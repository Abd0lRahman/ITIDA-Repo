
ITIDARTOSSession2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004c9e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000066  00800060  00004c9e  00004d32  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000027a  008000c6  008000c6  00004d98  2**0
                  ALLOC
  3 .stab         00005ef8  00000000  00000000  00004d98  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000383a  00000000  00000000  0000ac90  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  0000e4ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  0000e62a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  0000e7b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  000107fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  000118ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00012884  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00012a04  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  00012cc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013554  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9d 0d 	jmp	0x1b3a	; 0x1b3a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e9       	ldi	r30, 0x9E	; 158
      68:	fc e4       	ldi	r31, 0x4C	; 76
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3c       	cpi	r26, 0xC6	; 198
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a6 ec       	ldi	r26, 0xC6	; 198
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 34       	cpi	r26, 0x40	; 64
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 78 20 	call	0x40f0	; 0x40f0 <main>
      8a:	0c 94 4d 26 	jmp	0x4c9a	; 0x4c9a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ee 25 	jmp	0x4bdc	; 0x4bdc <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ab ea       	ldi	r26, 0xAB	; 171
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 0a 26 	jmp	0x4c14	; 0x4c14 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 fa 25 	jmp	0x4bf4	; 0x4bf4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 16 26 	jmp	0x4c2c	; 0x4c2c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 fa 25 	jmp	0x4bf4	; 0x4bf4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 16 26 	jmp	0x4c2c	; 0x4c2c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ee 25 	jmp	0x4bdc	; 0x4bdc <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8b ea       	ldi	r24, 0xAB	; 171
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 0a 26 	jmp	0x4c14	; 0x4c14 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 f6 25 	jmp	0x4bec	; 0x4bec <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6b ea       	ldi	r22, 0xAB	; 171
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 12 26 	jmp	0x4c24	; 0x4c24 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 fa 25 	jmp	0x4bf4	; 0x4bf4 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 16 26 	jmp	0x4c2c	; 0x4c2c <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 fa 25 	jmp	0x4bf4	; 0x4bf4 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 16 26 	jmp	0x4c2c	; 0x4c2c <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 fa 25 	jmp	0x4bf4	; 0x4bf4 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 16 26 	jmp	0x4c2c	; 0x4c2c <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 fe 25 	jmp	0x4bfc	; 0x4bfc <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 1a 26 	jmp	0x4c34	; 0x4c34 <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62
     ca6:	27 97       	sbiw	r28, 0x07	; 7
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	9d 83       	std	Y+5, r25	; 0x05
     cb4:	8c 83       	std	Y+4, r24	; 0x04
     cb6:	6e 83       	std	Y+6, r22	; 0x06
     cb8:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     cba:	8a e1       	ldi	r24, 0x1A	; 26
     cbc:	90 e0       	ldi	r25, 0x00	; 0
     cbe:	0e 94 27 09 	call	0x124e	; 0x124e <pvPortMalloc>
     cc2:	9a 83       	std	Y+2, r25	; 0x02
     cc4:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     cc6:	89 81       	ldd	r24, Y+1	; 0x01
     cc8:	9a 81       	ldd	r25, Y+2	; 0x02
     cca:	00 97       	sbiw	r24, 0x00	; 0
     ccc:	09 f4       	brne	.+2      	; 0xcd0 <xCoRoutineCreate+0x32>
     cce:	6f c0       	rjmp	.+222    	; 0xdae <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     cd0:	80 91 c6 00 	lds	r24, 0x00C6
     cd4:	90 91 c7 00 	lds	r25, 0x00C7
     cd8:	00 97       	sbiw	r24, 0x00	; 0
     cda:	41 f4       	brne	.+16     	; 0xcec <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     cdc:	89 81       	ldd	r24, Y+1	; 0x01
     cde:	9a 81       	ldd	r25, Y+2	; 0x02
     ce0:	90 93 c7 00 	sts	0x00C7, r25
     ce4:	80 93 c6 00 	sts	0x00C6, r24
			prvInitialiseCoRoutineLists();
     ce8:	0e 94 b6 08 	call	0x116c	; 0x116c <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     cec:	8e 81       	ldd	r24, Y+6	; 0x06
     cee:	82 30       	cpi	r24, 0x02	; 2
     cf0:	10 f0       	brcs	.+4      	; 0xcf6 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     cf6:	e9 81       	ldd	r30, Y+1	; 0x01
     cf8:	fa 81       	ldd	r31, Y+2	; 0x02
     cfa:	11 8e       	std	Z+25, r1	; 0x19
     cfc:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     cfe:	e9 81       	ldd	r30, Y+1	; 0x01
     d00:	fa 81       	ldd	r31, Y+2	; 0x02
     d02:	8e 81       	ldd	r24, Y+6	; 0x06
     d04:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     d06:	e9 81       	ldd	r30, Y+1	; 0x01
     d08:	fa 81       	ldd	r31, Y+2	; 0x02
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     d0e:	e9 81       	ldd	r30, Y+1	; 0x01
     d10:	fa 81       	ldd	r31, Y+2	; 0x02
     d12:	8c 81       	ldd	r24, Y+4	; 0x04
     d14:	9d 81       	ldd	r25, Y+5	; 0x05
     d16:	91 83       	std	Z+1, r25	; 0x01
     d18:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     d1a:	89 81       	ldd	r24, Y+1	; 0x01
     d1c:	9a 81       	ldd	r25, Y+2	; 0x02
     d1e:	02 96       	adiw	r24, 0x02	; 2
     d20:	0e 94 bd 09 	call	0x137a	; 0x137a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     d24:	89 81       	ldd	r24, Y+1	; 0x01
     d26:	9a 81       	ldd	r25, Y+2	; 0x02
     d28:	0c 96       	adiw	r24, 0x0c	; 12
     d2a:	0e 94 bd 09 	call	0x137a	; 0x137a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     d2e:	e9 81       	ldd	r30, Y+1	; 0x01
     d30:	fa 81       	ldd	r31, Y+2	; 0x02
     d32:	89 81       	ldd	r24, Y+1	; 0x01
     d34:	9a 81       	ldd	r25, Y+2	; 0x02
     d36:	91 87       	std	Z+9, r25	; 0x09
     d38:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     d3a:	e9 81       	ldd	r30, Y+1	; 0x01
     d3c:	fa 81       	ldd	r31, Y+2	; 0x02
     d3e:	89 81       	ldd	r24, Y+1	; 0x01
     d40:	9a 81       	ldd	r25, Y+2	; 0x02
     d42:	93 8b       	std	Z+19, r25	; 0x13
     d44:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     d46:	8e 81       	ldd	r24, Y+6	; 0x06
     d48:	28 2f       	mov	r18, r24
     d4a:	30 e0       	ldi	r19, 0x00	; 0
     d4c:	82 e0       	ldi	r24, 0x02	; 2
     d4e:	90 e0       	ldi	r25, 0x00	; 0
     d50:	82 1b       	sub	r24, r18
     d52:	93 0b       	sbc	r25, r19
     d54:	e9 81       	ldd	r30, Y+1	; 0x01
     d56:	fa 81       	ldd	r31, Y+2	; 0x02
     d58:	95 87       	std	Z+13, r25	; 0x0d
     d5a:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     d5c:	e9 81       	ldd	r30, Y+1	; 0x01
     d5e:	fa 81       	ldd	r31, Y+2	; 0x02
     d60:	96 89       	ldd	r25, Z+22	; 0x16
     d62:	80 91 c8 00 	lds	r24, 0x00C8
     d66:	89 17       	cp	r24, r25
     d68:	28 f4       	brcc	.+10     	; 0xd74 <xCoRoutineCreate+0xd6>
     d6a:	e9 81       	ldd	r30, Y+1	; 0x01
     d6c:	fa 81       	ldd	r31, Y+2	; 0x02
     d6e:	86 89       	ldd	r24, Z+22	; 0x16
     d70:	80 93 c8 00 	sts	0x00C8, r24
     d74:	e9 81       	ldd	r30, Y+1	; 0x01
     d76:	fa 81       	ldd	r31, Y+2	; 0x02
     d78:	86 89       	ldd	r24, Z+22	; 0x16
     d7a:	28 2f       	mov	r18, r24
     d7c:	30 e0       	ldi	r19, 0x00	; 0
     d7e:	c9 01       	movw	r24, r18
     d80:	88 0f       	add	r24, r24
     d82:	99 1f       	adc	r25, r25
     d84:	88 0f       	add	r24, r24
     d86:	99 1f       	adc	r25, r25
     d88:	88 0f       	add	r24, r24
     d8a:	99 1f       	adc	r25, r25
     d8c:	82 0f       	add	r24, r18
     d8e:	93 1f       	adc	r25, r19
     d90:	ac 01       	movw	r20, r24
     d92:	41 53       	subi	r20, 0x31	; 49
     d94:	5f 4f       	sbci	r21, 0xFF	; 255
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	9a 81       	ldd	r25, Y+2	; 0x02
     d9a:	9c 01       	movw	r18, r24
     d9c:	2e 5f       	subi	r18, 0xFE	; 254
     d9e:	3f 4f       	sbci	r19, 0xFF	; 255
     da0:	ca 01       	movw	r24, r20
     da2:	b9 01       	movw	r22, r18
     da4:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>

		xReturn = pdPASS;
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	8b 83       	std	Y+3, r24	; 0x03
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     dae:	8f ef       	ldi	r24, 0xFF	; 255
     db0:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     db2:	8b 81       	ldd	r24, Y+3	; 0x03
}
     db4:	27 96       	adiw	r28, 0x07	; 7
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	f8 94       	cli
     dba:	de bf       	out	0x3e, r29	; 62
     dbc:	0f be       	out	0x3f, r0	; 63
     dbe:	cd bf       	out	0x3d, r28	; 61
     dc0:	cf 91       	pop	r28
     dc2:	df 91       	pop	r29
     dc4:	08 95       	ret

00000dc6 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     dc6:	df 93       	push	r29
     dc8:	cf 93       	push	r28
     dca:	00 d0       	rcall	.+0      	; 0xdcc <vCoRoutineAddToDelayedList+0x6>
     dcc:	00 d0       	rcall	.+0      	; 0xdce <vCoRoutineAddToDelayedList+0x8>
     dce:	00 d0       	rcall	.+0      	; 0xdd0 <vCoRoutineAddToDelayedList+0xa>
     dd0:	cd b7       	in	r28, 0x3d	; 61
     dd2:	de b7       	in	r29, 0x3e	; 62
     dd4:	9c 83       	std	Y+4, r25	; 0x04
     dd6:	8b 83       	std	Y+3, r24	; 0x03
     dd8:	7e 83       	std	Y+6, r23	; 0x06
     dda:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     ddc:	20 91 c9 00 	lds	r18, 0x00C9
     de0:	30 91 ca 00 	lds	r19, 0x00CA
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	82 0f       	add	r24, r18
     dea:	93 1f       	adc	r25, r19
     dec:	9a 83       	std	Y+2, r25	; 0x02
     dee:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     df0:	80 91 c6 00 	lds	r24, 0x00C6
     df4:	90 91 c7 00 	lds	r25, 0x00C7
     df8:	02 96       	adiw	r24, 0x02	; 2
     dfa:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     dfe:	e0 91 c6 00 	lds	r30, 0x00C6
     e02:	f0 91 c7 00 	lds	r31, 0x00C7
     e06:	89 81       	ldd	r24, Y+1	; 0x01
     e08:	9a 81       	ldd	r25, Y+2	; 0x02
     e0a:	93 83       	std	Z+3, r25	; 0x03
     e0c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     e0e:	20 91 c9 00 	lds	r18, 0x00C9
     e12:	30 91 ca 00 	lds	r19, 0x00CA
     e16:	89 81       	ldd	r24, Y+1	; 0x01
     e18:	9a 81       	ldd	r25, Y+2	; 0x02
     e1a:	82 17       	cp	r24, r18
     e1c:	93 07       	cpc	r25, r19
     e1e:	70 f4       	brcc	.+28     	; 0xe3c <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     e20:	80 91 f5 00 	lds	r24, 0x00F5
     e24:	90 91 f6 00 	lds	r25, 0x00F6
     e28:	20 91 c6 00 	lds	r18, 0x00C6
     e2c:	30 91 c7 00 	lds	r19, 0x00C7
     e30:	2e 5f       	subi	r18, 0xFE	; 254
     e32:	3f 4f       	sbci	r19, 0xFF	; 255
     e34:	b9 01       	movw	r22, r18
     e36:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsert>
     e3a:	0d c0       	rjmp	.+26     	; 0xe56 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     e3c:	80 91 f3 00 	lds	r24, 0x00F3
     e40:	90 91 f4 00 	lds	r25, 0x00F4
     e44:	20 91 c6 00 	lds	r18, 0x00C6
     e48:	30 91 c7 00 	lds	r19, 0x00C7
     e4c:	2e 5f       	subi	r18, 0xFE	; 254
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsert>
	}

	if( pxEventList )
     e56:	8d 81       	ldd	r24, Y+5	; 0x05
     e58:	9e 81       	ldd	r25, Y+6	; 0x06
     e5a:	00 97       	sbiw	r24, 0x00	; 0
     e5c:	61 f0       	breq	.+24     	; 0xe76 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     e5e:	80 91 c6 00 	lds	r24, 0x00C6
     e62:	90 91 c7 00 	lds	r25, 0x00C7
     e66:	9c 01       	movw	r18, r24
     e68:	24 5f       	subi	r18, 0xF4	; 244
     e6a:	3f 4f       	sbci	r19, 0xFF	; 255
     e6c:	8d 81       	ldd	r24, Y+5	; 0x05
     e6e:	9e 81       	ldd	r25, Y+6	; 0x06
     e70:	b9 01       	movw	r22, r18
     e72:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsert>
	}
}
     e76:	26 96       	adiw	r28, 0x06	; 6
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	f8 94       	cli
     e7c:	de bf       	out	0x3e, r29	; 62
     e7e:	0f be       	out	0x3f, r0	; 63
     e80:	cd bf       	out	0x3d, r28	; 61
     e82:	cf 91       	pop	r28
     e84:	df 91       	pop	r29
     e86:	08 95       	ret

00000e88 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     e88:	df 93       	push	r29
     e8a:	cf 93       	push	r28
     e8c:	00 d0       	rcall	.+0      	; 0xe8e <prvCheckPendingReadyList+0x6>
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	3a c0       	rjmp	.+116    	; 0xf08 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     e94:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     e96:	e0 91 fc 00 	lds	r30, 0x00FC
     e9a:	f0 91 fd 00 	lds	r31, 0x00FD
     e9e:	86 81       	ldd	r24, Z+6	; 0x06
     ea0:	97 81       	ldd	r25, Z+7	; 0x07
     ea2:	9a 83       	std	Y+2, r25	; 0x02
     ea4:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     ea6:	89 81       	ldd	r24, Y+1	; 0x01
     ea8:	9a 81       	ldd	r25, Y+2	; 0x02
     eaa:	0c 96       	adiw	r24, 0x0c	; 12
     eac:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
		}
		portENABLE_INTERRUPTS();
     eb0:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     eb2:	89 81       	ldd	r24, Y+1	; 0x01
     eb4:	9a 81       	ldd	r25, Y+2	; 0x02
     eb6:	02 96       	adiw	r24, 0x02	; 2
     eb8:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     ebc:	e9 81       	ldd	r30, Y+1	; 0x01
     ebe:	fa 81       	ldd	r31, Y+2	; 0x02
     ec0:	96 89       	ldd	r25, Z+22	; 0x16
     ec2:	80 91 c8 00 	lds	r24, 0x00C8
     ec6:	89 17       	cp	r24, r25
     ec8:	28 f4       	brcc	.+10     	; 0xed4 <prvCheckPendingReadyList+0x4c>
     eca:	e9 81       	ldd	r30, Y+1	; 0x01
     ecc:	fa 81       	ldd	r31, Y+2	; 0x02
     ece:	86 89       	ldd	r24, Z+22	; 0x16
     ed0:	80 93 c8 00 	sts	0x00C8, r24
     ed4:	e9 81       	ldd	r30, Y+1	; 0x01
     ed6:	fa 81       	ldd	r31, Y+2	; 0x02
     ed8:	86 89       	ldd	r24, Z+22	; 0x16
     eda:	28 2f       	mov	r18, r24
     edc:	30 e0       	ldi	r19, 0x00	; 0
     ede:	c9 01       	movw	r24, r18
     ee0:	88 0f       	add	r24, r24
     ee2:	99 1f       	adc	r25, r25
     ee4:	88 0f       	add	r24, r24
     ee6:	99 1f       	adc	r25, r25
     ee8:	88 0f       	add	r24, r24
     eea:	99 1f       	adc	r25, r25
     eec:	82 0f       	add	r24, r18
     eee:	93 1f       	adc	r25, r19
     ef0:	ac 01       	movw	r20, r24
     ef2:	41 53       	subi	r20, 0x31	; 49
     ef4:	5f 4f       	sbci	r21, 0xFF	; 255
     ef6:	89 81       	ldd	r24, Y+1	; 0x01
     ef8:	9a 81       	ldd	r25, Y+2	; 0x02
     efa:	9c 01       	movw	r18, r24
     efc:	2e 5f       	subi	r18, 0xFE	; 254
     efe:	3f 4f       	sbci	r19, 0xFF	; 255
     f00:	ca 01       	movw	r24, r20
     f02:	b9 01       	movw	r22, r18
     f04:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     f08:	80 91 f7 00 	lds	r24, 0x00F7
     f0c:	88 23       	and	r24, r24
     f0e:	09 f0       	breq	.+2      	; 0xf12 <prvCheckPendingReadyList+0x8a>
     f10:	c1 cf       	rjmp	.-126    	; 0xe94 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	cf 91       	pop	r28
     f18:	df 91       	pop	r29
     f1a:	08 95       	ret

00000f1c <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     f1c:	df 93       	push	r29
     f1e:	cf 93       	push	r28
     f20:	00 d0       	rcall	.+0      	; 0xf22 <prvCheckDelayedList+0x6>
     f22:	00 d0       	rcall	.+0      	; 0xf24 <prvCheckDelayedList+0x8>
     f24:	cd b7       	in	r28, 0x3d	; 61
     f26:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     f28:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <xTaskGetTickCount>
     f2c:	20 91 cb 00 	lds	r18, 0x00CB
     f30:	30 91 cc 00 	lds	r19, 0x00CC
     f34:	82 1b       	sub	r24, r18
     f36:	93 0b       	sbc	r25, r19
     f38:	90 93 ce 00 	sts	0x00CE, r25
     f3c:	80 93 cd 00 	sts	0x00CD, r24
     f40:	85 c0       	rjmp	.+266    	; 0x104c <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     f42:	80 91 c9 00 	lds	r24, 0x00C9
     f46:	90 91 ca 00 	lds	r25, 0x00CA
     f4a:	01 96       	adiw	r24, 0x01	; 1
     f4c:	90 93 ca 00 	sts	0x00CA, r25
     f50:	80 93 c9 00 	sts	0x00C9, r24
		xPassedTicks--;
     f54:	80 91 cd 00 	lds	r24, 0x00CD
     f58:	90 91 ce 00 	lds	r25, 0x00CE
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	90 93 ce 00 	sts	0x00CE, r25
     f62:	80 93 cd 00 	sts	0x00CD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     f66:	80 91 c9 00 	lds	r24, 0x00C9
     f6a:	90 91 ca 00 	lds	r25, 0x00CA
     f6e:	00 97       	sbiw	r24, 0x00	; 0
     f70:	09 f0       	breq	.+2      	; 0xf74 <prvCheckDelayedList+0x58>
     f72:	64 c0       	rjmp	.+200    	; 0x103c <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     f74:	80 91 f3 00 	lds	r24, 0x00F3
     f78:	90 91 f4 00 	lds	r25, 0x00F4
     f7c:	9a 83       	std	Y+2, r25	; 0x02
     f7e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     f80:	80 91 f5 00 	lds	r24, 0x00F5
     f84:	90 91 f6 00 	lds	r25, 0x00F6
     f88:	90 93 f4 00 	sts	0x00F4, r25
     f8c:	80 93 f3 00 	sts	0x00F3, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	9a 81       	ldd	r25, Y+2	; 0x02
     f94:	90 93 f6 00 	sts	0x00F6, r25
     f98:	80 93 f5 00 	sts	0x00F5, r24
     f9c:	4f c0       	rjmp	.+158    	; 0x103c <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     f9e:	e0 91 f3 00 	lds	r30, 0x00F3
     fa2:	f0 91 f4 00 	lds	r31, 0x00F4
     fa6:	05 80       	ldd	r0, Z+5	; 0x05
     fa8:	f6 81       	ldd	r31, Z+6	; 0x06
     faa:	e0 2d       	mov	r30, r0
     fac:	86 81       	ldd	r24, Z+6	; 0x06
     fae:	97 81       	ldd	r25, Z+7	; 0x07
     fb0:	9c 83       	std	Y+4, r25	; 0x04
     fb2:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     fb4:	eb 81       	ldd	r30, Y+3	; 0x03
     fb6:	fc 81       	ldd	r31, Y+4	; 0x04
     fb8:	22 81       	ldd	r18, Z+2	; 0x02
     fba:	33 81       	ldd	r19, Z+3	; 0x03
     fbc:	80 91 c9 00 	lds	r24, 0x00C9
     fc0:	90 91 ca 00 	lds	r25, 0x00CA
     fc4:	82 17       	cp	r24, r18
     fc6:	93 07       	cpc	r25, r19
     fc8:	08 f4       	brcc	.+2      	; 0xfcc <prvCheckDelayedList+0xb0>
     fca:	40 c0       	rjmp	.+128    	; 0x104c <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     fcc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     fce:	8b 81       	ldd	r24, Y+3	; 0x03
     fd0:	9c 81       	ldd	r25, Y+4	; 0x04
     fd2:	02 96       	adiw	r24, 0x02	; 2
     fd4:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     fd8:	eb 81       	ldd	r30, Y+3	; 0x03
     fda:	fc 81       	ldd	r31, Y+4	; 0x04
     fdc:	84 89       	ldd	r24, Z+20	; 0x14
     fde:	95 89       	ldd	r25, Z+21	; 0x15
     fe0:	00 97       	sbiw	r24, 0x00	; 0
     fe2:	29 f0       	breq	.+10     	; 0xfee <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	9c 81       	ldd	r25, Y+4	; 0x04
     fe8:	0c 96       	adiw	r24, 0x0c	; 12
     fea:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     fee:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     ff0:	eb 81       	ldd	r30, Y+3	; 0x03
     ff2:	fc 81       	ldd	r31, Y+4	; 0x04
     ff4:	96 89       	ldd	r25, Z+22	; 0x16
     ff6:	80 91 c8 00 	lds	r24, 0x00C8
     ffa:	89 17       	cp	r24, r25
     ffc:	28 f4       	brcc	.+10     	; 0x1008 <prvCheckDelayedList+0xec>
     ffe:	eb 81       	ldd	r30, Y+3	; 0x03
    1000:	fc 81       	ldd	r31, Y+4	; 0x04
    1002:	86 89       	ldd	r24, Z+22	; 0x16
    1004:	80 93 c8 00 	sts	0x00C8, r24
    1008:	eb 81       	ldd	r30, Y+3	; 0x03
    100a:	fc 81       	ldd	r31, Y+4	; 0x04
    100c:	86 89       	ldd	r24, Z+22	; 0x16
    100e:	28 2f       	mov	r18, r24
    1010:	30 e0       	ldi	r19, 0x00	; 0
    1012:	c9 01       	movw	r24, r18
    1014:	88 0f       	add	r24, r24
    1016:	99 1f       	adc	r25, r25
    1018:	88 0f       	add	r24, r24
    101a:	99 1f       	adc	r25, r25
    101c:	88 0f       	add	r24, r24
    101e:	99 1f       	adc	r25, r25
    1020:	82 0f       	add	r24, r18
    1022:	93 1f       	adc	r25, r19
    1024:	ac 01       	movw	r20, r24
    1026:	41 53       	subi	r20, 0x31	; 49
    1028:	5f 4f       	sbci	r21, 0xFF	; 255
    102a:	8b 81       	ldd	r24, Y+3	; 0x03
    102c:	9c 81       	ldd	r25, Y+4	; 0x04
    102e:	9c 01       	movw	r18, r24
    1030:	2e 5f       	subi	r18, 0xFE	; 254
    1032:	3f 4f       	sbci	r19, 0xFF	; 255
    1034:	ca 01       	movw	r24, r20
    1036:	b9 01       	movw	r22, r18
    1038:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    103c:	e0 91 f3 00 	lds	r30, 0x00F3
    1040:	f0 91 f4 00 	lds	r31, 0x00F4
    1044:	80 81       	ld	r24, Z
    1046:	88 23       	and	r24, r24
    1048:	09 f0       	breq	.+2      	; 0x104c <prvCheckDelayedList+0x130>
    104a:	a9 cf       	rjmp	.-174    	; 0xf9e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    104c:	80 91 cd 00 	lds	r24, 0x00CD
    1050:	90 91 ce 00 	lds	r25, 0x00CE
    1054:	00 97       	sbiw	r24, 0x00	; 0
    1056:	09 f0       	breq	.+2      	; 0x105a <prvCheckDelayedList+0x13e>
    1058:	74 cf       	rjmp	.-280    	; 0xf42 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    105a:	80 91 c9 00 	lds	r24, 0x00C9
    105e:	90 91 ca 00 	lds	r25, 0x00CA
    1062:	90 93 cc 00 	sts	0x00CC, r25
    1066:	80 93 cb 00 	sts	0x00CB, r24
}
    106a:	0f 90       	pop	r0
    106c:	0f 90       	pop	r0
    106e:	0f 90       	pop	r0
    1070:	0f 90       	pop	r0
    1072:	cf 91       	pop	r28
    1074:	df 91       	pop	r29
    1076:	08 95       	ret

00001078 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	00 d0       	rcall	.+0      	; 0x107e <vCoRoutineSchedule+0x6>
    107e:	cd b7       	in	r28, 0x3d	; 61
    1080:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1082:	0e 94 44 07 	call	0xe88	; 0xe88 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1086:	0e 94 8e 07 	call	0xf1c	; 0xf1c <prvCheckDelayedList>
    108a:	0a c0       	rjmp	.+20     	; 0x10a0 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    108c:	80 91 c8 00 	lds	r24, 0x00C8
    1090:	88 23       	and	r24, r24
    1092:	09 f4       	brne	.+2      	; 0x1096 <vCoRoutineSchedule+0x1e>
    1094:	66 c0       	rjmp	.+204    	; 0x1162 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1096:	80 91 c8 00 	lds	r24, 0x00C8
    109a:	81 50       	subi	r24, 0x01	; 1
    109c:	80 93 c8 00 	sts	0x00C8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    10a0:	80 91 c8 00 	lds	r24, 0x00C8
    10a4:	28 2f       	mov	r18, r24
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	c9 01       	movw	r24, r18
    10aa:	88 0f       	add	r24, r24
    10ac:	99 1f       	adc	r25, r25
    10ae:	88 0f       	add	r24, r24
    10b0:	99 1f       	adc	r25, r25
    10b2:	88 0f       	add	r24, r24
    10b4:	99 1f       	adc	r25, r25
    10b6:	82 0f       	add	r24, r18
    10b8:	93 1f       	adc	r25, r19
    10ba:	fc 01       	movw	r30, r24
    10bc:	e1 53       	subi	r30, 0x31	; 49
    10be:	ff 4f       	sbci	r31, 0xFF	; 255
    10c0:	80 81       	ld	r24, Z
    10c2:	88 23       	and	r24, r24
    10c4:	19 f3       	breq	.-58     	; 0x108c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    10c6:	80 91 c8 00 	lds	r24, 0x00C8
    10ca:	28 2f       	mov	r18, r24
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	c9 01       	movw	r24, r18
    10d0:	88 0f       	add	r24, r24
    10d2:	99 1f       	adc	r25, r25
    10d4:	88 0f       	add	r24, r24
    10d6:	99 1f       	adc	r25, r25
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	82 0f       	add	r24, r18
    10de:	93 1f       	adc	r25, r19
    10e0:	81 53       	subi	r24, 0x31	; 49
    10e2:	9f 4f       	sbci	r25, 0xFF	; 255
    10e4:	9a 83       	std	Y+2, r25	; 0x02
    10e6:	89 83       	std	Y+1, r24	; 0x01
    10e8:	e9 81       	ldd	r30, Y+1	; 0x01
    10ea:	fa 81       	ldd	r31, Y+2	; 0x02
    10ec:	01 80       	ldd	r0, Z+1	; 0x01
    10ee:	f2 81       	ldd	r31, Z+2	; 0x02
    10f0:	e0 2d       	mov	r30, r0
    10f2:	82 81       	ldd	r24, Z+2	; 0x02
    10f4:	93 81       	ldd	r25, Z+3	; 0x03
    10f6:	e9 81       	ldd	r30, Y+1	; 0x01
    10f8:	fa 81       	ldd	r31, Y+2	; 0x02
    10fa:	92 83       	std	Z+2, r25	; 0x02
    10fc:	81 83       	std	Z+1, r24	; 0x01
    10fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1100:	fa 81       	ldd	r31, Y+2	; 0x02
    1102:	21 81       	ldd	r18, Z+1	; 0x01
    1104:	32 81       	ldd	r19, Z+2	; 0x02
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	9a 81       	ldd	r25, Y+2	; 0x02
    110a:	03 96       	adiw	r24, 0x03	; 3
    110c:	28 17       	cp	r18, r24
    110e:	39 07       	cpc	r19, r25
    1110:	59 f4       	brne	.+22     	; 0x1128 <vCoRoutineSchedule+0xb0>
    1112:	e9 81       	ldd	r30, Y+1	; 0x01
    1114:	fa 81       	ldd	r31, Y+2	; 0x02
    1116:	01 80       	ldd	r0, Z+1	; 0x01
    1118:	f2 81       	ldd	r31, Z+2	; 0x02
    111a:	e0 2d       	mov	r30, r0
    111c:	82 81       	ldd	r24, Z+2	; 0x02
    111e:	93 81       	ldd	r25, Z+3	; 0x03
    1120:	e9 81       	ldd	r30, Y+1	; 0x01
    1122:	fa 81       	ldd	r31, Y+2	; 0x02
    1124:	92 83       	std	Z+2, r25	; 0x02
    1126:	81 83       	std	Z+1, r24	; 0x01
    1128:	e9 81       	ldd	r30, Y+1	; 0x01
    112a:	fa 81       	ldd	r31, Y+2	; 0x02
    112c:	01 80       	ldd	r0, Z+1	; 0x01
    112e:	f2 81       	ldd	r31, Z+2	; 0x02
    1130:	e0 2d       	mov	r30, r0
    1132:	86 81       	ldd	r24, Z+6	; 0x06
    1134:	97 81       	ldd	r25, Z+7	; 0x07
    1136:	90 93 c7 00 	sts	0x00C7, r25
    113a:	80 93 c6 00 	sts	0x00C6, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    113e:	e0 91 c6 00 	lds	r30, 0x00C6
    1142:	f0 91 c7 00 	lds	r31, 0x00C7
    1146:	40 81       	ld	r20, Z
    1148:	51 81       	ldd	r21, Z+1	; 0x01
    114a:	80 91 c6 00 	lds	r24, 0x00C6
    114e:	90 91 c7 00 	lds	r25, 0x00C7
    1152:	e0 91 c6 00 	lds	r30, 0x00C6
    1156:	f0 91 c7 00 	lds	r31, 0x00C7
    115a:	27 89       	ldd	r18, Z+23	; 0x17
    115c:	62 2f       	mov	r22, r18
    115e:	fa 01       	movw	r30, r20
    1160:	09 95       	icall

	return;
}
    1162:	0f 90       	pop	r0
    1164:	0f 90       	pop	r0
    1166:	cf 91       	pop	r28
    1168:	df 91       	pop	r29
    116a:	08 95       	ret

0000116c <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    116c:	df 93       	push	r29
    116e:	cf 93       	push	r28
    1170:	0f 92       	push	r0
    1172:	cd b7       	in	r28, 0x3d	; 61
    1174:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1176:	19 82       	std	Y+1, r1	; 0x01
    1178:	13 c0       	rjmp	.+38     	; 0x11a0 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    117a:	89 81       	ldd	r24, Y+1	; 0x01
    117c:	28 2f       	mov	r18, r24
    117e:	30 e0       	ldi	r19, 0x00	; 0
    1180:	c9 01       	movw	r24, r18
    1182:	88 0f       	add	r24, r24
    1184:	99 1f       	adc	r25, r25
    1186:	88 0f       	add	r24, r24
    1188:	99 1f       	adc	r25, r25
    118a:	88 0f       	add	r24, r24
    118c:	99 1f       	adc	r25, r25
    118e:	82 0f       	add	r24, r18
    1190:	93 1f       	adc	r25, r19
    1192:	81 53       	subi	r24, 0x31	; 49
    1194:	9f 4f       	sbci	r25, 0xFF	; 255
    1196:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    119a:	89 81       	ldd	r24, Y+1	; 0x01
    119c:	8f 5f       	subi	r24, 0xFF	; 255
    119e:	89 83       	std	Y+1, r24	; 0x01
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
    11a2:	82 30       	cpi	r24, 0x02	; 2
    11a4:	50 f3       	brcs	.-44     	; 0x117a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    11a6:	81 ee       	ldi	r24, 0xE1	; 225
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    11ae:	8a ee       	ldi	r24, 0xEA	; 234
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    11b6:	87 ef       	ldi	r24, 0xF7	; 247
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    11be:	81 ee       	ldi	r24, 0xE1	; 225
    11c0:	90 e0       	ldi	r25, 0x00	; 0
    11c2:	90 93 f4 00 	sts	0x00F4, r25
    11c6:	80 93 f3 00 	sts	0x00F3, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    11ca:	8a ee       	ldi	r24, 0xEA	; 234
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	90 93 f6 00 	sts	0x00F6, r25
    11d2:	80 93 f5 00 	sts	0x00F5, r24
}
    11d6:	0f 90       	pop	r0
    11d8:	cf 91       	pop	r28
    11da:	df 91       	pop	r29
    11dc:	08 95       	ret

000011de <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    11de:	df 93       	push	r29
    11e0:	cf 93       	push	r28
    11e2:	00 d0       	rcall	.+0      	; 0x11e4 <xCoRoutineRemoveFromEventList+0x6>
    11e4:	00 d0       	rcall	.+0      	; 0x11e6 <xCoRoutineRemoveFromEventList+0x8>
    11e6:	0f 92       	push	r0
    11e8:	cd b7       	in	r28, 0x3d	; 61
    11ea:	de b7       	in	r29, 0x3e	; 62
    11ec:	9d 83       	std	Y+5, r25	; 0x05
    11ee:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    11f0:	ec 81       	ldd	r30, Y+4	; 0x04
    11f2:	fd 81       	ldd	r31, Y+5	; 0x05
    11f4:	05 80       	ldd	r0, Z+5	; 0x05
    11f6:	f6 81       	ldd	r31, Z+6	; 0x06
    11f8:	e0 2d       	mov	r30, r0
    11fa:	86 81       	ldd	r24, Z+6	; 0x06
    11fc:	97 81       	ldd	r25, Z+7	; 0x07
    11fe:	9b 83       	std	Y+3, r25	; 0x03
    1200:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1202:	8a 81       	ldd	r24, Y+2	; 0x02
    1204:	9b 81       	ldd	r25, Y+3	; 0x03
    1206:	0c 96       	adiw	r24, 0x0c	; 12
    1208:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	9b 81       	ldd	r25, Y+3	; 0x03
    1210:	9c 01       	movw	r18, r24
    1212:	24 5f       	subi	r18, 0xF4	; 244
    1214:	3f 4f       	sbci	r19, 0xFF	; 255
    1216:	87 ef       	ldi	r24, 0xF7	; 247
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	b9 01       	movw	r22, r18
    121c:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1220:	ea 81       	ldd	r30, Y+2	; 0x02
    1222:	fb 81       	ldd	r31, Y+3	; 0x03
    1224:	96 89       	ldd	r25, Z+22	; 0x16
    1226:	e0 91 c6 00 	lds	r30, 0x00C6
    122a:	f0 91 c7 00 	lds	r31, 0x00C7
    122e:	86 89       	ldd	r24, Z+22	; 0x16
    1230:	98 17       	cp	r25, r24
    1232:	18 f0       	brcs	.+6      	; 0x123a <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    1234:	81 e0       	ldi	r24, 0x01	; 1
    1236:	89 83       	std	Y+1, r24	; 0x01
    1238:	01 c0       	rjmp	.+2      	; 0x123c <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    123a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    123c:	89 81       	ldd	r24, Y+1	; 0x01
}
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	0f 90       	pop	r0
    1248:	cf 91       	pop	r28
    124a:	df 91       	pop	r29
    124c:	08 95       	ret

0000124e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    124e:	df 93       	push	r29
    1250:	cf 93       	push	r28
    1252:	00 d0       	rcall	.+0      	; 0x1254 <pvPortMalloc+0x6>
    1254:	00 d0       	rcall	.+0      	; 0x1256 <pvPortMalloc+0x8>
    1256:	cd b7       	in	r28, 0x3d	; 61
    1258:	de b7       	in	r29, 0x3e	; 62
    125a:	9c 83       	std	Y+4, r25	; 0x04
    125c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    125e:	1a 82       	std	Y+2, r1	; 0x02
    1260:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1262:	0e 94 5d 14 	call	0x28ba	; 0x28ba <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1266:	80 91 00 01 	lds	r24, 0x0100
    126a:	90 91 01 01 	lds	r25, 0x0101
    126e:	2b 81       	ldd	r18, Y+3	; 0x03
    1270:	3c 81       	ldd	r19, Y+4	; 0x04
    1272:	82 0f       	add	r24, r18
    1274:	93 1f       	adc	r25, r19
    1276:	21 e0       	ldi	r18, 0x01	; 1
    1278:	84 3f       	cpi	r24, 0xF4	; 244
    127a:	92 07       	cpc	r25, r18
    127c:	18 f5       	brcc	.+70     	; 0x12c4 <pvPortMalloc+0x76>
    127e:	20 91 00 01 	lds	r18, 0x0100
    1282:	30 91 01 01 	lds	r19, 0x0101
    1286:	8b 81       	ldd	r24, Y+3	; 0x03
    1288:	9c 81       	ldd	r25, Y+4	; 0x04
    128a:	28 0f       	add	r18, r24
    128c:	39 1f       	adc	r19, r25
    128e:	80 91 00 01 	lds	r24, 0x0100
    1292:	90 91 01 01 	lds	r25, 0x0101
    1296:	82 17       	cp	r24, r18
    1298:	93 07       	cpc	r25, r19
    129a:	a0 f4       	brcc	.+40     	; 0x12c4 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    129c:	80 91 00 01 	lds	r24, 0x0100
    12a0:	90 91 01 01 	lds	r25, 0x0101
    12a4:	8e 5f       	subi	r24, 0xFE	; 254
    12a6:	9e 4f       	sbci	r25, 0xFE	; 254
    12a8:	9a 83       	std	Y+2, r25	; 0x02
    12aa:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    12ac:	20 91 00 01 	lds	r18, 0x0100
    12b0:	30 91 01 01 	lds	r19, 0x0101
    12b4:	8b 81       	ldd	r24, Y+3	; 0x03
    12b6:	9c 81       	ldd	r25, Y+4	; 0x04
    12b8:	82 0f       	add	r24, r18
    12ba:	93 1f       	adc	r25, r19
    12bc:	90 93 01 01 	sts	0x0101, r25
    12c0:	80 93 00 01 	sts	0x0100, r24
		}	
	}
	xTaskResumeAll();
    12c4:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    12c8:	89 81       	ldd	r24, Y+1	; 0x01
    12ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    12cc:	0f 90       	pop	r0
    12ce:	0f 90       	pop	r0
    12d0:	0f 90       	pop	r0
    12d2:	0f 90       	pop	r0
    12d4:	cf 91       	pop	r28
    12d6:	df 91       	pop	r29
    12d8:	08 95       	ret

000012da <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    12da:	df 93       	push	r29
    12dc:	cf 93       	push	r28
    12de:	00 d0       	rcall	.+0      	; 0x12e0 <vPortFree+0x6>
    12e0:	cd b7       	in	r28, 0x3d	; 61
    12e2:	de b7       	in	r29, 0x3e	; 62
    12e4:	9a 83       	std	Y+2, r25	; 0x02
    12e6:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	cf 91       	pop	r28
    12ee:	df 91       	pop	r29
    12f0:	08 95       	ret

000012f2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    12f2:	df 93       	push	r29
    12f4:	cf 93       	push	r28
    12f6:	cd b7       	in	r28, 0x3d	; 61
    12f8:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    12fa:	10 92 01 01 	sts	0x0101, r1
    12fe:	10 92 00 01 	sts	0x0100, r1
}
    1302:	cf 91       	pop	r28
    1304:	df 91       	pop	r29
    1306:	08 95       	ret

00001308 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1308:	df 93       	push	r29
    130a:	cf 93       	push	r28
    130c:	cd b7       	in	r28, 0x3d	; 61
    130e:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1310:	20 91 00 01 	lds	r18, 0x0100
    1314:	30 91 01 01 	lds	r19, 0x0101
    1318:	84 ef       	ldi	r24, 0xF4	; 244
    131a:	91 e0       	ldi	r25, 0x01	; 1
    131c:	82 1b       	sub	r24, r18
    131e:	93 0b       	sbc	r25, r19
}
    1320:	cf 91       	pop	r28
    1322:	df 91       	pop	r29
    1324:	08 95       	ret

00001326 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1326:	df 93       	push	r29
    1328:	cf 93       	push	r28
    132a:	00 d0       	rcall	.+0      	; 0x132c <vListInitialise+0x6>
    132c:	cd b7       	in	r28, 0x3d	; 61
    132e:	de b7       	in	r29, 0x3e	; 62
    1330:	9a 83       	std	Y+2, r25	; 0x02
    1332:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1334:	89 81       	ldd	r24, Y+1	; 0x01
    1336:	9a 81       	ldd	r25, Y+2	; 0x02
    1338:	03 96       	adiw	r24, 0x03	; 3
    133a:	e9 81       	ldd	r30, Y+1	; 0x01
    133c:	fa 81       	ldd	r31, Y+2	; 0x02
    133e:	92 83       	std	Z+2, r25	; 0x02
    1340:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1342:	e9 81       	ldd	r30, Y+1	; 0x01
    1344:	fa 81       	ldd	r31, Y+2	; 0x02
    1346:	8f ef       	ldi	r24, 0xFF	; 255
    1348:	9f ef       	ldi	r25, 0xFF	; 255
    134a:	94 83       	std	Z+4, r25	; 0x04
    134c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    134e:	89 81       	ldd	r24, Y+1	; 0x01
    1350:	9a 81       	ldd	r25, Y+2	; 0x02
    1352:	03 96       	adiw	r24, 0x03	; 3
    1354:	e9 81       	ldd	r30, Y+1	; 0x01
    1356:	fa 81       	ldd	r31, Y+2	; 0x02
    1358:	96 83       	std	Z+6, r25	; 0x06
    135a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	9a 81       	ldd	r25, Y+2	; 0x02
    1360:	03 96       	adiw	r24, 0x03	; 3
    1362:	e9 81       	ldd	r30, Y+1	; 0x01
    1364:	fa 81       	ldd	r31, Y+2	; 0x02
    1366:	90 87       	std	Z+8, r25	; 0x08
    1368:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    136a:	e9 81       	ldd	r30, Y+1	; 0x01
    136c:	fa 81       	ldd	r31, Y+2	; 0x02
    136e:	10 82       	st	Z, r1
}
    1370:	0f 90       	pop	r0
    1372:	0f 90       	pop	r0
    1374:	cf 91       	pop	r28
    1376:	df 91       	pop	r29
    1378:	08 95       	ret

0000137a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    137a:	df 93       	push	r29
    137c:	cf 93       	push	r28
    137e:	00 d0       	rcall	.+0      	; 0x1380 <vListInitialiseItem+0x6>
    1380:	cd b7       	in	r28, 0x3d	; 61
    1382:	de b7       	in	r29, 0x3e	; 62
    1384:	9a 83       	std	Y+2, r25	; 0x02
    1386:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1388:	e9 81       	ldd	r30, Y+1	; 0x01
    138a:	fa 81       	ldd	r31, Y+2	; 0x02
    138c:	11 86       	std	Z+9, r1	; 0x09
    138e:	10 86       	std	Z+8, r1	; 0x08
}
    1390:	0f 90       	pop	r0
    1392:	0f 90       	pop	r0
    1394:	cf 91       	pop	r28
    1396:	df 91       	pop	r29
    1398:	08 95       	ret

0000139a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    139a:	df 93       	push	r29
    139c:	cf 93       	push	r28
    139e:	00 d0       	rcall	.+0      	; 0x13a0 <vListInsertEnd+0x6>
    13a0:	00 d0       	rcall	.+0      	; 0x13a2 <vListInsertEnd+0x8>
    13a2:	00 d0       	rcall	.+0      	; 0x13a4 <vListInsertEnd+0xa>
    13a4:	cd b7       	in	r28, 0x3d	; 61
    13a6:	de b7       	in	r29, 0x3e	; 62
    13a8:	9c 83       	std	Y+4, r25	; 0x04
    13aa:	8b 83       	std	Y+3, r24	; 0x03
    13ac:	7e 83       	std	Y+6, r23	; 0x06
    13ae:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    13b0:	eb 81       	ldd	r30, Y+3	; 0x03
    13b2:	fc 81       	ldd	r31, Y+4	; 0x04
    13b4:	81 81       	ldd	r24, Z+1	; 0x01
    13b6:	92 81       	ldd	r25, Z+2	; 0x02
    13b8:	9a 83       	std	Y+2, r25	; 0x02
    13ba:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    13bc:	e9 81       	ldd	r30, Y+1	; 0x01
    13be:	fa 81       	ldd	r31, Y+2	; 0x02
    13c0:	82 81       	ldd	r24, Z+2	; 0x02
    13c2:	93 81       	ldd	r25, Z+3	; 0x03
    13c4:	ed 81       	ldd	r30, Y+5	; 0x05
    13c6:	fe 81       	ldd	r31, Y+6	; 0x06
    13c8:	93 83       	std	Z+3, r25	; 0x03
    13ca:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    13cc:	eb 81       	ldd	r30, Y+3	; 0x03
    13ce:	fc 81       	ldd	r31, Y+4	; 0x04
    13d0:	81 81       	ldd	r24, Z+1	; 0x01
    13d2:	92 81       	ldd	r25, Z+2	; 0x02
    13d4:	ed 81       	ldd	r30, Y+5	; 0x05
    13d6:	fe 81       	ldd	r31, Y+6	; 0x06
    13d8:	95 83       	std	Z+5, r25	; 0x05
    13da:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    13dc:	e9 81       	ldd	r30, Y+1	; 0x01
    13de:	fa 81       	ldd	r31, Y+2	; 0x02
    13e0:	02 80       	ldd	r0, Z+2	; 0x02
    13e2:	f3 81       	ldd	r31, Z+3	; 0x03
    13e4:	e0 2d       	mov	r30, r0
    13e6:	8d 81       	ldd	r24, Y+5	; 0x05
    13e8:	9e 81       	ldd	r25, Y+6	; 0x06
    13ea:	95 83       	std	Z+5, r25	; 0x05
    13ec:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    13ee:	8d 81       	ldd	r24, Y+5	; 0x05
    13f0:	9e 81       	ldd	r25, Y+6	; 0x06
    13f2:	e9 81       	ldd	r30, Y+1	; 0x01
    13f4:	fa 81       	ldd	r31, Y+2	; 0x02
    13f6:	93 83       	std	Z+3, r25	; 0x03
    13f8:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    13fa:	8d 81       	ldd	r24, Y+5	; 0x05
    13fc:	9e 81       	ldd	r25, Y+6	; 0x06
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	92 83       	std	Z+2, r25	; 0x02
    1404:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1406:	ed 81       	ldd	r30, Y+5	; 0x05
    1408:	fe 81       	ldd	r31, Y+6	; 0x06
    140a:	8b 81       	ldd	r24, Y+3	; 0x03
    140c:	9c 81       	ldd	r25, Y+4	; 0x04
    140e:	91 87       	std	Z+9, r25	; 0x09
    1410:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1412:	eb 81       	ldd	r30, Y+3	; 0x03
    1414:	fc 81       	ldd	r31, Y+4	; 0x04
    1416:	80 81       	ld	r24, Z
    1418:	8f 5f       	subi	r24, 0xFF	; 255
    141a:	eb 81       	ldd	r30, Y+3	; 0x03
    141c:	fc 81       	ldd	r31, Y+4	; 0x04
    141e:	80 83       	st	Z, r24
}
    1420:	26 96       	adiw	r28, 0x06	; 6
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	de bf       	out	0x3e, r29	; 62
    1428:	0f be       	out	0x3f, r0	; 63
    142a:	cd bf       	out	0x3d, r28	; 61
    142c:	cf 91       	pop	r28
    142e:	df 91       	pop	r29
    1430:	08 95       	ret

00001432 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1432:	df 93       	push	r29
    1434:	cf 93       	push	r28
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	28 97       	sbiw	r28, 0x08	; 8
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	de bf       	out	0x3e, r29	; 62
    1442:	0f be       	out	0x3f, r0	; 63
    1444:	cd bf       	out	0x3d, r28	; 61
    1446:	9e 83       	std	Y+6, r25	; 0x06
    1448:	8d 83       	std	Y+5, r24	; 0x05
    144a:	78 87       	std	Y+8, r23	; 0x08
    144c:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    144e:	ef 81       	ldd	r30, Y+7	; 0x07
    1450:	f8 85       	ldd	r31, Y+8	; 0x08
    1452:	80 81       	ld	r24, Z
    1454:	91 81       	ldd	r25, Z+1	; 0x01
    1456:	9a 83       	std	Y+2, r25	; 0x02
    1458:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	9a 81       	ldd	r25, Y+2	; 0x02
    145e:	2f ef       	ldi	r18, 0xFF	; 255
    1460:	8f 3f       	cpi	r24, 0xFF	; 255
    1462:	92 07       	cpc	r25, r18
    1464:	39 f4       	brne	.+14     	; 0x1474 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1466:	ed 81       	ldd	r30, Y+5	; 0x05
    1468:	fe 81       	ldd	r31, Y+6	; 0x06
    146a:	87 81       	ldd	r24, Z+7	; 0x07
    146c:	90 85       	ldd	r25, Z+8	; 0x08
    146e:	9c 83       	std	Y+4, r25	; 0x04
    1470:	8b 83       	std	Y+3, r24	; 0x03
    1472:	18 c0       	rjmp	.+48     	; 0x14a4 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1474:	8d 81       	ldd	r24, Y+5	; 0x05
    1476:	9e 81       	ldd	r25, Y+6	; 0x06
    1478:	03 96       	adiw	r24, 0x03	; 3
    147a:	9c 83       	std	Y+4, r25	; 0x04
    147c:	8b 83       	std	Y+3, r24	; 0x03
    147e:	06 c0       	rjmp	.+12     	; 0x148c <vListInsert+0x5a>
    1480:	eb 81       	ldd	r30, Y+3	; 0x03
    1482:	fc 81       	ldd	r31, Y+4	; 0x04
    1484:	82 81       	ldd	r24, Z+2	; 0x02
    1486:	93 81       	ldd	r25, Z+3	; 0x03
    1488:	9c 83       	std	Y+4, r25	; 0x04
    148a:	8b 83       	std	Y+3, r24	; 0x03
    148c:	eb 81       	ldd	r30, Y+3	; 0x03
    148e:	fc 81       	ldd	r31, Y+4	; 0x04
    1490:	02 80       	ldd	r0, Z+2	; 0x02
    1492:	f3 81       	ldd	r31, Z+3	; 0x03
    1494:	e0 2d       	mov	r30, r0
    1496:	20 81       	ld	r18, Z
    1498:	31 81       	ldd	r19, Z+1	; 0x01
    149a:	89 81       	ldd	r24, Y+1	; 0x01
    149c:	9a 81       	ldd	r25, Y+2	; 0x02
    149e:	82 17       	cp	r24, r18
    14a0:	93 07       	cpc	r25, r19
    14a2:	70 f7       	brcc	.-36     	; 0x1480 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	82 81       	ldd	r24, Z+2	; 0x02
    14aa:	93 81       	ldd	r25, Z+3	; 0x03
    14ac:	ef 81       	ldd	r30, Y+7	; 0x07
    14ae:	f8 85       	ldd	r31, Y+8	; 0x08
    14b0:	93 83       	std	Z+3, r25	; 0x03
    14b2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14b4:	ef 81       	ldd	r30, Y+7	; 0x07
    14b6:	f8 85       	ldd	r31, Y+8	; 0x08
    14b8:	02 80       	ldd	r0, Z+2	; 0x02
    14ba:	f3 81       	ldd	r31, Z+3	; 0x03
    14bc:	e0 2d       	mov	r30, r0
    14be:	8f 81       	ldd	r24, Y+7	; 0x07
    14c0:	98 85       	ldd	r25, Y+8	; 0x08
    14c2:	95 83       	std	Z+5, r25	; 0x05
    14c4:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    14c6:	ef 81       	ldd	r30, Y+7	; 0x07
    14c8:	f8 85       	ldd	r31, Y+8	; 0x08
    14ca:	8b 81       	ldd	r24, Y+3	; 0x03
    14cc:	9c 81       	ldd	r25, Y+4	; 0x04
    14ce:	95 83       	std	Z+5, r25	; 0x05
    14d0:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    14d2:	8f 81       	ldd	r24, Y+7	; 0x07
    14d4:	98 85       	ldd	r25, Y+8	; 0x08
    14d6:	eb 81       	ldd	r30, Y+3	; 0x03
    14d8:	fc 81       	ldd	r31, Y+4	; 0x04
    14da:	93 83       	std	Z+3, r25	; 0x03
    14dc:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14de:	ef 81       	ldd	r30, Y+7	; 0x07
    14e0:	f8 85       	ldd	r31, Y+8	; 0x08
    14e2:	8d 81       	ldd	r24, Y+5	; 0x05
    14e4:	9e 81       	ldd	r25, Y+6	; 0x06
    14e6:	91 87       	std	Z+9, r25	; 0x09
    14e8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    14ea:	ed 81       	ldd	r30, Y+5	; 0x05
    14ec:	fe 81       	ldd	r31, Y+6	; 0x06
    14ee:	80 81       	ld	r24, Z
    14f0:	8f 5f       	subi	r24, 0xFF	; 255
    14f2:	ed 81       	ldd	r30, Y+5	; 0x05
    14f4:	fe 81       	ldd	r31, Y+6	; 0x06
    14f6:	80 83       	st	Z, r24
}
    14f8:	28 96       	adiw	r28, 0x08	; 8
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	f8 94       	cli
    14fe:	de bf       	out	0x3e, r29	; 62
    1500:	0f be       	out	0x3f, r0	; 63
    1502:	cd bf       	out	0x3d, r28	; 61
    1504:	cf 91       	pop	r28
    1506:	df 91       	pop	r29
    1508:	08 95       	ret

0000150a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    150a:	df 93       	push	r29
    150c:	cf 93       	push	r28
    150e:	00 d0       	rcall	.+0      	; 0x1510 <vListRemove+0x6>
    1510:	00 d0       	rcall	.+0      	; 0x1512 <vListRemove+0x8>
    1512:	cd b7       	in	r28, 0x3d	; 61
    1514:	de b7       	in	r29, 0x3e	; 62
    1516:	9c 83       	std	Y+4, r25	; 0x04
    1518:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    151a:	eb 81       	ldd	r30, Y+3	; 0x03
    151c:	fc 81       	ldd	r31, Y+4	; 0x04
    151e:	a2 81       	ldd	r26, Z+2	; 0x02
    1520:	b3 81       	ldd	r27, Z+3	; 0x03
    1522:	eb 81       	ldd	r30, Y+3	; 0x03
    1524:	fc 81       	ldd	r31, Y+4	; 0x04
    1526:	84 81       	ldd	r24, Z+4	; 0x04
    1528:	95 81       	ldd	r25, Z+5	; 0x05
    152a:	15 96       	adiw	r26, 0x05	; 5
    152c:	9c 93       	st	X, r25
    152e:	8e 93       	st	-X, r24
    1530:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1532:	eb 81       	ldd	r30, Y+3	; 0x03
    1534:	fc 81       	ldd	r31, Y+4	; 0x04
    1536:	a4 81       	ldd	r26, Z+4	; 0x04
    1538:	b5 81       	ldd	r27, Z+5	; 0x05
    153a:	eb 81       	ldd	r30, Y+3	; 0x03
    153c:	fc 81       	ldd	r31, Y+4	; 0x04
    153e:	82 81       	ldd	r24, Z+2	; 0x02
    1540:	93 81       	ldd	r25, Z+3	; 0x03
    1542:	13 96       	adiw	r26, 0x03	; 3
    1544:	9c 93       	st	X, r25
    1546:	8e 93       	st	-X, r24
    1548:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    154a:	eb 81       	ldd	r30, Y+3	; 0x03
    154c:	fc 81       	ldd	r31, Y+4	; 0x04
    154e:	80 85       	ldd	r24, Z+8	; 0x08
    1550:	91 85       	ldd	r25, Z+9	; 0x09
    1552:	9a 83       	std	Y+2, r25	; 0x02
    1554:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1556:	e9 81       	ldd	r30, Y+1	; 0x01
    1558:	fa 81       	ldd	r31, Y+2	; 0x02
    155a:	21 81       	ldd	r18, Z+1	; 0x01
    155c:	32 81       	ldd	r19, Z+2	; 0x02
    155e:	8b 81       	ldd	r24, Y+3	; 0x03
    1560:	9c 81       	ldd	r25, Y+4	; 0x04
    1562:	28 17       	cp	r18, r24
    1564:	39 07       	cpc	r19, r25
    1566:	41 f4       	brne	.+16     	; 0x1578 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1568:	eb 81       	ldd	r30, Y+3	; 0x03
    156a:	fc 81       	ldd	r31, Y+4	; 0x04
    156c:	84 81       	ldd	r24, Z+4	; 0x04
    156e:	95 81       	ldd	r25, Z+5	; 0x05
    1570:	e9 81       	ldd	r30, Y+1	; 0x01
    1572:	fa 81       	ldd	r31, Y+2	; 0x02
    1574:	92 83       	std	Z+2, r25	; 0x02
    1576:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1578:	eb 81       	ldd	r30, Y+3	; 0x03
    157a:	fc 81       	ldd	r31, Y+4	; 0x04
    157c:	11 86       	std	Z+9, r1	; 0x09
    157e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1580:	e9 81       	ldd	r30, Y+1	; 0x01
    1582:	fa 81       	ldd	r31, Y+2	; 0x02
    1584:	80 81       	ld	r24, Z
    1586:	81 50       	subi	r24, 0x01	; 1
    1588:	e9 81       	ldd	r30, Y+1	; 0x01
    158a:	fa 81       	ldd	r31, Y+2	; 0x02
    158c:	80 83       	st	Z, r24
}
    158e:	0f 90       	pop	r0
    1590:	0f 90       	pop	r0
    1592:	0f 90       	pop	r0
    1594:	0f 90       	pop	r0
    1596:	cf 91       	pop	r28
    1598:	df 91       	pop	r29
    159a:	08 95       	ret

0000159c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    159c:	df 93       	push	r29
    159e:	cf 93       	push	r28
    15a0:	cd b7       	in	r28, 0x3d	; 61
    15a2:	de b7       	in	r29, 0x3e	; 62
    15a4:	28 97       	sbiw	r28, 0x08	; 8
    15a6:	0f b6       	in	r0, 0x3f	; 63
    15a8:	f8 94       	cli
    15aa:	de bf       	out	0x3e, r29	; 62
    15ac:	0f be       	out	0x3f, r0	; 63
    15ae:	cd bf       	out	0x3d, r28	; 61
    15b0:	9c 83       	std	Y+4, r25	; 0x04
    15b2:	8b 83       	std	Y+3, r24	; 0x03
    15b4:	7e 83       	std	Y+6, r23	; 0x06
    15b6:	6d 83       	std	Y+5, r22	; 0x05
    15b8:	58 87       	std	Y+8, r21	; 0x08
    15ba:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    15bc:	eb 81       	ldd	r30, Y+3	; 0x03
    15be:	fc 81       	ldd	r31, Y+4	; 0x04
    15c0:	81 e1       	ldi	r24, 0x11	; 17
    15c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    15c4:	8b 81       	ldd	r24, Y+3	; 0x03
    15c6:	9c 81       	ldd	r25, Y+4	; 0x04
    15c8:	01 97       	sbiw	r24, 0x01	; 1
    15ca:	9c 83       	std	Y+4, r25	; 0x04
    15cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    15ce:	eb 81       	ldd	r30, Y+3	; 0x03
    15d0:	fc 81       	ldd	r31, Y+4	; 0x04
    15d2:	82 e2       	ldi	r24, 0x22	; 34
    15d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    15d6:	8b 81       	ldd	r24, Y+3	; 0x03
    15d8:	9c 81       	ldd	r25, Y+4	; 0x04
    15da:	01 97       	sbiw	r24, 0x01	; 1
    15dc:	9c 83       	std	Y+4, r25	; 0x04
    15de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    15e0:	eb 81       	ldd	r30, Y+3	; 0x03
    15e2:	fc 81       	ldd	r31, Y+4	; 0x04
    15e4:	83 e3       	ldi	r24, 0x33	; 51
    15e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    15e8:	8b 81       	ldd	r24, Y+3	; 0x03
    15ea:	9c 81       	ldd	r25, Y+4	; 0x04
    15ec:	01 97       	sbiw	r24, 0x01	; 1
    15ee:	9c 83       	std	Y+4, r25	; 0x04
    15f0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    15f2:	8d 81       	ldd	r24, Y+5	; 0x05
    15f4:	9e 81       	ldd	r25, Y+6	; 0x06
    15f6:	9a 83       	std	Y+2, r25	; 0x02
    15f8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    15fa:	89 81       	ldd	r24, Y+1	; 0x01
    15fc:	eb 81       	ldd	r30, Y+3	; 0x03
    15fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1600:	80 83       	st	Z, r24
	pxTopOfStack--;
    1602:	8b 81       	ldd	r24, Y+3	; 0x03
    1604:	9c 81       	ldd	r25, Y+4	; 0x04
    1606:	01 97       	sbiw	r24, 0x01	; 1
    1608:	9c 83       	std	Y+4, r25	; 0x04
    160a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    160c:	89 81       	ldd	r24, Y+1	; 0x01
    160e:	9a 81       	ldd	r25, Y+2	; 0x02
    1610:	89 2f       	mov	r24, r25
    1612:	99 27       	eor	r25, r25
    1614:	9a 83       	std	Y+2, r25	; 0x02
    1616:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1618:	89 81       	ldd	r24, Y+1	; 0x01
    161a:	eb 81       	ldd	r30, Y+3	; 0x03
    161c:	fc 81       	ldd	r31, Y+4	; 0x04
    161e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1620:	8b 81       	ldd	r24, Y+3	; 0x03
    1622:	9c 81       	ldd	r25, Y+4	; 0x04
    1624:	01 97       	sbiw	r24, 0x01	; 1
    1626:	9c 83       	std	Y+4, r25	; 0x04
    1628:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    162a:	eb 81       	ldd	r30, Y+3	; 0x03
    162c:	fc 81       	ldd	r31, Y+4	; 0x04
    162e:	10 82       	st	Z, r1
	pxTopOfStack--;
    1630:	8b 81       	ldd	r24, Y+3	; 0x03
    1632:	9c 81       	ldd	r25, Y+4	; 0x04
    1634:	01 97       	sbiw	r24, 0x01	; 1
    1636:	9c 83       	std	Y+4, r25	; 0x04
    1638:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    163a:	eb 81       	ldd	r30, Y+3	; 0x03
    163c:	fc 81       	ldd	r31, Y+4	; 0x04
    163e:	80 e8       	ldi	r24, 0x80	; 128
    1640:	80 83       	st	Z, r24
	pxTopOfStack--;
    1642:	8b 81       	ldd	r24, Y+3	; 0x03
    1644:	9c 81       	ldd	r25, Y+4	; 0x04
    1646:	01 97       	sbiw	r24, 0x01	; 1
    1648:	9c 83       	std	Y+4, r25	; 0x04
    164a:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    164c:	eb 81       	ldd	r30, Y+3	; 0x03
    164e:	fc 81       	ldd	r31, Y+4	; 0x04
    1650:	10 82       	st	Z, r1
	pxTopOfStack--;
    1652:	8b 81       	ldd	r24, Y+3	; 0x03
    1654:	9c 81       	ldd	r25, Y+4	; 0x04
    1656:	01 97       	sbiw	r24, 0x01	; 1
    1658:	9c 83       	std	Y+4, r25	; 0x04
    165a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    165c:	eb 81       	ldd	r30, Y+3	; 0x03
    165e:	fc 81       	ldd	r31, Y+4	; 0x04
    1660:	82 e0       	ldi	r24, 0x02	; 2
    1662:	80 83       	st	Z, r24
	pxTopOfStack--;
    1664:	8b 81       	ldd	r24, Y+3	; 0x03
    1666:	9c 81       	ldd	r25, Y+4	; 0x04
    1668:	01 97       	sbiw	r24, 0x01	; 1
    166a:	9c 83       	std	Y+4, r25	; 0x04
    166c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    166e:	eb 81       	ldd	r30, Y+3	; 0x03
    1670:	fc 81       	ldd	r31, Y+4	; 0x04
    1672:	83 e0       	ldi	r24, 0x03	; 3
    1674:	80 83       	st	Z, r24
	pxTopOfStack--;
    1676:	8b 81       	ldd	r24, Y+3	; 0x03
    1678:	9c 81       	ldd	r25, Y+4	; 0x04
    167a:	01 97       	sbiw	r24, 0x01	; 1
    167c:	9c 83       	std	Y+4, r25	; 0x04
    167e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1680:	eb 81       	ldd	r30, Y+3	; 0x03
    1682:	fc 81       	ldd	r31, Y+4	; 0x04
    1684:	84 e0       	ldi	r24, 0x04	; 4
    1686:	80 83       	st	Z, r24
	pxTopOfStack--;
    1688:	8b 81       	ldd	r24, Y+3	; 0x03
    168a:	9c 81       	ldd	r25, Y+4	; 0x04
    168c:	01 97       	sbiw	r24, 0x01	; 1
    168e:	9c 83       	std	Y+4, r25	; 0x04
    1690:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1692:	eb 81       	ldd	r30, Y+3	; 0x03
    1694:	fc 81       	ldd	r31, Y+4	; 0x04
    1696:	85 e0       	ldi	r24, 0x05	; 5
    1698:	80 83       	st	Z, r24
	pxTopOfStack--;
    169a:	8b 81       	ldd	r24, Y+3	; 0x03
    169c:	9c 81       	ldd	r25, Y+4	; 0x04
    169e:	01 97       	sbiw	r24, 0x01	; 1
    16a0:	9c 83       	std	Y+4, r25	; 0x04
    16a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    16a4:	eb 81       	ldd	r30, Y+3	; 0x03
    16a6:	fc 81       	ldd	r31, Y+4	; 0x04
    16a8:	86 e0       	ldi	r24, 0x06	; 6
    16aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    16ac:	8b 81       	ldd	r24, Y+3	; 0x03
    16ae:	9c 81       	ldd	r25, Y+4	; 0x04
    16b0:	01 97       	sbiw	r24, 0x01	; 1
    16b2:	9c 83       	std	Y+4, r25	; 0x04
    16b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    16b6:	eb 81       	ldd	r30, Y+3	; 0x03
    16b8:	fc 81       	ldd	r31, Y+4	; 0x04
    16ba:	87 e0       	ldi	r24, 0x07	; 7
    16bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    16be:	8b 81       	ldd	r24, Y+3	; 0x03
    16c0:	9c 81       	ldd	r25, Y+4	; 0x04
    16c2:	01 97       	sbiw	r24, 0x01	; 1
    16c4:	9c 83       	std	Y+4, r25	; 0x04
    16c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    16c8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ca:	fc 81       	ldd	r31, Y+4	; 0x04
    16cc:	88 e0       	ldi	r24, 0x08	; 8
    16ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d0:	8b 81       	ldd	r24, Y+3	; 0x03
    16d2:	9c 81       	ldd	r25, Y+4	; 0x04
    16d4:	01 97       	sbiw	r24, 0x01	; 1
    16d6:	9c 83       	std	Y+4, r25	; 0x04
    16d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    16da:	eb 81       	ldd	r30, Y+3	; 0x03
    16dc:	fc 81       	ldd	r31, Y+4	; 0x04
    16de:	89 e0       	ldi	r24, 0x09	; 9
    16e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16e2:	8b 81       	ldd	r24, Y+3	; 0x03
    16e4:	9c 81       	ldd	r25, Y+4	; 0x04
    16e6:	01 97       	sbiw	r24, 0x01	; 1
    16e8:	9c 83       	std	Y+4, r25	; 0x04
    16ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    16ec:	eb 81       	ldd	r30, Y+3	; 0x03
    16ee:	fc 81       	ldd	r31, Y+4	; 0x04
    16f0:	80 e1       	ldi	r24, 0x10	; 16
    16f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16f4:	8b 81       	ldd	r24, Y+3	; 0x03
    16f6:	9c 81       	ldd	r25, Y+4	; 0x04
    16f8:	01 97       	sbiw	r24, 0x01	; 1
    16fa:	9c 83       	std	Y+4, r25	; 0x04
    16fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    16fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1700:	fc 81       	ldd	r31, Y+4	; 0x04
    1702:	81 e1       	ldi	r24, 0x11	; 17
    1704:	80 83       	st	Z, r24
	pxTopOfStack--;
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	9c 81       	ldd	r25, Y+4	; 0x04
    170a:	01 97       	sbiw	r24, 0x01	; 1
    170c:	9c 83       	std	Y+4, r25	; 0x04
    170e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1710:	eb 81       	ldd	r30, Y+3	; 0x03
    1712:	fc 81       	ldd	r31, Y+4	; 0x04
    1714:	82 e1       	ldi	r24, 0x12	; 18
    1716:	80 83       	st	Z, r24
	pxTopOfStack--;
    1718:	8b 81       	ldd	r24, Y+3	; 0x03
    171a:	9c 81       	ldd	r25, Y+4	; 0x04
    171c:	01 97       	sbiw	r24, 0x01	; 1
    171e:	9c 83       	std	Y+4, r25	; 0x04
    1720:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1722:	eb 81       	ldd	r30, Y+3	; 0x03
    1724:	fc 81       	ldd	r31, Y+4	; 0x04
    1726:	83 e1       	ldi	r24, 0x13	; 19
    1728:	80 83       	st	Z, r24
	pxTopOfStack--;
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	9c 81       	ldd	r25, Y+4	; 0x04
    172e:	01 97       	sbiw	r24, 0x01	; 1
    1730:	9c 83       	std	Y+4, r25	; 0x04
    1732:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1734:	eb 81       	ldd	r30, Y+3	; 0x03
    1736:	fc 81       	ldd	r31, Y+4	; 0x04
    1738:	84 e1       	ldi	r24, 0x14	; 20
    173a:	80 83       	st	Z, r24
	pxTopOfStack--;
    173c:	8b 81       	ldd	r24, Y+3	; 0x03
    173e:	9c 81       	ldd	r25, Y+4	; 0x04
    1740:	01 97       	sbiw	r24, 0x01	; 1
    1742:	9c 83       	std	Y+4, r25	; 0x04
    1744:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1746:	eb 81       	ldd	r30, Y+3	; 0x03
    1748:	fc 81       	ldd	r31, Y+4	; 0x04
    174a:	85 e1       	ldi	r24, 0x15	; 21
    174c:	80 83       	st	Z, r24
	pxTopOfStack--;
    174e:	8b 81       	ldd	r24, Y+3	; 0x03
    1750:	9c 81       	ldd	r25, Y+4	; 0x04
    1752:	01 97       	sbiw	r24, 0x01	; 1
    1754:	9c 83       	std	Y+4, r25	; 0x04
    1756:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1758:	eb 81       	ldd	r30, Y+3	; 0x03
    175a:	fc 81       	ldd	r31, Y+4	; 0x04
    175c:	86 e1       	ldi	r24, 0x16	; 22
    175e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1760:	8b 81       	ldd	r24, Y+3	; 0x03
    1762:	9c 81       	ldd	r25, Y+4	; 0x04
    1764:	01 97       	sbiw	r24, 0x01	; 1
    1766:	9c 83       	std	Y+4, r25	; 0x04
    1768:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    176a:	eb 81       	ldd	r30, Y+3	; 0x03
    176c:	fc 81       	ldd	r31, Y+4	; 0x04
    176e:	87 e1       	ldi	r24, 0x17	; 23
    1770:	80 83       	st	Z, r24
	pxTopOfStack--;
    1772:	8b 81       	ldd	r24, Y+3	; 0x03
    1774:	9c 81       	ldd	r25, Y+4	; 0x04
    1776:	01 97       	sbiw	r24, 0x01	; 1
    1778:	9c 83       	std	Y+4, r25	; 0x04
    177a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    177c:	eb 81       	ldd	r30, Y+3	; 0x03
    177e:	fc 81       	ldd	r31, Y+4	; 0x04
    1780:	88 e1       	ldi	r24, 0x18	; 24
    1782:	80 83       	st	Z, r24
	pxTopOfStack--;
    1784:	8b 81       	ldd	r24, Y+3	; 0x03
    1786:	9c 81       	ldd	r25, Y+4	; 0x04
    1788:	01 97       	sbiw	r24, 0x01	; 1
    178a:	9c 83       	std	Y+4, r25	; 0x04
    178c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    178e:	eb 81       	ldd	r30, Y+3	; 0x03
    1790:	fc 81       	ldd	r31, Y+4	; 0x04
    1792:	89 e1       	ldi	r24, 0x19	; 25
    1794:	80 83       	st	Z, r24
	pxTopOfStack--;
    1796:	8b 81       	ldd	r24, Y+3	; 0x03
    1798:	9c 81       	ldd	r25, Y+4	; 0x04
    179a:	01 97       	sbiw	r24, 0x01	; 1
    179c:	9c 83       	std	Y+4, r25	; 0x04
    179e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    17a0:	eb 81       	ldd	r30, Y+3	; 0x03
    17a2:	fc 81       	ldd	r31, Y+4	; 0x04
    17a4:	80 e2       	ldi	r24, 0x20	; 32
    17a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    17a8:	8b 81       	ldd	r24, Y+3	; 0x03
    17aa:	9c 81       	ldd	r25, Y+4	; 0x04
    17ac:	01 97       	sbiw	r24, 0x01	; 1
    17ae:	9c 83       	std	Y+4, r25	; 0x04
    17b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    17b2:	eb 81       	ldd	r30, Y+3	; 0x03
    17b4:	fc 81       	ldd	r31, Y+4	; 0x04
    17b6:	81 e2       	ldi	r24, 0x21	; 33
    17b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ba:	8b 81       	ldd	r24, Y+3	; 0x03
    17bc:	9c 81       	ldd	r25, Y+4	; 0x04
    17be:	01 97       	sbiw	r24, 0x01	; 1
    17c0:	9c 83       	std	Y+4, r25	; 0x04
    17c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    17c4:	eb 81       	ldd	r30, Y+3	; 0x03
    17c6:	fc 81       	ldd	r31, Y+4	; 0x04
    17c8:	82 e2       	ldi	r24, 0x22	; 34
    17ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    17cc:	8b 81       	ldd	r24, Y+3	; 0x03
    17ce:	9c 81       	ldd	r25, Y+4	; 0x04
    17d0:	01 97       	sbiw	r24, 0x01	; 1
    17d2:	9c 83       	std	Y+4, r25	; 0x04
    17d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    17d6:	eb 81       	ldd	r30, Y+3	; 0x03
    17d8:	fc 81       	ldd	r31, Y+4	; 0x04
    17da:	83 e2       	ldi	r24, 0x23	; 35
    17dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    17de:	8b 81       	ldd	r24, Y+3	; 0x03
    17e0:	9c 81       	ldd	r25, Y+4	; 0x04
    17e2:	01 97       	sbiw	r24, 0x01	; 1
    17e4:	9c 83       	std	Y+4, r25	; 0x04
    17e6:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    17e8:	8f 81       	ldd	r24, Y+7	; 0x07
    17ea:	98 85       	ldd	r25, Y+8	; 0x08
    17ec:	9a 83       	std	Y+2, r25	; 0x02
    17ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17f0:	89 81       	ldd	r24, Y+1	; 0x01
    17f2:	eb 81       	ldd	r30, Y+3	; 0x03
    17f4:	fc 81       	ldd	r31, Y+4	; 0x04
    17f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f8:	8b 81       	ldd	r24, Y+3	; 0x03
    17fa:	9c 81       	ldd	r25, Y+4	; 0x04
    17fc:	01 97       	sbiw	r24, 0x01	; 1
    17fe:	9c 83       	std	Y+4, r25	; 0x04
    1800:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1802:	89 81       	ldd	r24, Y+1	; 0x01
    1804:	9a 81       	ldd	r25, Y+2	; 0x02
    1806:	89 2f       	mov	r24, r25
    1808:	99 27       	eor	r25, r25
    180a:	9a 83       	std	Y+2, r25	; 0x02
    180c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    180e:	89 81       	ldd	r24, Y+1	; 0x01
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	80 83       	st	Z, r24
	pxTopOfStack--;
    1816:	8b 81       	ldd	r24, Y+3	; 0x03
    1818:	9c 81       	ldd	r25, Y+4	; 0x04
    181a:	01 97       	sbiw	r24, 0x01	; 1
    181c:	9c 83       	std	Y+4, r25	; 0x04
    181e:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1820:	eb 81       	ldd	r30, Y+3	; 0x03
    1822:	fc 81       	ldd	r31, Y+4	; 0x04
    1824:	86 e2       	ldi	r24, 0x26	; 38
    1826:	80 83       	st	Z, r24
	pxTopOfStack--;
    1828:	8b 81       	ldd	r24, Y+3	; 0x03
    182a:	9c 81       	ldd	r25, Y+4	; 0x04
    182c:	01 97       	sbiw	r24, 0x01	; 1
    182e:	9c 83       	std	Y+4, r25	; 0x04
    1830:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1832:	eb 81       	ldd	r30, Y+3	; 0x03
    1834:	fc 81       	ldd	r31, Y+4	; 0x04
    1836:	87 e2       	ldi	r24, 0x27	; 39
    1838:	80 83       	st	Z, r24
	pxTopOfStack--;
    183a:	8b 81       	ldd	r24, Y+3	; 0x03
    183c:	9c 81       	ldd	r25, Y+4	; 0x04
    183e:	01 97       	sbiw	r24, 0x01	; 1
    1840:	9c 83       	std	Y+4, r25	; 0x04
    1842:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1844:	eb 81       	ldd	r30, Y+3	; 0x03
    1846:	fc 81       	ldd	r31, Y+4	; 0x04
    1848:	88 e2       	ldi	r24, 0x28	; 40
    184a:	80 83       	st	Z, r24
	pxTopOfStack--;
    184c:	8b 81       	ldd	r24, Y+3	; 0x03
    184e:	9c 81       	ldd	r25, Y+4	; 0x04
    1850:	01 97       	sbiw	r24, 0x01	; 1
    1852:	9c 83       	std	Y+4, r25	; 0x04
    1854:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1856:	eb 81       	ldd	r30, Y+3	; 0x03
    1858:	fc 81       	ldd	r31, Y+4	; 0x04
    185a:	89 e2       	ldi	r24, 0x29	; 41
    185c:	80 83       	st	Z, r24
	pxTopOfStack--;
    185e:	8b 81       	ldd	r24, Y+3	; 0x03
    1860:	9c 81       	ldd	r25, Y+4	; 0x04
    1862:	01 97       	sbiw	r24, 0x01	; 1
    1864:	9c 83       	std	Y+4, r25	; 0x04
    1866:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1868:	eb 81       	ldd	r30, Y+3	; 0x03
    186a:	fc 81       	ldd	r31, Y+4	; 0x04
    186c:	80 e3       	ldi	r24, 0x30	; 48
    186e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1870:	8b 81       	ldd	r24, Y+3	; 0x03
    1872:	9c 81       	ldd	r25, Y+4	; 0x04
    1874:	01 97       	sbiw	r24, 0x01	; 1
    1876:	9c 83       	std	Y+4, r25	; 0x04
    1878:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    187a:	eb 81       	ldd	r30, Y+3	; 0x03
    187c:	fc 81       	ldd	r31, Y+4	; 0x04
    187e:	81 e3       	ldi	r24, 0x31	; 49
    1880:	80 83       	st	Z, r24
	pxTopOfStack--;
    1882:	8b 81       	ldd	r24, Y+3	; 0x03
    1884:	9c 81       	ldd	r25, Y+4	; 0x04
    1886:	01 97       	sbiw	r24, 0x01	; 1
    1888:	9c 83       	std	Y+4, r25	; 0x04
    188a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    188c:	8b 81       	ldd	r24, Y+3	; 0x03
    188e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1890:	28 96       	adiw	r28, 0x08	; 8
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	de bf       	out	0x3e, r29	; 62
    1898:	0f be       	out	0x3f, r0	; 63
    189a:	cd bf       	out	0x3d, r28	; 61
    189c:	cf 91       	pop	r28
    189e:	df 91       	pop	r29
    18a0:	08 95       	ret

000018a2 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    18a2:	df 93       	push	r29
    18a4:	cf 93       	push	r28
    18a6:	cd b7       	in	r28, 0x3d	; 61
    18a8:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    18aa:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    18ae:	a0 91 f6 02 	lds	r26, 0x02F6
    18b2:	b0 91 f7 02 	lds	r27, 0x02F7
    18b6:	cd 91       	ld	r28, X+
    18b8:	cd bf       	out	0x3d, r28	; 61
    18ba:	dd 91       	ld	r29, X+
    18bc:	de bf       	out	0x3e, r29	; 62
    18be:	ff 91       	pop	r31
    18c0:	ef 91       	pop	r30
    18c2:	df 91       	pop	r29
    18c4:	cf 91       	pop	r28
    18c6:	bf 91       	pop	r27
    18c8:	af 91       	pop	r26
    18ca:	9f 91       	pop	r25
    18cc:	8f 91       	pop	r24
    18ce:	7f 91       	pop	r23
    18d0:	6f 91       	pop	r22
    18d2:	5f 91       	pop	r21
    18d4:	4f 91       	pop	r20
    18d6:	3f 91       	pop	r19
    18d8:	2f 91       	pop	r18
    18da:	1f 91       	pop	r17
    18dc:	0f 91       	pop	r16
    18de:	ff 90       	pop	r15
    18e0:	ef 90       	pop	r14
    18e2:	df 90       	pop	r13
    18e4:	cf 90       	pop	r12
    18e6:	bf 90       	pop	r11
    18e8:	af 90       	pop	r10
    18ea:	9f 90       	pop	r9
    18ec:	8f 90       	pop	r8
    18ee:	7f 90       	pop	r7
    18f0:	6f 90       	pop	r6
    18f2:	5f 90       	pop	r5
    18f4:	4f 90       	pop	r4
    18f6:	3f 90       	pop	r3
    18f8:	2f 90       	pop	r2
    18fa:	1f 90       	pop	r1
    18fc:	0f 90       	pop	r0
    18fe:	0f be       	out	0x3f, r0	; 63
    1900:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1902:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1904:	81 e0       	ldi	r24, 0x01	; 1
}
    1906:	cf 91       	pop	r28
    1908:	df 91       	pop	r29
    190a:	08 95       	ret

0000190c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    190c:	df 93       	push	r29
    190e:	cf 93       	push	r28
    1910:	cd b7       	in	r28, 0x3d	; 61
    1912:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1914:	cf 91       	pop	r28
    1916:	df 91       	pop	r29
    1918:	08 95       	ret

0000191a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    191a:	0f 92       	push	r0
    191c:	0f b6       	in	r0, 0x3f	; 63
    191e:	f8 94       	cli
    1920:	0f 92       	push	r0
    1922:	1f 92       	push	r1
    1924:	11 24       	eor	r1, r1
    1926:	2f 92       	push	r2
    1928:	3f 92       	push	r3
    192a:	4f 92       	push	r4
    192c:	5f 92       	push	r5
    192e:	6f 92       	push	r6
    1930:	7f 92       	push	r7
    1932:	8f 92       	push	r8
    1934:	9f 92       	push	r9
    1936:	af 92       	push	r10
    1938:	bf 92       	push	r11
    193a:	cf 92       	push	r12
    193c:	df 92       	push	r13
    193e:	ef 92       	push	r14
    1940:	ff 92       	push	r15
    1942:	0f 93       	push	r16
    1944:	1f 93       	push	r17
    1946:	2f 93       	push	r18
    1948:	3f 93       	push	r19
    194a:	4f 93       	push	r20
    194c:	5f 93       	push	r21
    194e:	6f 93       	push	r22
    1950:	7f 93       	push	r23
    1952:	8f 93       	push	r24
    1954:	9f 93       	push	r25
    1956:	af 93       	push	r26
    1958:	bf 93       	push	r27
    195a:	cf 93       	push	r28
    195c:	df 93       	push	r29
    195e:	ef 93       	push	r30
    1960:	ff 93       	push	r31
    1962:	a0 91 f6 02 	lds	r26, 0x02F6
    1966:	b0 91 f7 02 	lds	r27, 0x02F7
    196a:	0d b6       	in	r0, 0x3d	; 61
    196c:	0d 92       	st	X+, r0
    196e:	0e b6       	in	r0, 0x3e	; 62
    1970:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1972:	0e 94 fd 15 	call	0x2bfa	; 0x2bfa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1976:	a0 91 f6 02 	lds	r26, 0x02F6
    197a:	b0 91 f7 02 	lds	r27, 0x02F7
    197e:	cd 91       	ld	r28, X+
    1980:	cd bf       	out	0x3d, r28	; 61
    1982:	dd 91       	ld	r29, X+
    1984:	de bf       	out	0x3e, r29	; 62
    1986:	ff 91       	pop	r31
    1988:	ef 91       	pop	r30
    198a:	df 91       	pop	r29
    198c:	cf 91       	pop	r28
    198e:	bf 91       	pop	r27
    1990:	af 91       	pop	r26
    1992:	9f 91       	pop	r25
    1994:	8f 91       	pop	r24
    1996:	7f 91       	pop	r23
    1998:	6f 91       	pop	r22
    199a:	5f 91       	pop	r21
    199c:	4f 91       	pop	r20
    199e:	3f 91       	pop	r19
    19a0:	2f 91       	pop	r18
    19a2:	1f 91       	pop	r17
    19a4:	0f 91       	pop	r16
    19a6:	ff 90       	pop	r15
    19a8:	ef 90       	pop	r14
    19aa:	df 90       	pop	r13
    19ac:	cf 90       	pop	r12
    19ae:	bf 90       	pop	r11
    19b0:	af 90       	pop	r10
    19b2:	9f 90       	pop	r9
    19b4:	8f 90       	pop	r8
    19b6:	7f 90       	pop	r7
    19b8:	6f 90       	pop	r6
    19ba:	5f 90       	pop	r5
    19bc:	4f 90       	pop	r4
    19be:	3f 90       	pop	r3
    19c0:	2f 90       	pop	r2
    19c2:	1f 90       	pop	r1
    19c4:	0f 90       	pop	r0
    19c6:	0f be       	out	0x3f, r0	; 63
    19c8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19ca:	08 95       	ret

000019cc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    19cc:	0f 92       	push	r0
    19ce:	0f b6       	in	r0, 0x3f	; 63
    19d0:	f8 94       	cli
    19d2:	0f 92       	push	r0
    19d4:	1f 92       	push	r1
    19d6:	11 24       	eor	r1, r1
    19d8:	2f 92       	push	r2
    19da:	3f 92       	push	r3
    19dc:	4f 92       	push	r4
    19de:	5f 92       	push	r5
    19e0:	6f 92       	push	r6
    19e2:	7f 92       	push	r7
    19e4:	8f 92       	push	r8
    19e6:	9f 92       	push	r9
    19e8:	af 92       	push	r10
    19ea:	bf 92       	push	r11
    19ec:	cf 92       	push	r12
    19ee:	df 92       	push	r13
    19f0:	ef 92       	push	r14
    19f2:	ff 92       	push	r15
    19f4:	0f 93       	push	r16
    19f6:	1f 93       	push	r17
    19f8:	2f 93       	push	r18
    19fa:	3f 93       	push	r19
    19fc:	4f 93       	push	r20
    19fe:	5f 93       	push	r21
    1a00:	6f 93       	push	r22
    1a02:	7f 93       	push	r23
    1a04:	8f 93       	push	r24
    1a06:	9f 93       	push	r25
    1a08:	af 93       	push	r26
    1a0a:	bf 93       	push	r27
    1a0c:	cf 93       	push	r28
    1a0e:	df 93       	push	r29
    1a10:	ef 93       	push	r30
    1a12:	ff 93       	push	r31
    1a14:	a0 91 f6 02 	lds	r26, 0x02F6
    1a18:	b0 91 f7 02 	lds	r27, 0x02F7
    1a1c:	0d b6       	in	r0, 0x3d	; 61
    1a1e:	0d 92       	st	X+, r0
    1a20:	0e b6       	in	r0, 0x3e	; 62
    1a22:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a24:	0e 94 28 15 	call	0x2a50	; 0x2a50 <vTaskIncrementTick>
	vTaskSwitchContext();
    1a28:	0e 94 fd 15 	call	0x2bfa	; 0x2bfa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a2c:	a0 91 f6 02 	lds	r26, 0x02F6
    1a30:	b0 91 f7 02 	lds	r27, 0x02F7
    1a34:	cd 91       	ld	r28, X+
    1a36:	cd bf       	out	0x3d, r28	; 61
    1a38:	dd 91       	ld	r29, X+
    1a3a:	de bf       	out	0x3e, r29	; 62
    1a3c:	ff 91       	pop	r31
    1a3e:	ef 91       	pop	r30
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	bf 91       	pop	r27
    1a46:	af 91       	pop	r26
    1a48:	9f 91       	pop	r25
    1a4a:	8f 91       	pop	r24
    1a4c:	7f 91       	pop	r23
    1a4e:	6f 91       	pop	r22
    1a50:	5f 91       	pop	r21
    1a52:	4f 91       	pop	r20
    1a54:	3f 91       	pop	r19
    1a56:	2f 91       	pop	r18
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	ff 90       	pop	r15
    1a5e:	ef 90       	pop	r14
    1a60:	df 90       	pop	r13
    1a62:	cf 90       	pop	r12
    1a64:	bf 90       	pop	r11
    1a66:	af 90       	pop	r10
    1a68:	9f 90       	pop	r9
    1a6a:	8f 90       	pop	r8
    1a6c:	7f 90       	pop	r7
    1a6e:	6f 90       	pop	r6
    1a70:	5f 90       	pop	r5
    1a72:	4f 90       	pop	r4
    1a74:	3f 90       	pop	r3
    1a76:	2f 90       	pop	r2
    1a78:	1f 90       	pop	r1
    1a7a:	0f 90       	pop	r0
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a80:	08 95       	ret

00001a82 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1a82:	df 93       	push	r29
    1a84:	cf 93       	push	r28
    1a86:	00 d0       	rcall	.+0      	; 0x1a88 <prvSetupTimerInterrupt+0x6>
    1a88:	00 d0       	rcall	.+0      	; 0x1a8a <prvSetupTimerInterrupt+0x8>
    1a8a:	00 d0       	rcall	.+0      	; 0x1a8c <prvSetupTimerInterrupt+0xa>
    1a8c:	cd b7       	in	r28, 0x3d	; 61
    1a8e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1a90:	80 e4       	ldi	r24, 0x40	; 64
    1a92:	9f e1       	ldi	r25, 0x1F	; 31
    1a94:	a0 e0       	ldi	r26, 0x00	; 0
    1a96:	b0 e0       	ldi	r27, 0x00	; 0
    1a98:	8b 83       	std	Y+3, r24	; 0x03
    1a9a:	9c 83       	std	Y+4, r25	; 0x04
    1a9c:	ad 83       	std	Y+5, r26	; 0x05
    1a9e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa4:	ad 81       	ldd	r26, Y+5	; 0x05
    1aa6:	be 81       	ldd	r27, Y+6	; 0x06
    1aa8:	68 94       	set
    1aaa:	15 f8       	bld	r1, 5
    1aac:	b6 95       	lsr	r27
    1aae:	a7 95       	ror	r26
    1ab0:	97 95       	ror	r25
    1ab2:	87 95       	ror	r24
    1ab4:	16 94       	lsr	r1
    1ab6:	d1 f7       	brne	.-12     	; 0x1aac <prvSetupTimerInterrupt+0x2a>
    1ab8:	8b 83       	std	Y+3, r24	; 0x03
    1aba:	9c 83       	std	Y+4, r25	; 0x04
    1abc:	ad 83       	std	Y+5, r26	; 0x05
    1abe:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac4:	ad 81       	ldd	r26, Y+5	; 0x05
    1ac6:	be 81       	ldd	r27, Y+6	; 0x06
    1ac8:	01 97       	sbiw	r24, 0x01	; 1
    1aca:	a1 09       	sbc	r26, r1
    1acc:	b1 09       	sbc	r27, r1
    1ace:	8b 83       	std	Y+3, r24	; 0x03
    1ad0:	9c 83       	std	Y+4, r25	; 0x04
    1ad2:	ad 83       	std	Y+5, r26	; 0x05
    1ad4:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad8:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1ada:	8b 81       	ldd	r24, Y+3	; 0x03
    1adc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ade:	ad 81       	ldd	r26, Y+5	; 0x05
    1ae0:	be 81       	ldd	r27, Y+6	; 0x06
    1ae2:	89 2f       	mov	r24, r25
    1ae4:	9a 2f       	mov	r25, r26
    1ae6:	ab 2f       	mov	r26, r27
    1ae8:	bb 27       	eor	r27, r27
    1aea:	8b 83       	std	Y+3, r24	; 0x03
    1aec:	9c 83       	std	Y+4, r25	; 0x04
    1aee:	ad 83       	std	Y+5, r26	; 0x05
    1af0:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1af2:	8b 81       	ldd	r24, Y+3	; 0x03
    1af4:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1af6:	eb e4       	ldi	r30, 0x4B	; 75
    1af8:	f0 e0       	ldi	r31, 0x00	; 0
    1afa:	8a 81       	ldd	r24, Y+2	; 0x02
    1afc:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1afe:	ea e4       	ldi	r30, 0x4A	; 74
    1b00:	f0 e0       	ldi	r31, 0x00	; 0
    1b02:	89 81       	ldd	r24, Y+1	; 0x01
    1b04:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1b06:	8b e0       	ldi	r24, 0x0B	; 11
    1b08:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1b0a:	ee e4       	ldi	r30, 0x4E	; 78
    1b0c:	f0 e0       	ldi	r31, 0x00	; 0
    1b0e:	89 81       	ldd	r24, Y+1	; 0x01
    1b10:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1b12:	e9 e5       	ldi	r30, 0x59	; 89
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	80 81       	ld	r24, Z
    1b18:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1b1a:	89 81       	ldd	r24, Y+1	; 0x01
    1b1c:	80 61       	ori	r24, 0x10	; 16
    1b1e:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1b20:	e9 e5       	ldi	r30, 0x59	; 89
    1b22:	f0 e0       	ldi	r31, 0x00	; 0
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
    1b26:	80 83       	st	Z, r24
}
    1b28:	26 96       	adiw	r28, 0x06	; 6
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	f8 94       	cli
    1b2e:	de bf       	out	0x3e, r29	; 62
    1b30:	0f be       	out	0x3f, r0	; 63
    1b32:	cd bf       	out	0x3d, r28	; 61
    1b34:	cf 91       	pop	r28
    1b36:	df 91       	pop	r29
    1b38:	08 95       	ret

00001b3a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1b3a:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <vPortYieldFromTick>
		asm volatile ( "reti" );
    1b3e:	18 95       	reti

00001b40 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1b40:	df 93       	push	r29
    1b42:	cf 93       	push	r28
    1b44:	cd b7       	in	r28, 0x3d	; 61
    1b46:	de b7       	in	r29, 0x3e	; 62
    1b48:	28 97       	sbiw	r28, 0x08	; 8
    1b4a:	0f b6       	in	r0, 0x3f	; 63
    1b4c:	f8 94       	cli
    1b4e:	de bf       	out	0x3e, r29	; 62
    1b50:	0f be       	out	0x3f, r0	; 63
    1b52:	cd bf       	out	0x3d, r28	; 61
    1b54:	8f 83       	std	Y+7, r24	; 0x07
    1b56:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1b58:	1a 82       	std	Y+2, r1	; 0x02
    1b5a:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1b5c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b5e:	88 23       	and	r24, r24
    1b60:	09 f4       	brne	.+2      	; 0x1b64 <xQueueCreate+0x24>
    1b62:	8c c0       	rjmp	.+280    	; 0x1c7c <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b64:	8f e1       	ldi	r24, 0x1F	; 31
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	0e 94 27 09 	call	0x124e	; 0x124e <pvPortMalloc>
    1b6c:	9e 83       	std	Y+6, r25	; 0x06
    1b6e:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1b70:	8d 81       	ldd	r24, Y+5	; 0x05
    1b72:	9e 81       	ldd	r25, Y+6	; 0x06
    1b74:	00 97       	sbiw	r24, 0x00	; 0
    1b76:	09 f4       	brne	.+2      	; 0x1b7a <xQueueCreate+0x3a>
    1b78:	81 c0       	rjmp	.+258    	; 0x1c7c <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1b7a:	8f 81       	ldd	r24, Y+7	; 0x07
    1b7c:	28 2f       	mov	r18, r24
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	88 85       	ldd	r24, Y+8	; 0x08
    1b82:	88 2f       	mov	r24, r24
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	ac 01       	movw	r20, r24
    1b88:	24 9f       	mul	r18, r20
    1b8a:	c0 01       	movw	r24, r0
    1b8c:	25 9f       	mul	r18, r21
    1b8e:	90 0d       	add	r25, r0
    1b90:	34 9f       	mul	r19, r20
    1b92:	90 0d       	add	r25, r0
    1b94:	11 24       	eor	r1, r1
    1b96:	01 96       	adiw	r24, 0x01	; 1
    1b98:	9c 83       	std	Y+4, r25	; 0x04
    1b9a:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba0:	0e 94 27 09 	call	0x124e	; 0x124e <pvPortMalloc>
    1ba4:	ed 81       	ldd	r30, Y+5	; 0x05
    1ba6:	fe 81       	ldd	r31, Y+6	; 0x06
    1ba8:	91 83       	std	Z+1, r25	; 0x01
    1baa:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1bac:	ed 81       	ldd	r30, Y+5	; 0x05
    1bae:	fe 81       	ldd	r31, Y+6	; 0x06
    1bb0:	80 81       	ld	r24, Z
    1bb2:	91 81       	ldd	r25, Z+1	; 0x01
    1bb4:	00 97       	sbiw	r24, 0x00	; 0
    1bb6:	09 f4       	brne	.+2      	; 0x1bba <xQueueCreate+0x7a>
    1bb8:	5d c0       	rjmp	.+186    	; 0x1c74 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1bba:	ed 81       	ldd	r30, Y+5	; 0x05
    1bbc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bbe:	40 81       	ld	r20, Z
    1bc0:	51 81       	ldd	r21, Z+1	; 0x01
    1bc2:	8f 81       	ldd	r24, Y+7	; 0x07
    1bc4:	28 2f       	mov	r18, r24
    1bc6:	30 e0       	ldi	r19, 0x00	; 0
    1bc8:	88 85       	ldd	r24, Y+8	; 0x08
    1bca:	88 2f       	mov	r24, r24
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	bc 01       	movw	r22, r24
    1bd0:	26 9f       	mul	r18, r22
    1bd2:	c0 01       	movw	r24, r0
    1bd4:	27 9f       	mul	r18, r23
    1bd6:	90 0d       	add	r25, r0
    1bd8:	36 9f       	mul	r19, r22
    1bda:	90 0d       	add	r25, r0
    1bdc:	11 24       	eor	r1, r1
    1bde:	84 0f       	add	r24, r20
    1be0:	95 1f       	adc	r25, r21
    1be2:	ed 81       	ldd	r30, Y+5	; 0x05
    1be4:	fe 81       	ldd	r31, Y+6	; 0x06
    1be6:	93 83       	std	Z+3, r25	; 0x03
    1be8:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1bea:	ed 81       	ldd	r30, Y+5	; 0x05
    1bec:	fe 81       	ldd	r31, Y+6	; 0x06
    1bee:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1bf0:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf2:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf4:	80 81       	ld	r24, Z
    1bf6:	91 81       	ldd	r25, Z+1	; 0x01
    1bf8:	ed 81       	ldd	r30, Y+5	; 0x05
    1bfa:	fe 81       	ldd	r31, Y+6	; 0x06
    1bfc:	95 83       	std	Z+5, r25	; 0x05
    1bfe:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1c00:	ed 81       	ldd	r30, Y+5	; 0x05
    1c02:	fe 81       	ldd	r31, Y+6	; 0x06
    1c04:	40 81       	ld	r20, Z
    1c06:	51 81       	ldd	r21, Z+1	; 0x01
    1c08:	8f 81       	ldd	r24, Y+7	; 0x07
    1c0a:	88 2f       	mov	r24, r24
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	9c 01       	movw	r18, r24
    1c10:	21 50       	subi	r18, 0x01	; 1
    1c12:	30 40       	sbci	r19, 0x00	; 0
    1c14:	88 85       	ldd	r24, Y+8	; 0x08
    1c16:	88 2f       	mov	r24, r24
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	bc 01       	movw	r22, r24
    1c1c:	26 9f       	mul	r18, r22
    1c1e:	c0 01       	movw	r24, r0
    1c20:	27 9f       	mul	r18, r23
    1c22:	90 0d       	add	r25, r0
    1c24:	36 9f       	mul	r19, r22
    1c26:	90 0d       	add	r25, r0
    1c28:	11 24       	eor	r1, r1
    1c2a:	84 0f       	add	r24, r20
    1c2c:	95 1f       	adc	r25, r21
    1c2e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c30:	fe 81       	ldd	r31, Y+6	; 0x06
    1c32:	97 83       	std	Z+7, r25	; 0x07
    1c34:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1c36:	ed 81       	ldd	r30, Y+5	; 0x05
    1c38:	fe 81       	ldd	r31, Y+6	; 0x06
    1c3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c3c:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1c3e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c40:	fe 81       	ldd	r31, Y+6	; 0x06
    1c42:	88 85       	ldd	r24, Y+8	; 0x08
    1c44:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1c46:	ed 81       	ldd	r30, Y+5	; 0x05
    1c48:	fe 81       	ldd	r31, Y+6	; 0x06
    1c4a:	8f ef       	ldi	r24, 0xFF	; 255
    1c4c:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1c4e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c50:	fe 81       	ldd	r31, Y+6	; 0x06
    1c52:	8f ef       	ldi	r24, 0xFF	; 255
    1c54:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1c56:	8d 81       	ldd	r24, Y+5	; 0x05
    1c58:	9e 81       	ldd	r25, Y+6	; 0x06
    1c5a:	08 96       	adiw	r24, 0x08	; 8
    1c5c:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1c60:	8d 81       	ldd	r24, Y+5	; 0x05
    1c62:	9e 81       	ldd	r25, Y+6	; 0x06
    1c64:	41 96       	adiw	r24, 0x11	; 17
    1c66:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1c6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c6e:	9a 83       	std	Y+2, r25	; 0x02
    1c70:	89 83       	std	Y+1, r24	; 0x01
    1c72:	04 c0       	rjmp	.+8      	; 0x1c7c <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1c74:	8d 81       	ldd	r24, Y+5	; 0x05
    1c76:	9e 81       	ldd	r25, Y+6	; 0x06
    1c78:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1c7c:	89 81       	ldd	r24, Y+1	; 0x01
    1c7e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1c80:	28 96       	adiw	r28, 0x08	; 8
    1c82:	0f b6       	in	r0, 0x3f	; 63
    1c84:	f8 94       	cli
    1c86:	de bf       	out	0x3e, r29	; 62
    1c88:	0f be       	out	0x3f, r0	; 63
    1c8a:	cd bf       	out	0x3d, r28	; 61
    1c8c:	cf 91       	pop	r28
    1c8e:	df 91       	pop	r29
    1c90:	08 95       	ret

00001c92 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1c92:	df 93       	push	r29
    1c94:	cf 93       	push	r28
    1c96:	cd b7       	in	r28, 0x3d	; 61
    1c98:	de b7       	in	r29, 0x3e	; 62
    1c9a:	2c 97       	sbiw	r28, 0x0c	; 12
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	f8 94       	cli
    1ca0:	de bf       	out	0x3e, r29	; 62
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	cd bf       	out	0x3d, r28	; 61
    1ca6:	9e 83       	std	Y+6, r25	; 0x06
    1ca8:	8d 83       	std	Y+5, r24	; 0x05
    1caa:	78 87       	std	Y+8, r23	; 0x08
    1cac:	6f 83       	std	Y+7, r22	; 0x07
    1cae:	5a 87       	std	Y+10, r21	; 0x0a
    1cb0:	49 87       	std	Y+9, r20	; 0x09
    1cb2:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1cb4:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1cbc:	ed 81       	ldd	r30, Y+5	; 0x05
    1cbe:	fe 81       	ldd	r31, Y+6	; 0x06
    1cc0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1cc2:	ed 81       	ldd	r30, Y+5	; 0x05
    1cc4:	fe 81       	ldd	r31, Y+6	; 0x06
    1cc6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cc8:	98 17       	cp	r25, r24
    1cca:	d8 f4       	brcc	.+54     	; 0x1d02 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ccc:	8d 81       	ldd	r24, Y+5	; 0x05
    1cce:	9e 81       	ldd	r25, Y+6	; 0x06
    1cd0:	2f 81       	ldd	r18, Y+7	; 0x07
    1cd2:	38 85       	ldd	r19, Y+8	; 0x08
    1cd4:	b9 01       	movw	r22, r18
    1cd6:	4b 85       	ldd	r20, Y+11	; 0x0b
    1cd8:	0e 94 84 10 	call	0x2108	; 0x2108 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cdc:	ed 81       	ldd	r30, Y+5	; 0x05
    1cde:	fe 81       	ldd	r31, Y+6	; 0x06
    1ce0:	81 89       	ldd	r24, Z+17	; 0x11
    1ce2:	88 23       	and	r24, r24
    1ce4:	49 f0       	breq	.+18     	; 0x1cf8 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cea:	41 96       	adiw	r24, 0x11	; 17
    1cec:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    1cf0:	81 30       	cpi	r24, 0x01	; 1
    1cf2:	11 f4       	brne	.+4      	; 0x1cf8 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1cf4:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1cfc:	81 e0       	ldi	r24, 0x01	; 1
    1cfe:	8c 87       	std	Y+12, r24	; 0x0c
    1d00:	5c c0       	rjmp	.+184    	; 0x1dba <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1d02:	89 85       	ldd	r24, Y+9	; 0x09
    1d04:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d06:	00 97       	sbiw	r24, 0x00	; 0
    1d08:	21 f4       	brne	.+8      	; 0x1d12 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1d0e:	1c 86       	std	Y+12, r1	; 0x0c
    1d10:	54 c0       	rjmp	.+168    	; 0x1dba <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	88 23       	and	r24, r24
    1d16:	31 f4       	brne	.+12     	; 0x1d24 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d18:	ce 01       	movw	r24, r28
    1d1a:	02 96       	adiw	r24, 0x02	; 2
    1d1c:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d28:	0e 94 5d 14 	call	0x28ba	; 0x28ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	0f 92       	push	r0
    1d32:	ed 81       	ldd	r30, Y+5	; 0x05
    1d34:	fe 81       	ldd	r31, Y+6	; 0x06
    1d36:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d38:	8f 3f       	cpi	r24, 0xFF	; 255
    1d3a:	19 f4       	brne	.+6      	; 0x1d42 <xQueueGenericSend+0xb0>
    1d3c:	ed 81       	ldd	r30, Y+5	; 0x05
    1d3e:	fe 81       	ldd	r31, Y+6	; 0x06
    1d40:	15 8e       	std	Z+29, r1	; 0x1d
    1d42:	ed 81       	ldd	r30, Y+5	; 0x05
    1d44:	fe 81       	ldd	r31, Y+6	; 0x06
    1d46:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d48:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4a:	19 f4       	brne	.+6      	; 0x1d52 <xQueueGenericSend+0xc0>
    1d4c:	ed 81       	ldd	r30, Y+5	; 0x05
    1d4e:	fe 81       	ldd	r31, Y+6	; 0x06
    1d50:	16 8e       	std	Z+30, r1	; 0x1e
    1d52:	0f 90       	pop	r0
    1d54:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d56:	ce 01       	movw	r24, r28
    1d58:	02 96       	adiw	r24, 0x02	; 2
    1d5a:	9e 01       	movw	r18, r28
    1d5c:	27 5f       	subi	r18, 0xF7	; 247
    1d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d60:	b9 01       	movw	r22, r18
    1d62:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <xTaskCheckForTimeOut>
    1d66:	88 23       	and	r24, r24
    1d68:	09 f5       	brne	.+66     	; 0x1dac <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d6e:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <prvIsQueueFull>
    1d72:	88 23       	and	r24, r24
    1d74:	a1 f0       	breq	.+40     	; 0x1d9e <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d76:	8d 81       	ldd	r24, Y+5	; 0x05
    1d78:	9e 81       	ldd	r25, Y+6	; 0x06
    1d7a:	08 96       	adiw	r24, 0x08	; 8
    1d7c:	29 85       	ldd	r18, Y+9	; 0x09
    1d7e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d80:	b9 01       	movw	r22, r18
    1d82:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d86:	8d 81       	ldd	r24, Y+5	; 0x05
    1d88:	9e 81       	ldd	r25, Y+6	; 0x06
    1d8a:	0e 94 61 11 	call	0x22c2	; 0x22c2 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d8e:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
    1d92:	88 23       	and	r24, r24
    1d94:	09 f0       	breq	.+2      	; 0x1d98 <xQueueGenericSend+0x106>
    1d96:	8f cf       	rjmp	.-226    	; 0x1cb6 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1d98:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
    1d9c:	8c cf       	rjmp	.-232    	; 0x1cb6 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1da0:	9e 81       	ldd	r25, Y+6	; 0x06
    1da2:	0e 94 61 11 	call	0x22c2	; 0x22c2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1da6:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
    1daa:	85 cf       	rjmp	.-246    	; 0x1cb6 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1dac:	8d 81       	ldd	r24, Y+5	; 0x05
    1dae:	9e 81       	ldd	r25, Y+6	; 0x06
    1db0:	0e 94 61 11 	call	0x22c2	; 0x22c2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1db4:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1db8:	1c 86       	std	Y+12, r1	; 0x0c
    1dba:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1dbc:	2c 96       	adiw	r28, 0x0c	; 12
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	cf 91       	pop	r28
    1dca:	df 91       	pop	r29
    1dcc:	08 95       	ret

00001dce <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1dce:	df 93       	push	r29
    1dd0:	cf 93       	push	r28
    1dd2:	cd b7       	in	r28, 0x3d	; 61
    1dd4:	de b7       	in	r29, 0x3e	; 62
    1dd6:	29 97       	sbiw	r28, 0x09	; 9
    1dd8:	0f b6       	in	r0, 0x3f	; 63
    1dda:	f8 94       	cli
    1ddc:	de bf       	out	0x3e, r29	; 62
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	cd bf       	out	0x3d, r28	; 61
    1de2:	9c 83       	std	Y+4, r25	; 0x04
    1de4:	8b 83       	std	Y+3, r24	; 0x03
    1de6:	7e 83       	std	Y+6, r23	; 0x06
    1de8:	6d 83       	std	Y+5, r22	; 0x05
    1dea:	58 87       	std	Y+8, r21	; 0x08
    1dec:	4f 83       	std	Y+7, r20	; 0x07
    1dee:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1df0:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1df2:	eb 81       	ldd	r30, Y+3	; 0x03
    1df4:	fc 81       	ldd	r31, Y+4	; 0x04
    1df6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1df8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfc:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dfe:	98 17       	cp	r25, r24
    1e00:	40 f5       	brcc	.+80     	; 0x1e52 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e02:	8b 81       	ldd	r24, Y+3	; 0x03
    1e04:	9c 81       	ldd	r25, Y+4	; 0x04
    1e06:	2d 81       	ldd	r18, Y+5	; 0x05
    1e08:	3e 81       	ldd	r19, Y+6	; 0x06
    1e0a:	b9 01       	movw	r22, r18
    1e0c:	49 85       	ldd	r20, Y+9	; 0x09
    1e0e:	0e 94 84 10 	call	0x2108	; 0x2108 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e12:	eb 81       	ldd	r30, Y+3	; 0x03
    1e14:	fc 81       	ldd	r31, Y+4	; 0x04
    1e16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e18:	8f 3f       	cpi	r24, 0xFF	; 255
    1e1a:	89 f4       	brne	.+34     	; 0x1e3e <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e20:	81 89       	ldd	r24, Z+17	; 0x11
    1e22:	88 23       	and	r24, r24
    1e24:	99 f0       	breq	.+38     	; 0x1e4c <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e26:	8b 81       	ldd	r24, Y+3	; 0x03
    1e28:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2a:	41 96       	adiw	r24, 0x11	; 17
    1e2c:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    1e30:	88 23       	and	r24, r24
    1e32:	61 f0       	breq	.+24     	; 0x1e4c <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e34:	ef 81       	ldd	r30, Y+7	; 0x07
    1e36:	f8 85       	ldd	r31, Y+8	; 0x08
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	80 83       	st	Z, r24
    1e3c:	07 c0       	rjmp	.+14     	; 0x1e4c <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e44:	8f 5f       	subi	r24, 0xFF	; 255
    1e46:	eb 81       	ldd	r30, Y+3	; 0x03
    1e48:	fc 81       	ldd	r31, Y+4	; 0x04
    1e4a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	8a 83       	std	Y+2, r24	; 0x02
    1e50:	01 c0       	rjmp	.+2      	; 0x1e54 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e52:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e54:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1e56:	29 96       	adiw	r28, 0x09	; 9
    1e58:	0f b6       	in	r0, 0x3f	; 63
    1e5a:	f8 94       	cli
    1e5c:	de bf       	out	0x3e, r29	; 62
    1e5e:	0f be       	out	0x3f, r0	; 63
    1e60:	cd bf       	out	0x3d, r28	; 61
    1e62:	cf 91       	pop	r28
    1e64:	df 91       	pop	r29
    1e66:	08 95       	ret

00001e68 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1e68:	df 93       	push	r29
    1e6a:	cf 93       	push	r28
    1e6c:	cd b7       	in	r28, 0x3d	; 61
    1e6e:	de b7       	in	r29, 0x3e	; 62
    1e70:	2e 97       	sbiw	r28, 0x0e	; 14
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	de bf       	out	0x3e, r29	; 62
    1e78:	0f be       	out	0x3f, r0	; 63
    1e7a:	cd bf       	out	0x3d, r28	; 61
    1e7c:	98 87       	std	Y+8, r25	; 0x08
    1e7e:	8f 83       	std	Y+7, r24	; 0x07
    1e80:	7a 87       	std	Y+10, r23	; 0x0a
    1e82:	69 87       	std	Y+9, r22	; 0x09
    1e84:	5c 87       	std	Y+12, r21	; 0x0c
    1e86:	4b 87       	std	Y+11, r20	; 0x0b
    1e88:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e8a:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e8c:	0f b6       	in	r0, 0x3f	; 63
    1e8e:	f8 94       	cli
    1e90:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1e92:	ef 81       	ldd	r30, Y+7	; 0x07
    1e94:	f8 85       	ldd	r31, Y+8	; 0x08
    1e96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e98:	88 23       	and	r24, r24
    1e9a:	09 f4       	brne	.+2      	; 0x1e9e <xQueueGenericReceive+0x36>
    1e9c:	3f c0       	rjmp	.+126    	; 0x1f1c <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1e9e:	ef 81       	ldd	r30, Y+7	; 0x07
    1ea0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ea2:	86 81       	ldd	r24, Z+6	; 0x06
    1ea4:	97 81       	ldd	r25, Z+7	; 0x07
    1ea6:	9a 83       	std	Y+2, r25	; 0x02
    1ea8:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1eaa:	8f 81       	ldd	r24, Y+7	; 0x07
    1eac:	98 85       	ldd	r25, Y+8	; 0x08
    1eae:	29 85       	ldd	r18, Y+9	; 0x09
    1eb0:	3a 85       	ldd	r19, Y+10	; 0x0a
    1eb2:	b9 01       	movw	r22, r18
    1eb4:	0e 94 19 11 	call	0x2232	; 0x2232 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1eb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eba:	88 23       	and	r24, r24
    1ebc:	b1 f4       	brne	.+44     	; 0x1eea <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1ebe:	ef 81       	ldd	r30, Y+7	; 0x07
    1ec0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ec2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec4:	81 50       	subi	r24, 0x01	; 1
    1ec6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ec8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eca:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ecc:	ef 81       	ldd	r30, Y+7	; 0x07
    1ece:	f8 85       	ldd	r31, Y+8	; 0x08
    1ed0:	80 85       	ldd	r24, Z+8	; 0x08
    1ed2:	88 23       	and	r24, r24
    1ed4:	f1 f0       	breq	.+60     	; 0x1f12 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1ed6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed8:	98 85       	ldd	r25, Y+8	; 0x08
    1eda:	08 96       	adiw	r24, 0x08	; 8
    1edc:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    1ee0:	81 30       	cpi	r24, 0x01	; 1
    1ee2:	b9 f4       	brne	.+46     	; 0x1f12 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1ee4:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
    1ee8:	14 c0       	rjmp	.+40     	; 0x1f12 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1eea:	ef 81       	ldd	r30, Y+7	; 0x07
    1eec:	f8 85       	ldd	r31, Y+8	; 0x08
    1eee:	89 81       	ldd	r24, Y+1	; 0x01
    1ef0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef2:	97 83       	std	Z+7, r25	; 0x07
    1ef4:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ef6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ef8:	f8 85       	ldd	r31, Y+8	; 0x08
    1efa:	81 89       	ldd	r24, Z+17	; 0x11
    1efc:	88 23       	and	r24, r24
    1efe:	49 f0       	breq	.+18     	; 0x1f12 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f00:	8f 81       	ldd	r24, Y+7	; 0x07
    1f02:	98 85       	ldd	r25, Y+8	; 0x08
    1f04:	41 96       	adiw	r24, 0x11	; 17
    1f06:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    1f0a:	88 23       	and	r24, r24
    1f0c:	11 f0       	breq	.+4      	; 0x1f12 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f0e:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1f12:	0f 90       	pop	r0
    1f14:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	8e 87       	std	Y+14, r24	; 0x0e
    1f1a:	5c c0       	rjmp	.+184    	; 0x1fd4 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1f1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f1e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f20:	00 97       	sbiw	r24, 0x00	; 0
    1f22:	21 f4       	brne	.+8      	; 0x1f2c <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f24:	0f 90       	pop	r0
    1f26:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f28:	1e 86       	std	Y+14, r1	; 0x0e
    1f2a:	54 c0       	rjmp	.+168    	; 0x1fd4 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2e:	88 23       	and	r24, r24
    1f30:	31 f4       	brne	.+12     	; 0x1f3e <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f32:	ce 01       	movw	r24, r28
    1f34:	04 96       	adiw	r24, 0x04	; 4
    1f36:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1f3e:	0f 90       	pop	r0
    1f40:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f42:	0e 94 5d 14 	call	0x28ba	; 0x28ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	f8 94       	cli
    1f4a:	0f 92       	push	r0
    1f4c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f4e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f50:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f52:	8f 3f       	cpi	r24, 0xFF	; 255
    1f54:	19 f4       	brne	.+6      	; 0x1f5c <xQueueGenericReceive+0xf4>
    1f56:	ef 81       	ldd	r30, Y+7	; 0x07
    1f58:	f8 85       	ldd	r31, Y+8	; 0x08
    1f5a:	15 8e       	std	Z+29, r1	; 0x1d
    1f5c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f5e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f60:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f62:	8f 3f       	cpi	r24, 0xFF	; 255
    1f64:	19 f4       	brne	.+6      	; 0x1f6c <xQueueGenericReceive+0x104>
    1f66:	ef 81       	ldd	r30, Y+7	; 0x07
    1f68:	f8 85       	ldd	r31, Y+8	; 0x08
    1f6a:	16 8e       	std	Z+30, r1	; 0x1e
    1f6c:	0f 90       	pop	r0
    1f6e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f70:	ce 01       	movw	r24, r28
    1f72:	04 96       	adiw	r24, 0x04	; 4
    1f74:	9e 01       	movw	r18, r28
    1f76:	25 5f       	subi	r18, 0xF5	; 245
    1f78:	3f 4f       	sbci	r19, 0xFF	; 255
    1f7a:	b9 01       	movw	r22, r18
    1f7c:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <xTaskCheckForTimeOut>
    1f80:	88 23       	and	r24, r24
    1f82:	09 f5       	brne	.+66     	; 0x1fc6 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f84:	8f 81       	ldd	r24, Y+7	; 0x07
    1f86:	98 85       	ldd	r25, Y+8	; 0x08
    1f88:	0e 94 b5 11 	call	0x236a	; 0x236a <prvIsQueueEmpty>
    1f8c:	88 23       	and	r24, r24
    1f8e:	a1 f0       	breq	.+40     	; 0x1fb8 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f90:	8f 81       	ldd	r24, Y+7	; 0x07
    1f92:	98 85       	ldd	r25, Y+8	; 0x08
    1f94:	41 96       	adiw	r24, 0x11	; 17
    1f96:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f98:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f9a:	b9 01       	movw	r22, r18
    1f9c:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fa0:	8f 81       	ldd	r24, Y+7	; 0x07
    1fa2:	98 85       	ldd	r25, Y+8	; 0x08
    1fa4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1fa8:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
    1fac:	88 23       	and	r24, r24
    1fae:	09 f0       	breq	.+2      	; 0x1fb2 <xQueueGenericReceive+0x14a>
    1fb0:	6d cf       	rjmp	.-294    	; 0x1e8c <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1fb2:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
    1fb6:	6a cf       	rjmp	.-300    	; 0x1e8c <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1fb8:	8f 81       	ldd	r24, Y+7	; 0x07
    1fba:	98 85       	ldd	r25, Y+8	; 0x08
    1fbc:	0e 94 61 11 	call	0x22c2	; 0x22c2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1fc0:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
    1fc4:	63 cf       	rjmp	.-314    	; 0x1e8c <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1fc6:	8f 81       	ldd	r24, Y+7	; 0x07
    1fc8:	98 85       	ldd	r25, Y+8	; 0x08
    1fca:	0e 94 61 11 	call	0x22c2	; 0x22c2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1fce:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1fd2:	1e 86       	std	Y+14, r1	; 0x0e
    1fd4:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1fd6:	2e 96       	adiw	r28, 0x0e	; 14
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	de bf       	out	0x3e, r29	; 62
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	cd bf       	out	0x3d, r28	; 61
    1fe2:	cf 91       	pop	r28
    1fe4:	df 91       	pop	r29
    1fe6:	08 95       	ret

00001fe8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1fe8:	df 93       	push	r29
    1fea:	cf 93       	push	r28
    1fec:	cd b7       	in	r28, 0x3d	; 61
    1fee:	de b7       	in	r29, 0x3e	; 62
    1ff0:	28 97       	sbiw	r28, 0x08	; 8
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	de bf       	out	0x3e, r29	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	cd bf       	out	0x3d, r28	; 61
    1ffc:	9c 83       	std	Y+4, r25	; 0x04
    1ffe:	8b 83       	std	Y+3, r24	; 0x03
    2000:	7e 83       	std	Y+6, r23	; 0x06
    2002:	6d 83       	std	Y+5, r22	; 0x05
    2004:	58 87       	std	Y+8, r21	; 0x08
    2006:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2008:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    200a:	eb 81       	ldd	r30, Y+3	; 0x03
    200c:	fc 81       	ldd	r31, Y+4	; 0x04
    200e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2010:	88 23       	and	r24, r24
    2012:	71 f1       	breq	.+92     	; 0x2070 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2014:	8b 81       	ldd	r24, Y+3	; 0x03
    2016:	9c 81       	ldd	r25, Y+4	; 0x04
    2018:	2d 81       	ldd	r18, Y+5	; 0x05
    201a:	3e 81       	ldd	r19, Y+6	; 0x06
    201c:	b9 01       	movw	r22, r18
    201e:	0e 94 19 11 	call	0x2232	; 0x2232 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2022:	eb 81       	ldd	r30, Y+3	; 0x03
    2024:	fc 81       	ldd	r31, Y+4	; 0x04
    2026:	82 8d       	ldd	r24, Z+26	; 0x1a
    2028:	81 50       	subi	r24, 0x01	; 1
    202a:	eb 81       	ldd	r30, Y+3	; 0x03
    202c:	fc 81       	ldd	r31, Y+4	; 0x04
    202e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2030:	eb 81       	ldd	r30, Y+3	; 0x03
    2032:	fc 81       	ldd	r31, Y+4	; 0x04
    2034:	85 8d       	ldd	r24, Z+29	; 0x1d
    2036:	8f 3f       	cpi	r24, 0xFF	; 255
    2038:	89 f4       	brne	.+34     	; 0x205c <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    203a:	eb 81       	ldd	r30, Y+3	; 0x03
    203c:	fc 81       	ldd	r31, Y+4	; 0x04
    203e:	80 85       	ldd	r24, Z+8	; 0x08
    2040:	88 23       	and	r24, r24
    2042:	99 f0       	breq	.+38     	; 0x206a <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2044:	8b 81       	ldd	r24, Y+3	; 0x03
    2046:	9c 81       	ldd	r25, Y+4	; 0x04
    2048:	08 96       	adiw	r24, 0x08	; 8
    204a:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    204e:	88 23       	and	r24, r24
    2050:	61 f0       	breq	.+24     	; 0x206a <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2052:	ef 81       	ldd	r30, Y+7	; 0x07
    2054:	f8 85       	ldd	r31, Y+8	; 0x08
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	80 83       	st	Z, r24
    205a:	07 c0       	rjmp	.+14     	; 0x206a <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    205c:	eb 81       	ldd	r30, Y+3	; 0x03
    205e:	fc 81       	ldd	r31, Y+4	; 0x04
    2060:	85 8d       	ldd	r24, Z+29	; 0x1d
    2062:	8f 5f       	subi	r24, 0xFF	; 255
    2064:	eb 81       	ldd	r30, Y+3	; 0x03
    2066:	fc 81       	ldd	r31, Y+4	; 0x04
    2068:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    206a:	81 e0       	ldi	r24, 0x01	; 1
    206c:	8a 83       	std	Y+2, r24	; 0x02
    206e:	01 c0       	rjmp	.+2      	; 0x2072 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2070:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2072:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2074:	28 96       	adiw	r28, 0x08	; 8
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	de bf       	out	0x3e, r29	; 62
    207c:	0f be       	out	0x3f, r0	; 63
    207e:	cd bf       	out	0x3d, r28	; 61
    2080:	cf 91       	pop	r28
    2082:	df 91       	pop	r29
    2084:	08 95       	ret

00002086 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2086:	df 93       	push	r29
    2088:	cf 93       	push	r28
    208a:	00 d0       	rcall	.+0      	; 0x208c <uxQueueMessagesWaiting+0x6>
    208c:	0f 92       	push	r0
    208e:	cd b7       	in	r28, 0x3d	; 61
    2090:	de b7       	in	r29, 0x3e	; 62
    2092:	9b 83       	std	Y+3, r25	; 0x03
    2094:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    209c:	ea 81       	ldd	r30, Y+2	; 0x02
    209e:	fb 81       	ldd	r31, Y+3	; 0x03
    20a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    20a4:	0f 90       	pop	r0
    20a6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    20aa:	0f 90       	pop	r0
    20ac:	0f 90       	pop	r0
    20ae:	0f 90       	pop	r0
    20b0:	cf 91       	pop	r28
    20b2:	df 91       	pop	r29
    20b4:	08 95       	ret

000020b6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    20b6:	df 93       	push	r29
    20b8:	cf 93       	push	r28
    20ba:	00 d0       	rcall	.+0      	; 0x20bc <uxQueueMessagesWaitingFromISR+0x6>
    20bc:	0f 92       	push	r0
    20be:	cd b7       	in	r28, 0x3d	; 61
    20c0:	de b7       	in	r29, 0x3e	; 62
    20c2:	9b 83       	std	Y+3, r25	; 0x03
    20c4:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    20c6:	ea 81       	ldd	r30, Y+2	; 0x02
    20c8:	fb 81       	ldd	r31, Y+3	; 0x03
    20ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    20cc:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    20ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    20d0:	0f 90       	pop	r0
    20d2:	0f 90       	pop	r0
    20d4:	0f 90       	pop	r0
    20d6:	cf 91       	pop	r28
    20d8:	df 91       	pop	r29
    20da:	08 95       	ret

000020dc <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    20dc:	df 93       	push	r29
    20de:	cf 93       	push	r28
    20e0:	00 d0       	rcall	.+0      	; 0x20e2 <vQueueDelete+0x6>
    20e2:	cd b7       	in	r28, 0x3d	; 61
    20e4:	de b7       	in	r29, 0x3e	; 62
    20e6:	9a 83       	std	Y+2, r25	; 0x02
    20e8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    20ea:	e9 81       	ldd	r30, Y+1	; 0x01
    20ec:	fa 81       	ldd	r31, Y+2	; 0x02
    20ee:	80 81       	ld	r24, Z
    20f0:	91 81       	ldd	r25, Z+1	; 0x01
    20f2:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
	vPortFree( pxQueue );
    20f6:	89 81       	ldd	r24, Y+1	; 0x01
    20f8:	9a 81       	ldd	r25, Y+2	; 0x02
    20fa:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
}
    20fe:	0f 90       	pop	r0
    2100:	0f 90       	pop	r0
    2102:	cf 91       	pop	r28
    2104:	df 91       	pop	r29
    2106:	08 95       	ret

00002108 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2108:	df 93       	push	r29
    210a:	cf 93       	push	r28
    210c:	00 d0       	rcall	.+0      	; 0x210e <prvCopyDataToQueue+0x6>
    210e:	00 d0       	rcall	.+0      	; 0x2110 <prvCopyDataToQueue+0x8>
    2110:	0f 92       	push	r0
    2112:	cd b7       	in	r28, 0x3d	; 61
    2114:	de b7       	in	r29, 0x3e	; 62
    2116:	9a 83       	std	Y+2, r25	; 0x02
    2118:	89 83       	std	Y+1, r24	; 0x01
    211a:	7c 83       	std	Y+4, r23	; 0x04
    211c:	6b 83       	std	Y+3, r22	; 0x03
    211e:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2120:	e9 81       	ldd	r30, Y+1	; 0x01
    2122:	fa 81       	ldd	r31, Y+2	; 0x02
    2124:	84 8d       	ldd	r24, Z+28	; 0x1c
    2126:	88 23       	and	r24, r24
    2128:	09 f4       	brne	.+2      	; 0x212c <prvCopyDataToQueue+0x24>
    212a:	74 c0       	rjmp	.+232    	; 0x2214 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    212c:	8d 81       	ldd	r24, Y+5	; 0x05
    212e:	88 23       	and	r24, r24
    2130:	99 f5       	brne	.+102    	; 0x2198 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2132:	e9 81       	ldd	r30, Y+1	; 0x01
    2134:	fa 81       	ldd	r31, Y+2	; 0x02
    2136:	64 81       	ldd	r22, Z+4	; 0x04
    2138:	75 81       	ldd	r23, Z+5	; 0x05
    213a:	e9 81       	ldd	r30, Y+1	; 0x01
    213c:	fa 81       	ldd	r31, Y+2	; 0x02
    213e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2140:	48 2f       	mov	r20, r24
    2142:	50 e0       	ldi	r21, 0x00	; 0
    2144:	2b 81       	ldd	r18, Y+3	; 0x03
    2146:	3c 81       	ldd	r19, Y+4	; 0x04
    2148:	cb 01       	movw	r24, r22
    214a:	b9 01       	movw	r22, r18
    214c:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2150:	e9 81       	ldd	r30, Y+1	; 0x01
    2152:	fa 81       	ldd	r31, Y+2	; 0x02
    2154:	24 81       	ldd	r18, Z+4	; 0x04
    2156:	35 81       	ldd	r19, Z+5	; 0x05
    2158:	e9 81       	ldd	r30, Y+1	; 0x01
    215a:	fa 81       	ldd	r31, Y+2	; 0x02
    215c:	84 8d       	ldd	r24, Z+28	; 0x1c
    215e:	88 2f       	mov	r24, r24
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	82 0f       	add	r24, r18
    2164:	93 1f       	adc	r25, r19
    2166:	e9 81       	ldd	r30, Y+1	; 0x01
    2168:	fa 81       	ldd	r31, Y+2	; 0x02
    216a:	95 83       	std	Z+5, r25	; 0x05
    216c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    216e:	e9 81       	ldd	r30, Y+1	; 0x01
    2170:	fa 81       	ldd	r31, Y+2	; 0x02
    2172:	24 81       	ldd	r18, Z+4	; 0x04
    2174:	35 81       	ldd	r19, Z+5	; 0x05
    2176:	e9 81       	ldd	r30, Y+1	; 0x01
    2178:	fa 81       	ldd	r31, Y+2	; 0x02
    217a:	82 81       	ldd	r24, Z+2	; 0x02
    217c:	93 81       	ldd	r25, Z+3	; 0x03
    217e:	28 17       	cp	r18, r24
    2180:	39 07       	cpc	r19, r25
    2182:	08 f4       	brcc	.+2      	; 0x2186 <prvCopyDataToQueue+0x7e>
    2184:	47 c0       	rjmp	.+142    	; 0x2214 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2186:	e9 81       	ldd	r30, Y+1	; 0x01
    2188:	fa 81       	ldd	r31, Y+2	; 0x02
    218a:	80 81       	ld	r24, Z
    218c:	91 81       	ldd	r25, Z+1	; 0x01
    218e:	e9 81       	ldd	r30, Y+1	; 0x01
    2190:	fa 81       	ldd	r31, Y+2	; 0x02
    2192:	95 83       	std	Z+5, r25	; 0x05
    2194:	84 83       	std	Z+4, r24	; 0x04
    2196:	3e c0       	rjmp	.+124    	; 0x2214 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2198:	e9 81       	ldd	r30, Y+1	; 0x01
    219a:	fa 81       	ldd	r31, Y+2	; 0x02
    219c:	66 81       	ldd	r22, Z+6	; 0x06
    219e:	77 81       	ldd	r23, Z+7	; 0x07
    21a0:	e9 81       	ldd	r30, Y+1	; 0x01
    21a2:	fa 81       	ldd	r31, Y+2	; 0x02
    21a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    21a6:	48 2f       	mov	r20, r24
    21a8:	50 e0       	ldi	r21, 0x00	; 0
    21aa:	2b 81       	ldd	r18, Y+3	; 0x03
    21ac:	3c 81       	ldd	r19, Y+4	; 0x04
    21ae:	cb 01       	movw	r24, r22
    21b0:	b9 01       	movw	r22, r18
    21b2:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    21b6:	e9 81       	ldd	r30, Y+1	; 0x01
    21b8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ba:	26 81       	ldd	r18, Z+6	; 0x06
    21bc:	37 81       	ldd	r19, Z+7	; 0x07
    21be:	e9 81       	ldd	r30, Y+1	; 0x01
    21c0:	fa 81       	ldd	r31, Y+2	; 0x02
    21c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21c4:	88 2f       	mov	r24, r24
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	90 95       	com	r25
    21ca:	81 95       	neg	r24
    21cc:	9f 4f       	sbci	r25, 0xFF	; 255
    21ce:	82 0f       	add	r24, r18
    21d0:	93 1f       	adc	r25, r19
    21d2:	e9 81       	ldd	r30, Y+1	; 0x01
    21d4:	fa 81       	ldd	r31, Y+2	; 0x02
    21d6:	97 83       	std	Z+7, r25	; 0x07
    21d8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    21da:	e9 81       	ldd	r30, Y+1	; 0x01
    21dc:	fa 81       	ldd	r31, Y+2	; 0x02
    21de:	26 81       	ldd	r18, Z+6	; 0x06
    21e0:	37 81       	ldd	r19, Z+7	; 0x07
    21e2:	e9 81       	ldd	r30, Y+1	; 0x01
    21e4:	fa 81       	ldd	r31, Y+2	; 0x02
    21e6:	80 81       	ld	r24, Z
    21e8:	91 81       	ldd	r25, Z+1	; 0x01
    21ea:	28 17       	cp	r18, r24
    21ec:	39 07       	cpc	r19, r25
    21ee:	90 f4       	brcc	.+36     	; 0x2214 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    21f0:	e9 81       	ldd	r30, Y+1	; 0x01
    21f2:	fa 81       	ldd	r31, Y+2	; 0x02
    21f4:	22 81       	ldd	r18, Z+2	; 0x02
    21f6:	33 81       	ldd	r19, Z+3	; 0x03
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    21fe:	88 2f       	mov	r24, r24
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	90 95       	com	r25
    2204:	81 95       	neg	r24
    2206:	9f 4f       	sbci	r25, 0xFF	; 255
    2208:	82 0f       	add	r24, r18
    220a:	93 1f       	adc	r25, r19
    220c:	e9 81       	ldd	r30, Y+1	; 0x01
    220e:	fa 81       	ldd	r31, Y+2	; 0x02
    2210:	97 83       	std	Z+7, r25	; 0x07
    2212:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2214:	e9 81       	ldd	r30, Y+1	; 0x01
    2216:	fa 81       	ldd	r31, Y+2	; 0x02
    2218:	82 8d       	ldd	r24, Z+26	; 0x1a
    221a:	8f 5f       	subi	r24, 0xFF	; 255
    221c:	e9 81       	ldd	r30, Y+1	; 0x01
    221e:	fa 81       	ldd	r31, Y+2	; 0x02
    2220:	82 8f       	std	Z+26, r24	; 0x1a
}
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
    2228:	0f 90       	pop	r0
    222a:	0f 90       	pop	r0
    222c:	cf 91       	pop	r28
    222e:	df 91       	pop	r29
    2230:	08 95       	ret

00002232 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2232:	df 93       	push	r29
    2234:	cf 93       	push	r28
    2236:	00 d0       	rcall	.+0      	; 0x2238 <prvCopyDataFromQueue+0x6>
    2238:	00 d0       	rcall	.+0      	; 0x223a <prvCopyDataFromQueue+0x8>
    223a:	cd b7       	in	r28, 0x3d	; 61
    223c:	de b7       	in	r29, 0x3e	; 62
    223e:	9a 83       	std	Y+2, r25	; 0x02
    2240:	89 83       	std	Y+1, r24	; 0x01
    2242:	7c 83       	std	Y+4, r23	; 0x04
    2244:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2246:	e9 81       	ldd	r30, Y+1	; 0x01
    2248:	fa 81       	ldd	r31, Y+2	; 0x02
    224a:	80 81       	ld	r24, Z
    224c:	91 81       	ldd	r25, Z+1	; 0x01
    224e:	00 97       	sbiw	r24, 0x00	; 0
    2250:	89 f1       	breq	.+98     	; 0x22b4 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2252:	e9 81       	ldd	r30, Y+1	; 0x01
    2254:	fa 81       	ldd	r31, Y+2	; 0x02
    2256:	26 81       	ldd	r18, Z+6	; 0x06
    2258:	37 81       	ldd	r19, Z+7	; 0x07
    225a:	e9 81       	ldd	r30, Y+1	; 0x01
    225c:	fa 81       	ldd	r31, Y+2	; 0x02
    225e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2260:	88 2f       	mov	r24, r24
    2262:	90 e0       	ldi	r25, 0x00	; 0
    2264:	82 0f       	add	r24, r18
    2266:	93 1f       	adc	r25, r19
    2268:	e9 81       	ldd	r30, Y+1	; 0x01
    226a:	fa 81       	ldd	r31, Y+2	; 0x02
    226c:	97 83       	std	Z+7, r25	; 0x07
    226e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2270:	e9 81       	ldd	r30, Y+1	; 0x01
    2272:	fa 81       	ldd	r31, Y+2	; 0x02
    2274:	26 81       	ldd	r18, Z+6	; 0x06
    2276:	37 81       	ldd	r19, Z+7	; 0x07
    2278:	e9 81       	ldd	r30, Y+1	; 0x01
    227a:	fa 81       	ldd	r31, Y+2	; 0x02
    227c:	82 81       	ldd	r24, Z+2	; 0x02
    227e:	93 81       	ldd	r25, Z+3	; 0x03
    2280:	28 17       	cp	r18, r24
    2282:	39 07       	cpc	r19, r25
    2284:	40 f0       	brcs	.+16     	; 0x2296 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2286:	e9 81       	ldd	r30, Y+1	; 0x01
    2288:	fa 81       	ldd	r31, Y+2	; 0x02
    228a:	80 81       	ld	r24, Z
    228c:	91 81       	ldd	r25, Z+1	; 0x01
    228e:	e9 81       	ldd	r30, Y+1	; 0x01
    2290:	fa 81       	ldd	r31, Y+2	; 0x02
    2292:	97 83       	std	Z+7, r25	; 0x07
    2294:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2296:	e9 81       	ldd	r30, Y+1	; 0x01
    2298:	fa 81       	ldd	r31, Y+2	; 0x02
    229a:	46 81       	ldd	r20, Z+6	; 0x06
    229c:	57 81       	ldd	r21, Z+7	; 0x07
    229e:	e9 81       	ldd	r30, Y+1	; 0x01
    22a0:	fa 81       	ldd	r31, Y+2	; 0x02
    22a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    22a4:	28 2f       	mov	r18, r24
    22a6:	30 e0       	ldi	r19, 0x00	; 0
    22a8:	8b 81       	ldd	r24, Y+3	; 0x03
    22aa:	9c 81       	ldd	r25, Y+4	; 0x04
    22ac:	ba 01       	movw	r22, r20
    22ae:	a9 01       	movw	r20, r18
    22b0:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <memcpy>
	}
}
    22b4:	0f 90       	pop	r0
    22b6:	0f 90       	pop	r0
    22b8:	0f 90       	pop	r0
    22ba:	0f 90       	pop	r0
    22bc:	cf 91       	pop	r28
    22be:	df 91       	pop	r29
    22c0:	08 95       	ret

000022c2 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    22c2:	df 93       	push	r29
    22c4:	cf 93       	push	r28
    22c6:	00 d0       	rcall	.+0      	; 0x22c8 <prvUnlockQueue+0x6>
    22c8:	cd b7       	in	r28, 0x3d	; 61
    22ca:	de b7       	in	r29, 0x3e	; 62
    22cc:	9a 83       	std	Y+2, r25	; 0x02
    22ce:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    22d0:	0f b6       	in	r0, 0x3f	; 63
    22d2:	f8 94       	cli
    22d4:	0f 92       	push	r0
    22d6:	15 c0       	rjmp	.+42     	; 0x2302 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22d8:	e9 81       	ldd	r30, Y+1	; 0x01
    22da:	fa 81       	ldd	r31, Y+2	; 0x02
    22dc:	81 89       	ldd	r24, Z+17	; 0x11
    22de:	88 23       	and	r24, r24
    22e0:	a9 f0       	breq	.+42     	; 0x230c <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22e2:	89 81       	ldd	r24, Y+1	; 0x01
    22e4:	9a 81       	ldd	r25, Y+2	; 0x02
    22e6:	41 96       	adiw	r24, 0x11	; 17
    22e8:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    22ec:	88 23       	and	r24, r24
    22ee:	11 f0       	breq	.+4      	; 0x22f4 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    22f0:	0e 94 77 17 	call	0x2eee	; 0x2eee <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    22f4:	e9 81       	ldd	r30, Y+1	; 0x01
    22f6:	fa 81       	ldd	r31, Y+2	; 0x02
    22f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    22fa:	81 50       	subi	r24, 0x01	; 1
    22fc:	e9 81       	ldd	r30, Y+1	; 0x01
    22fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2300:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2302:	e9 81       	ldd	r30, Y+1	; 0x01
    2304:	fa 81       	ldd	r31, Y+2	; 0x02
    2306:	86 8d       	ldd	r24, Z+30	; 0x1e
    2308:	18 16       	cp	r1, r24
    230a:	34 f3       	brlt	.-52     	; 0x22d8 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    230c:	e9 81       	ldd	r30, Y+1	; 0x01
    230e:	fa 81       	ldd	r31, Y+2	; 0x02
    2310:	8f ef       	ldi	r24, 0xFF	; 255
    2312:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2314:	0f 90       	pop	r0
    2316:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2318:	0f b6       	in	r0, 0x3f	; 63
    231a:	f8 94       	cli
    231c:	0f 92       	push	r0
    231e:	15 c0       	rjmp	.+42     	; 0x234a <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2320:	e9 81       	ldd	r30, Y+1	; 0x01
    2322:	fa 81       	ldd	r31, Y+2	; 0x02
    2324:	80 85       	ldd	r24, Z+8	; 0x08
    2326:	88 23       	and	r24, r24
    2328:	a9 f0       	breq	.+42     	; 0x2354 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    232a:	89 81       	ldd	r24, Y+1	; 0x01
    232c:	9a 81       	ldd	r25, Y+2	; 0x02
    232e:	08 96       	adiw	r24, 0x08	; 8
    2330:	0e 94 99 16 	call	0x2d32	; 0x2d32 <xTaskRemoveFromEventList>
    2334:	88 23       	and	r24, r24
    2336:	11 f0       	breq	.+4      	; 0x233c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2338:	0e 94 77 17 	call	0x2eee	; 0x2eee <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    233c:	e9 81       	ldd	r30, Y+1	; 0x01
    233e:	fa 81       	ldd	r31, Y+2	; 0x02
    2340:	85 8d       	ldd	r24, Z+29	; 0x1d
    2342:	81 50       	subi	r24, 0x01	; 1
    2344:	e9 81       	ldd	r30, Y+1	; 0x01
    2346:	fa 81       	ldd	r31, Y+2	; 0x02
    2348:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    234a:	e9 81       	ldd	r30, Y+1	; 0x01
    234c:	fa 81       	ldd	r31, Y+2	; 0x02
    234e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2350:	18 16       	cp	r1, r24
    2352:	34 f3       	brlt	.-52     	; 0x2320 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2354:	e9 81       	ldd	r30, Y+1	; 0x01
    2356:	fa 81       	ldd	r31, Y+2	; 0x02
    2358:	8f ef       	ldi	r24, 0xFF	; 255
    235a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    235c:	0f 90       	pop	r0
    235e:	0f be       	out	0x3f, r0	; 63
}
    2360:	0f 90       	pop	r0
    2362:	0f 90       	pop	r0
    2364:	cf 91       	pop	r28
    2366:	df 91       	pop	r29
    2368:	08 95       	ret

0000236a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    236a:	df 93       	push	r29
    236c:	cf 93       	push	r28
    236e:	00 d0       	rcall	.+0      	; 0x2370 <prvIsQueueEmpty+0x6>
    2370:	0f 92       	push	r0
    2372:	cd b7       	in	r28, 0x3d	; 61
    2374:	de b7       	in	r29, 0x3e	; 62
    2376:	9b 83       	std	Y+3, r25	; 0x03
    2378:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    237a:	0f b6       	in	r0, 0x3f	; 63
    237c:	f8 94       	cli
    237e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2380:	ea 81       	ldd	r30, Y+2	; 0x02
    2382:	fb 81       	ldd	r31, Y+3	; 0x03
    2384:	82 8d       	ldd	r24, Z+26	; 0x1a
    2386:	19 82       	std	Y+1, r1	; 0x01
    2388:	88 23       	and	r24, r24
    238a:	11 f4       	brne	.+4      	; 0x2390 <prvIsQueueEmpty+0x26>
    238c:	81 e0       	ldi	r24, 0x01	; 1
    238e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2394:	89 81       	ldd	r24, Y+1	; 0x01
}
    2396:	0f 90       	pop	r0
    2398:	0f 90       	pop	r0
    239a:	0f 90       	pop	r0
    239c:	cf 91       	pop	r28
    239e:	df 91       	pop	r29
    23a0:	08 95       	ret

000023a2 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    23a2:	df 93       	push	r29
    23a4:	cf 93       	push	r28
    23a6:	00 d0       	rcall	.+0      	; 0x23a8 <xQueueIsQueueEmptyFromISR+0x6>
    23a8:	0f 92       	push	r0
    23aa:	cd b7       	in	r28, 0x3d	; 61
    23ac:	de b7       	in	r29, 0x3e	; 62
    23ae:	9b 83       	std	Y+3, r25	; 0x03
    23b0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    23b2:	ea 81       	ldd	r30, Y+2	; 0x02
    23b4:	fb 81       	ldd	r31, Y+3	; 0x03
    23b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    23b8:	19 82       	std	Y+1, r1	; 0x01
    23ba:	88 23       	and	r24, r24
    23bc:	11 f4       	brne	.+4      	; 0x23c2 <xQueueIsQueueEmptyFromISR+0x20>
    23be:	81 e0       	ldi	r24, 0x01	; 1
    23c0:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    23c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    23c4:	0f 90       	pop	r0
    23c6:	0f 90       	pop	r0
    23c8:	0f 90       	pop	r0
    23ca:	cf 91       	pop	r28
    23cc:	df 91       	pop	r29
    23ce:	08 95       	ret

000023d0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    23d0:	df 93       	push	r29
    23d2:	cf 93       	push	r28
    23d4:	00 d0       	rcall	.+0      	; 0x23d6 <prvIsQueueFull+0x6>
    23d6:	0f 92       	push	r0
    23d8:	cd b7       	in	r28, 0x3d	; 61
    23da:	de b7       	in	r29, 0x3e	; 62
    23dc:	9b 83       	std	Y+3, r25	; 0x03
    23de:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	f8 94       	cli
    23e4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23e6:	ea 81       	ldd	r30, Y+2	; 0x02
    23e8:	fb 81       	ldd	r31, Y+3	; 0x03
    23ea:	92 8d       	ldd	r25, Z+26	; 0x1a
    23ec:	ea 81       	ldd	r30, Y+2	; 0x02
    23ee:	fb 81       	ldd	r31, Y+3	; 0x03
    23f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    23f2:	19 82       	std	Y+1, r1	; 0x01
    23f4:	98 17       	cp	r25, r24
    23f6:	11 f4       	brne	.+4      	; 0x23fc <prvIsQueueFull+0x2c>
    23f8:	81 e0       	ldi	r24, 0x01	; 1
    23fa:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23fc:	0f 90       	pop	r0
    23fe:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2400:	89 81       	ldd	r24, Y+1	; 0x01
}
    2402:	0f 90       	pop	r0
    2404:	0f 90       	pop	r0
    2406:	0f 90       	pop	r0
    2408:	cf 91       	pop	r28
    240a:	df 91       	pop	r29
    240c:	08 95       	ret

0000240e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    240e:	df 93       	push	r29
    2410:	cf 93       	push	r28
    2412:	00 d0       	rcall	.+0      	; 0x2414 <xQueueIsQueueFullFromISR+0x6>
    2414:	0f 92       	push	r0
    2416:	cd b7       	in	r28, 0x3d	; 61
    2418:	de b7       	in	r29, 0x3e	; 62
    241a:	9b 83       	std	Y+3, r25	; 0x03
    241c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    241e:	ea 81       	ldd	r30, Y+2	; 0x02
    2420:	fb 81       	ldd	r31, Y+3	; 0x03
    2422:	92 8d       	ldd	r25, Z+26	; 0x1a
    2424:	ea 81       	ldd	r30, Y+2	; 0x02
    2426:	fb 81       	ldd	r31, Y+3	; 0x03
    2428:	83 8d       	ldd	r24, Z+27	; 0x1b
    242a:	19 82       	std	Y+1, r1	; 0x01
    242c:	98 17       	cp	r25, r24
    242e:	11 f4       	brne	.+4      	; 0x2434 <xQueueIsQueueFullFromISR+0x26>
    2430:	81 e0       	ldi	r24, 0x01	; 1
    2432:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2434:	89 81       	ldd	r24, Y+1	; 0x01
}
    2436:	0f 90       	pop	r0
    2438:	0f 90       	pop	r0
    243a:	0f 90       	pop	r0
    243c:	cf 91       	pop	r28
    243e:	df 91       	pop	r29
    2440:	08 95       	ret

00002442 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2442:	af 92       	push	r10
    2444:	bf 92       	push	r11
    2446:	cf 92       	push	r12
    2448:	df 92       	push	r13
    244a:	ef 92       	push	r14
    244c:	ff 92       	push	r15
    244e:	0f 93       	push	r16
    2450:	1f 93       	push	r17
    2452:	df 93       	push	r29
    2454:	cf 93       	push	r28
    2456:	cd b7       	in	r28, 0x3d	; 61
    2458:	de b7       	in	r29, 0x3e	; 62
    245a:	64 97       	sbiw	r28, 0x14	; 20
    245c:	0f b6       	in	r0, 0x3f	; 63
    245e:	f8 94       	cli
    2460:	de bf       	out	0x3e, r29	; 62
    2462:	0f be       	out	0x3f, r0	; 63
    2464:	cd bf       	out	0x3d, r28	; 61
    2466:	9f 83       	std	Y+7, r25	; 0x07
    2468:	8e 83       	std	Y+6, r24	; 0x06
    246a:	79 87       	std	Y+9, r23	; 0x09
    246c:	68 87       	std	Y+8, r22	; 0x08
    246e:	5b 87       	std	Y+11, r21	; 0x0b
    2470:	4a 87       	std	Y+10, r20	; 0x0a
    2472:	3d 87       	std	Y+13, r19	; 0x0d
    2474:	2c 87       	std	Y+12, r18	; 0x0c
    2476:	0e 87       	std	Y+14, r16	; 0x0e
    2478:	f8 8a       	std	Y+16, r15	; 0x10
    247a:	ef 86       	std	Y+15, r14	; 0x0f
    247c:	da 8a       	std	Y+18, r13	; 0x12
    247e:	c9 8a       	std	Y+17, r12	; 0x11
    2480:	bc 8a       	std	Y+20, r11	; 0x14
    2482:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    2484:	8a 85       	ldd	r24, Y+10	; 0x0a
    2486:	9b 85       	ldd	r25, Y+11	; 0x0b
    2488:	29 89       	ldd	r18, Y+17	; 0x11
    248a:	3a 89       	ldd	r19, Y+18	; 0x12
    248c:	b9 01       	movw	r22, r18
    248e:	0e 94 a6 18 	call	0x314c	; 0x314c <prvAllocateTCBAndStack>
    2492:	9c 83       	std	Y+4, r25	; 0x04
    2494:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    2496:	8b 81       	ldd	r24, Y+3	; 0x03
    2498:	9c 81       	ldd	r25, Y+4	; 0x04
    249a:	00 97       	sbiw	r24, 0x00	; 0
    249c:	09 f4       	brne	.+2      	; 0x24a0 <xTaskGenericCreate+0x5e>
    249e:	99 c0       	rjmp	.+306    	; 0x25d2 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    24a0:	eb 81       	ldd	r30, Y+3	; 0x03
    24a2:	fc 81       	ldd	r31, Y+4	; 0x04
    24a4:	27 89       	ldd	r18, Z+23	; 0x17
    24a6:	30 8d       	ldd	r19, Z+24	; 0x18
    24a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    24aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    24ac:	01 97       	sbiw	r24, 0x01	; 1
    24ae:	82 0f       	add	r24, r18
    24b0:	93 1f       	adc	r25, r19
    24b2:	9a 83       	std	Y+2, r25	; 0x02
    24b4:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    24b6:	8b 81       	ldd	r24, Y+3	; 0x03
    24b8:	9c 81       	ldd	r25, Y+4	; 0x04
    24ba:	28 85       	ldd	r18, Y+8	; 0x08
    24bc:	39 85       	ldd	r19, Y+9	; 0x09
    24be:	eb 89       	ldd	r30, Y+19	; 0x13
    24c0:	fc 89       	ldd	r31, Y+20	; 0x14
    24c2:	aa 85       	ldd	r26, Y+10	; 0x0a
    24c4:	bb 85       	ldd	r27, Y+11	; 0x0b
    24c6:	b9 01       	movw	r22, r18
    24c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    24ca:	9f 01       	movw	r18, r30
    24cc:	8d 01       	movw	r16, r26
    24ce:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    24d2:	89 81       	ldd	r24, Y+1	; 0x01
    24d4:	9a 81       	ldd	r25, Y+2	; 0x02
    24d6:	2e 81       	ldd	r18, Y+6	; 0x06
    24d8:	3f 81       	ldd	r19, Y+7	; 0x07
    24da:	4c 85       	ldd	r20, Y+12	; 0x0c
    24dc:	5d 85       	ldd	r21, Y+13	; 0x0d
    24de:	b9 01       	movw	r22, r18
    24e0:	0e 94 ce 0a 	call	0x159c	; 0x159c <pxPortInitialiseStack>
    24e4:	eb 81       	ldd	r30, Y+3	; 0x03
    24e6:	fc 81       	ldd	r31, Y+4	; 0x04
    24e8:	91 83       	std	Z+1, r25	; 0x01
    24ea:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    24ec:	8f 85       	ldd	r24, Y+15	; 0x0f
    24ee:	98 89       	ldd	r25, Y+16	; 0x10
    24f0:	00 97       	sbiw	r24, 0x00	; 0
    24f2:	31 f0       	breq	.+12     	; 0x2500 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    24f4:	ef 85       	ldd	r30, Y+15	; 0x0f
    24f6:	f8 89       	ldd	r31, Y+16	; 0x10
    24f8:	8b 81       	ldd	r24, Y+3	; 0x03
    24fa:	9c 81       	ldd	r25, Y+4	; 0x04
    24fc:	91 83       	std	Z+1, r25	; 0x01
    24fe:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2500:	0f b6       	in	r0, 0x3f	; 63
    2502:	f8 94       	cli
    2504:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2506:	80 91 f9 02 	lds	r24, 0x02F9
    250a:	8f 5f       	subi	r24, 0xFF	; 255
    250c:	80 93 f9 02 	sts	0x02F9, r24
			if( pxCurrentTCB == NULL )
    2510:	80 91 f6 02 	lds	r24, 0x02F6
    2514:	90 91 f7 02 	lds	r25, 0x02F7
    2518:	00 97       	sbiw	r24, 0x00	; 0
    251a:	69 f4       	brne	.+26     	; 0x2536 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    251c:	8b 81       	ldd	r24, Y+3	; 0x03
    251e:	9c 81       	ldd	r25, Y+4	; 0x04
    2520:	90 93 f7 02 	sts	0x02F7, r25
    2524:	80 93 f6 02 	sts	0x02F6, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2528:	80 91 f9 02 	lds	r24, 0x02F9
    252c:	81 30       	cpi	r24, 0x01	; 1
    252e:	a9 f4       	brne	.+42     	; 0x255a <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2530:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <prvInitialiseTaskLists>
    2534:	12 c0       	rjmp	.+36     	; 0x255a <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2536:	80 91 fe 02 	lds	r24, 0x02FE
    253a:	88 23       	and	r24, r24
    253c:	71 f4       	brne	.+28     	; 0x255a <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    253e:	e0 91 f6 02 	lds	r30, 0x02F6
    2542:	f0 91 f7 02 	lds	r31, 0x02F7
    2546:	96 89       	ldd	r25, Z+22	; 0x16
    2548:	8e 85       	ldd	r24, Y+14	; 0x0e
    254a:	89 17       	cp	r24, r25
    254c:	30 f0       	brcs	.+12     	; 0x255a <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    254e:	8b 81       	ldd	r24, Y+3	; 0x03
    2550:	9c 81       	ldd	r25, Y+4	; 0x04
    2552:	90 93 f7 02 	sts	0x02F7, r25
    2556:	80 93 f6 02 	sts	0x02F6, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    255a:	eb 81       	ldd	r30, Y+3	; 0x03
    255c:	fc 81       	ldd	r31, Y+4	; 0x04
    255e:	96 89       	ldd	r25, Z+22	; 0x16
    2560:	80 91 fc 02 	lds	r24, 0x02FC
    2564:	89 17       	cp	r24, r25
    2566:	28 f4       	brcc	.+10     	; 0x2572 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2568:	eb 81       	ldd	r30, Y+3	; 0x03
    256a:	fc 81       	ldd	r31, Y+4	; 0x04
    256c:	86 89       	ldd	r24, Z+22	; 0x16
    256e:	80 93 fc 02 	sts	0x02FC, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2572:	80 91 03 03 	lds	r24, 0x0303
    2576:	8f 5f       	subi	r24, 0xFF	; 255
    2578:	80 93 03 03 	sts	0x0303, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    257c:	eb 81       	ldd	r30, Y+3	; 0x03
    257e:	fc 81       	ldd	r31, Y+4	; 0x04
    2580:	96 89       	ldd	r25, Z+22	; 0x16
    2582:	80 91 fd 02 	lds	r24, 0x02FD
    2586:	89 17       	cp	r24, r25
    2588:	28 f4       	brcc	.+10     	; 0x2594 <xTaskGenericCreate+0x152>
    258a:	eb 81       	ldd	r30, Y+3	; 0x03
    258c:	fc 81       	ldd	r31, Y+4	; 0x04
    258e:	86 89       	ldd	r24, Z+22	; 0x16
    2590:	80 93 fd 02 	sts	0x02FD, r24
    2594:	eb 81       	ldd	r30, Y+3	; 0x03
    2596:	fc 81       	ldd	r31, Y+4	; 0x04
    2598:	86 89       	ldd	r24, Z+22	; 0x16
    259a:	28 2f       	mov	r18, r24
    259c:	30 e0       	ldi	r19, 0x00	; 0
    259e:	c9 01       	movw	r24, r18
    25a0:	88 0f       	add	r24, r24
    25a2:	99 1f       	adc	r25, r25
    25a4:	88 0f       	add	r24, r24
    25a6:	99 1f       	adc	r25, r25
    25a8:	88 0f       	add	r24, r24
    25aa:	99 1f       	adc	r25, r25
    25ac:	82 0f       	add	r24, r18
    25ae:	93 1f       	adc	r25, r19
    25b0:	ac 01       	movw	r20, r24
    25b2:	4c 5f       	subi	r20, 0xFC	; 252
    25b4:	5c 4f       	sbci	r21, 0xFC	; 252
    25b6:	8b 81       	ldd	r24, Y+3	; 0x03
    25b8:	9c 81       	ldd	r25, Y+4	; 0x04
    25ba:	9c 01       	movw	r18, r24
    25bc:	2e 5f       	subi	r18, 0xFE	; 254
    25be:	3f 4f       	sbci	r19, 0xFF	; 255
    25c0:	ca 01       	movw	r24, r20
    25c2:	b9 01       	movw	r22, r18
    25c4:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>

			xReturn = pdPASS;
    25c8:	81 e0       	ldi	r24, 0x01	; 1
    25ca:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    25cc:	0f 90       	pop	r0
    25ce:	0f be       	out	0x3f, r0	; 63
    25d0:	02 c0       	rjmp	.+4      	; 0x25d6 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    25d2:	8f ef       	ldi	r24, 0xFF	; 255
    25d4:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    25d6:	8d 81       	ldd	r24, Y+5	; 0x05
    25d8:	81 30       	cpi	r24, 0x01	; 1
    25da:	71 f4       	brne	.+28     	; 0x25f8 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    25dc:	80 91 fe 02 	lds	r24, 0x02FE
    25e0:	88 23       	and	r24, r24
    25e2:	51 f0       	breq	.+20     	; 0x25f8 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    25e4:	e0 91 f6 02 	lds	r30, 0x02F6
    25e8:	f0 91 f7 02 	lds	r31, 0x02F7
    25ec:	96 89       	ldd	r25, Z+22	; 0x16
    25ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    25f0:	98 17       	cp	r25, r24
    25f2:	10 f4       	brcc	.+4      	; 0x25f8 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    25f4:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
			}
		}
	}

	return xReturn;
    25f8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    25fa:	64 96       	adiw	r28, 0x14	; 20
    25fc:	0f b6       	in	r0, 0x3f	; 63
    25fe:	f8 94       	cli
    2600:	de bf       	out	0x3e, r29	; 62
    2602:	0f be       	out	0x3f, r0	; 63
    2604:	cd bf       	out	0x3d, r28	; 61
    2606:	cf 91       	pop	r28
    2608:	df 91       	pop	r29
    260a:	1f 91       	pop	r17
    260c:	0f 91       	pop	r16
    260e:	ff 90       	pop	r15
    2610:	ef 90       	pop	r14
    2612:	df 90       	pop	r13
    2614:	cf 90       	pop	r12
    2616:	bf 90       	pop	r11
    2618:	af 90       	pop	r10
    261a:	08 95       	ret

0000261c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    261c:	df 93       	push	r29
    261e:	cf 93       	push	r28
    2620:	00 d0       	rcall	.+0      	; 0x2622 <vTaskDelete+0x6>
    2622:	00 d0       	rcall	.+0      	; 0x2624 <vTaskDelete+0x8>
    2624:	00 d0       	rcall	.+0      	; 0x2626 <vTaskDelete+0xa>
    2626:	cd b7       	in	r28, 0x3d	; 61
    2628:	de b7       	in	r29, 0x3e	; 62
    262a:	9c 83       	std	Y+4, r25	; 0x04
    262c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2634:	20 91 f6 02 	lds	r18, 0x02F6
    2638:	30 91 f7 02 	lds	r19, 0x02F7
    263c:	8b 81       	ldd	r24, Y+3	; 0x03
    263e:	9c 81       	ldd	r25, Y+4	; 0x04
    2640:	82 17       	cp	r24, r18
    2642:	93 07       	cpc	r25, r19
    2644:	11 f4       	brne	.+4      	; 0x264a <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2646:	1c 82       	std	Y+4, r1	; 0x04
    2648:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    264a:	8b 81       	ldd	r24, Y+3	; 0x03
    264c:	9c 81       	ldd	r25, Y+4	; 0x04
    264e:	00 97       	sbiw	r24, 0x00	; 0
    2650:	39 f4       	brne	.+14     	; 0x2660 <vTaskDelete+0x44>
    2652:	80 91 f6 02 	lds	r24, 0x02F6
    2656:	90 91 f7 02 	lds	r25, 0x02F7
    265a:	9e 83       	std	Y+6, r25	; 0x06
    265c:	8d 83       	std	Y+5, r24	; 0x05
    265e:	04 c0       	rjmp	.+8      	; 0x2668 <vTaskDelete+0x4c>
    2660:	8b 81       	ldd	r24, Y+3	; 0x03
    2662:	9c 81       	ldd	r25, Y+4	; 0x04
    2664:	9e 83       	std	Y+6, r25	; 0x06
    2666:	8d 83       	std	Y+5, r24	; 0x05
    2668:	8d 81       	ldd	r24, Y+5	; 0x05
    266a:	9e 81       	ldd	r25, Y+6	; 0x06
    266c:	9a 83       	std	Y+2, r25	; 0x02
    266e:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2670:	89 81       	ldd	r24, Y+1	; 0x01
    2672:	9a 81       	ldd	r25, Y+2	; 0x02
    2674:	02 96       	adiw	r24, 0x02	; 2
    2676:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    267a:	e9 81       	ldd	r30, Y+1	; 0x01
    267c:	fa 81       	ldd	r31, Y+2	; 0x02
    267e:	84 89       	ldd	r24, Z+20	; 0x14
    2680:	95 89       	ldd	r25, Z+21	; 0x15
    2682:	00 97       	sbiw	r24, 0x00	; 0
    2684:	29 f0       	breq	.+10     	; 0x2690 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	9a 81       	ldd	r25, Y+2	; 0x02
    268a:	0c 96       	adiw	r24, 0x0c	; 12
    268c:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2690:	89 81       	ldd	r24, Y+1	; 0x01
    2692:	9a 81       	ldd	r25, Y+2	; 0x02
    2694:	9c 01       	movw	r18, r24
    2696:	2e 5f       	subi	r18, 0xFE	; 254
    2698:	3f 4f       	sbci	r19, 0xFF	; 255
    269a:	85 e3       	ldi	r24, 0x35	; 53
    269c:	93 e0       	ldi	r25, 0x03	; 3
    269e:	b9 01       	movw	r22, r18
    26a0:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    26a4:	80 91 f8 02 	lds	r24, 0x02F8
    26a8:	8f 5f       	subi	r24, 0xFF	; 255
    26aa:	80 93 f8 02 	sts	0x02F8, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    26ae:	80 91 03 03 	lds	r24, 0x0303
    26b2:	8f 5f       	subi	r24, 0xFF	; 255
    26b4:	80 93 03 03 	sts	0x0303, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    26b8:	0f 90       	pop	r0
    26ba:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    26bc:	80 91 fe 02 	lds	r24, 0x02FE
    26c0:	88 23       	and	r24, r24
    26c2:	31 f0       	breq	.+12     	; 0x26d0 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    26c4:	8b 81       	ldd	r24, Y+3	; 0x03
    26c6:	9c 81       	ldd	r25, Y+4	; 0x04
    26c8:	00 97       	sbiw	r24, 0x00	; 0
    26ca:	11 f4       	brne	.+4      	; 0x26d0 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    26cc:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
			}
		}
	}
    26d0:	26 96       	adiw	r28, 0x06	; 6
    26d2:	0f b6       	in	r0, 0x3f	; 63
    26d4:	f8 94       	cli
    26d6:	de bf       	out	0x3e, r29	; 62
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	cd bf       	out	0x3d, r28	; 61
    26dc:	cf 91       	pop	r28
    26de:	df 91       	pop	r29
    26e0:	08 95       	ret

000026e2 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    26e2:	df 93       	push	r29
    26e4:	cf 93       	push	r28
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	28 97       	sbiw	r28, 0x08	; 8
    26ec:	0f b6       	in	r0, 0x3f	; 63
    26ee:	f8 94       	cli
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	0f be       	out	0x3f, r0	; 63
    26f4:	cd bf       	out	0x3d, r28	; 61
    26f6:	9e 83       	std	Y+6, r25	; 0x06
    26f8:	8d 83       	std	Y+5, r24	; 0x05
    26fa:	78 87       	std	Y+8, r23	; 0x08
    26fc:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    26fe:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2700:	0e 94 5d 14 	call	0x28ba	; 0x28ba <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2704:	ed 81       	ldd	r30, Y+5	; 0x05
    2706:	fe 81       	ldd	r31, Y+6	; 0x06
    2708:	20 81       	ld	r18, Z
    270a:	31 81       	ldd	r19, Z+1	; 0x01
    270c:	8f 81       	ldd	r24, Y+7	; 0x07
    270e:	98 85       	ldd	r25, Y+8	; 0x08
    2710:	82 0f       	add	r24, r18
    2712:	93 1f       	adc	r25, r19
    2714:	9c 83       	std	Y+4, r25	; 0x04
    2716:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2718:	ed 81       	ldd	r30, Y+5	; 0x05
    271a:	fe 81       	ldd	r31, Y+6	; 0x06
    271c:	20 81       	ld	r18, Z
    271e:	31 81       	ldd	r19, Z+1	; 0x01
    2720:	80 91 fa 02 	lds	r24, 0x02FA
    2724:	90 91 fb 02 	lds	r25, 0x02FB
    2728:	82 17       	cp	r24, r18
    272a:	93 07       	cpc	r25, r19
    272c:	a8 f4       	brcc	.+42     	; 0x2758 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    272e:	ed 81       	ldd	r30, Y+5	; 0x05
    2730:	fe 81       	ldd	r31, Y+6	; 0x06
    2732:	20 81       	ld	r18, Z
    2734:	31 81       	ldd	r19, Z+1	; 0x01
    2736:	8b 81       	ldd	r24, Y+3	; 0x03
    2738:	9c 81       	ldd	r25, Y+4	; 0x04
    273a:	82 17       	cp	r24, r18
    273c:	93 07       	cpc	r25, r19
    273e:	00 f5       	brcc	.+64     	; 0x2780 <vTaskDelayUntil+0x9e>
    2740:	20 91 fa 02 	lds	r18, 0x02FA
    2744:	30 91 fb 02 	lds	r19, 0x02FB
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
    274a:	9c 81       	ldd	r25, Y+4	; 0x04
    274c:	28 17       	cp	r18, r24
    274e:	39 07       	cpc	r19, r25
    2750:	b8 f4       	brcc	.+46     	; 0x2780 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2752:	81 e0       	ldi	r24, 0x01	; 1
    2754:	89 83       	std	Y+1, r24	; 0x01
    2756:	14 c0       	rjmp	.+40     	; 0x2780 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2758:	ed 81       	ldd	r30, Y+5	; 0x05
    275a:	fe 81       	ldd	r31, Y+6	; 0x06
    275c:	20 81       	ld	r18, Z
    275e:	31 81       	ldd	r19, Z+1	; 0x01
    2760:	8b 81       	ldd	r24, Y+3	; 0x03
    2762:	9c 81       	ldd	r25, Y+4	; 0x04
    2764:	82 17       	cp	r24, r18
    2766:	93 07       	cpc	r25, r19
    2768:	48 f0       	brcs	.+18     	; 0x277c <vTaskDelayUntil+0x9a>
    276a:	20 91 fa 02 	lds	r18, 0x02FA
    276e:	30 91 fb 02 	lds	r19, 0x02FB
    2772:	8b 81       	ldd	r24, Y+3	; 0x03
    2774:	9c 81       	ldd	r25, Y+4	; 0x04
    2776:	28 17       	cp	r18, r24
    2778:	39 07       	cpc	r19, r25
    277a:	10 f4       	brcc	.+4      	; 0x2780 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    277c:	81 e0       	ldi	r24, 0x01	; 1
    277e:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2780:	ed 81       	ldd	r30, Y+5	; 0x05
    2782:	fe 81       	ldd	r31, Y+6	; 0x06
    2784:	8b 81       	ldd	r24, Y+3	; 0x03
    2786:	9c 81       	ldd	r25, Y+4	; 0x04
    2788:	91 83       	std	Z+1, r25	; 0x01
    278a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    278c:	89 81       	ldd	r24, Y+1	; 0x01
    278e:	88 23       	and	r24, r24
    2790:	59 f0       	breq	.+22     	; 0x27a8 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2792:	80 91 f6 02 	lds	r24, 0x02F6
    2796:	90 91 f7 02 	lds	r25, 0x02F7
    279a:	02 96       	adiw	r24, 0x02	; 2
    279c:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    27a0:	8b 81       	ldd	r24, Y+3	; 0x03
    27a2:	9c 81       	ldd	r25, Y+4	; 0x04
    27a4:	0e 94 5d 18 	call	0x30ba	; 0x30ba <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    27a8:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
    27ac:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    27ae:	8a 81       	ldd	r24, Y+2	; 0x02
    27b0:	88 23       	and	r24, r24
    27b2:	11 f4       	brne	.+4      	; 0x27b8 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    27b4:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
		}
	}
    27b8:	28 96       	adiw	r28, 0x08	; 8
    27ba:	0f b6       	in	r0, 0x3f	; 63
    27bc:	f8 94       	cli
    27be:	de bf       	out	0x3e, r29	; 62
    27c0:	0f be       	out	0x3f, r0	; 63
    27c2:	cd bf       	out	0x3d, r28	; 61
    27c4:	cf 91       	pop	r28
    27c6:	df 91       	pop	r29
    27c8:	08 95       	ret

000027ca <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    27ca:	df 93       	push	r29
    27cc:	cf 93       	push	r28
    27ce:	00 d0       	rcall	.+0      	; 0x27d0 <vTaskDelay+0x6>
    27d0:	00 d0       	rcall	.+0      	; 0x27d2 <vTaskDelay+0x8>
    27d2:	0f 92       	push	r0
    27d4:	cd b7       	in	r28, 0x3d	; 61
    27d6:	de b7       	in	r29, 0x3e	; 62
    27d8:	9d 83       	std	Y+5, r25	; 0x05
    27da:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    27dc:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    27de:	8c 81       	ldd	r24, Y+4	; 0x04
    27e0:	9d 81       	ldd	r25, Y+5	; 0x05
    27e2:	00 97       	sbiw	r24, 0x00	; 0
    27e4:	d1 f0       	breq	.+52     	; 0x281a <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    27e6:	0e 94 5d 14 	call	0x28ba	; 0x28ba <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    27ea:	20 91 fa 02 	lds	r18, 0x02FA
    27ee:	30 91 fb 02 	lds	r19, 0x02FB
    27f2:	8c 81       	ldd	r24, Y+4	; 0x04
    27f4:	9d 81       	ldd	r25, Y+5	; 0x05
    27f6:	82 0f       	add	r24, r18
    27f8:	93 1f       	adc	r25, r19
    27fa:	9b 83       	std	Y+3, r25	; 0x03
    27fc:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27fe:	80 91 f6 02 	lds	r24, 0x02F6
    2802:	90 91 f7 02 	lds	r25, 0x02F7
    2806:	02 96       	adiw	r24, 0x02	; 2
    2808:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    280c:	8a 81       	ldd	r24, Y+2	; 0x02
    280e:	9b 81       	ldd	r25, Y+3	; 0x03
    2810:	0e 94 5d 18 	call	0x30ba	; 0x30ba <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2814:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>
    2818:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    281a:	89 81       	ldd	r24, Y+1	; 0x01
    281c:	88 23       	and	r24, r24
    281e:	11 f4       	brne	.+4      	; 0x2824 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2820:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
		}
	}
    2824:	0f 90       	pop	r0
    2826:	0f 90       	pop	r0
    2828:	0f 90       	pop	r0
    282a:	0f 90       	pop	r0
    282c:	0f 90       	pop	r0
    282e:	cf 91       	pop	r28
    2830:	df 91       	pop	r29
    2832:	08 95       	ret

00002834 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2834:	af 92       	push	r10
    2836:	bf 92       	push	r11
    2838:	cf 92       	push	r12
    283a:	df 92       	push	r13
    283c:	ef 92       	push	r14
    283e:	ff 92       	push	r15
    2840:	0f 93       	push	r16
    2842:	df 93       	push	r29
    2844:	cf 93       	push	r28
    2846:	0f 92       	push	r0
    2848:	cd b7       	in	r28, 0x3d	; 61
    284a:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    284c:	20 e6       	ldi	r18, 0x60	; 96
    284e:	30 e0       	ldi	r19, 0x00	; 0
    2850:	81 e8       	ldi	r24, 0x81	; 129
    2852:	97 e1       	ldi	r25, 0x17	; 23
    2854:	b9 01       	movw	r22, r18
    2856:	44 e6       	ldi	r20, 0x64	; 100
    2858:	50 e0       	ldi	r21, 0x00	; 0
    285a:	20 e0       	ldi	r18, 0x00	; 0
    285c:	30 e0       	ldi	r19, 0x00	; 0
    285e:	00 e0       	ldi	r16, 0x00	; 0
    2860:	ee 24       	eor	r14, r14
    2862:	ff 24       	eor	r15, r15
    2864:	cc 24       	eor	r12, r12
    2866:	dd 24       	eor	r13, r13
    2868:	aa 24       	eor	r10, r10
    286a:	bb 24       	eor	r11, r11
    286c:	0e 94 21 12 	call	0x2442	; 0x2442 <xTaskGenericCreate>
    2870:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2872:	89 81       	ldd	r24, Y+1	; 0x01
    2874:	81 30       	cpi	r24, 0x01	; 1
    2876:	51 f4       	brne	.+20     	; 0x288c <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2878:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	80 93 fe 02 	sts	0x02FE, r24
		xTickCount = ( portTickType ) 0U;
    2880:	10 92 fb 02 	sts	0x02FB, r1
    2884:	10 92 fa 02 	sts	0x02FA, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2888:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    288c:	0f 90       	pop	r0
    288e:	cf 91       	pop	r28
    2890:	df 91       	pop	r29
    2892:	0f 91       	pop	r16
    2894:	ff 90       	pop	r15
    2896:	ef 90       	pop	r14
    2898:	df 90       	pop	r13
    289a:	cf 90       	pop	r12
    289c:	bf 90       	pop	r11
    289e:	af 90       	pop	r10
    28a0:	08 95       	ret

000028a2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    28a2:	df 93       	push	r29
    28a4:	cf 93       	push	r28
    28a6:	cd b7       	in	r28, 0x3d	; 61
    28a8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    28aa:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    28ac:	10 92 fe 02 	sts	0x02FE, r1
	vPortEndScheduler();
    28b0:	0e 94 86 0c 	call	0x190c	; 0x190c <vPortEndScheduler>
}
    28b4:	cf 91       	pop	r28
    28b6:	df 91       	pop	r29
    28b8:	08 95       	ret

000028ba <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    28ba:	df 93       	push	r29
    28bc:	cf 93       	push	r28
    28be:	cd b7       	in	r28, 0x3d	; 61
    28c0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    28c2:	80 91 ff 02 	lds	r24, 0x02FF
    28c6:	8f 5f       	subi	r24, 0xFF	; 255
    28c8:	80 93 ff 02 	sts	0x02FF, r24
}
    28cc:	cf 91       	pop	r28
    28ce:	df 91       	pop	r29
    28d0:	08 95       	ret

000028d2 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    28d2:	df 93       	push	r29
    28d4:	cf 93       	push	r28
    28d6:	00 d0       	rcall	.+0      	; 0x28d8 <xTaskResumeAll+0x6>
    28d8:	00 d0       	rcall	.+0      	; 0x28da <xTaskResumeAll+0x8>
    28da:	cd b7       	in	r28, 0x3d	; 61
    28dc:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    28de:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	f8 94       	cli
    28e4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    28e6:	80 91 ff 02 	lds	r24, 0x02FF
    28ea:	81 50       	subi	r24, 0x01	; 1
    28ec:	80 93 ff 02 	sts	0x02FF, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    28f0:	80 91 ff 02 	lds	r24, 0x02FF
    28f4:	88 23       	and	r24, r24
    28f6:	09 f0       	breq	.+2      	; 0x28fa <xTaskResumeAll+0x28>
    28f8:	6c c0       	rjmp	.+216    	; 0x29d2 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    28fa:	80 91 f9 02 	lds	r24, 0x02F9
    28fe:	88 23       	and	r24, r24
    2900:	09 f4       	brne	.+2      	; 0x2904 <xTaskResumeAll+0x32>
    2902:	67 c0       	rjmp	.+206    	; 0x29d2 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2904:	19 82       	std	Y+1, r1	; 0x01
    2906:	41 c0       	rjmp	.+130    	; 0x298a <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2908:	e0 91 31 03 	lds	r30, 0x0331
    290c:	f0 91 32 03 	lds	r31, 0x0332
    2910:	86 81       	ldd	r24, Z+6	; 0x06
    2912:	97 81       	ldd	r25, Z+7	; 0x07
    2914:	9c 83       	std	Y+4, r25	; 0x04
    2916:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2918:	8b 81       	ldd	r24, Y+3	; 0x03
    291a:	9c 81       	ldd	r25, Y+4	; 0x04
    291c:	0c 96       	adiw	r24, 0x0c	; 12
    291e:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2922:	8b 81       	ldd	r24, Y+3	; 0x03
    2924:	9c 81       	ldd	r25, Y+4	; 0x04
    2926:	02 96       	adiw	r24, 0x02	; 2
    2928:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    292c:	eb 81       	ldd	r30, Y+3	; 0x03
    292e:	fc 81       	ldd	r31, Y+4	; 0x04
    2930:	96 89       	ldd	r25, Z+22	; 0x16
    2932:	80 91 fd 02 	lds	r24, 0x02FD
    2936:	89 17       	cp	r24, r25
    2938:	28 f4       	brcc	.+10     	; 0x2944 <xTaskResumeAll+0x72>
    293a:	eb 81       	ldd	r30, Y+3	; 0x03
    293c:	fc 81       	ldd	r31, Y+4	; 0x04
    293e:	86 89       	ldd	r24, Z+22	; 0x16
    2940:	80 93 fd 02 	sts	0x02FD, r24
    2944:	eb 81       	ldd	r30, Y+3	; 0x03
    2946:	fc 81       	ldd	r31, Y+4	; 0x04
    2948:	86 89       	ldd	r24, Z+22	; 0x16
    294a:	28 2f       	mov	r18, r24
    294c:	30 e0       	ldi	r19, 0x00	; 0
    294e:	c9 01       	movw	r24, r18
    2950:	88 0f       	add	r24, r24
    2952:	99 1f       	adc	r25, r25
    2954:	88 0f       	add	r24, r24
    2956:	99 1f       	adc	r25, r25
    2958:	88 0f       	add	r24, r24
    295a:	99 1f       	adc	r25, r25
    295c:	82 0f       	add	r24, r18
    295e:	93 1f       	adc	r25, r19
    2960:	8c 5f       	subi	r24, 0xFC	; 252
    2962:	9c 4f       	sbci	r25, 0xFC	; 252
    2964:	2b 81       	ldd	r18, Y+3	; 0x03
    2966:	3c 81       	ldd	r19, Y+4	; 0x04
    2968:	2e 5f       	subi	r18, 0xFE	; 254
    296a:	3f 4f       	sbci	r19, 0xFF	; 255
    296c:	b9 01       	movw	r22, r18
    296e:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2972:	eb 81       	ldd	r30, Y+3	; 0x03
    2974:	fc 81       	ldd	r31, Y+4	; 0x04
    2976:	96 89       	ldd	r25, Z+22	; 0x16
    2978:	e0 91 f6 02 	lds	r30, 0x02F6
    297c:	f0 91 f7 02 	lds	r31, 0x02F7
    2980:	86 89       	ldd	r24, Z+22	; 0x16
    2982:	98 17       	cp	r25, r24
    2984:	10 f0       	brcs	.+4      	; 0x298a <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2986:	81 e0       	ldi	r24, 0x01	; 1
    2988:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    298a:	80 91 2c 03 	lds	r24, 0x032C
    298e:	88 23       	and	r24, r24
    2990:	09 f0       	breq	.+2      	; 0x2994 <xTaskResumeAll+0xc2>
    2992:	ba cf       	rjmp	.-140    	; 0x2908 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2994:	80 91 00 03 	lds	r24, 0x0300
    2998:	88 23       	and	r24, r24
    299a:	71 f0       	breq	.+28     	; 0x29b8 <xTaskResumeAll+0xe6>
    299c:	07 c0       	rjmp	.+14     	; 0x29ac <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    299e:	0e 94 28 15 	call	0x2a50	; 0x2a50 <vTaskIncrementTick>
						--uxMissedTicks;
    29a2:	80 91 00 03 	lds	r24, 0x0300
    29a6:	81 50       	subi	r24, 0x01	; 1
    29a8:	80 93 00 03 	sts	0x0300, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29ac:	80 91 00 03 	lds	r24, 0x0300
    29b0:	88 23       	and	r24, r24
    29b2:	a9 f7       	brne	.-22     	; 0x299e <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    29b4:	81 e0       	ldi	r24, 0x01	; 1
    29b6:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    29b8:	89 81       	ldd	r24, Y+1	; 0x01
    29ba:	81 30       	cpi	r24, 0x01	; 1
    29bc:	21 f0       	breq	.+8      	; 0x29c6 <xTaskResumeAll+0xf4>
    29be:	80 91 01 03 	lds	r24, 0x0301
    29c2:	81 30       	cpi	r24, 0x01	; 1
    29c4:	31 f4       	brne	.+12     	; 0x29d2 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    29c6:	81 e0       	ldi	r24, 0x01	; 1
    29c8:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    29ca:	10 92 01 03 	sts	0x0301, r1
					portYIELD_WITHIN_API();
    29ce:	0e 94 8d 0c 	call	0x191a	; 0x191a <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    29d2:	0f 90       	pop	r0
    29d4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    29d6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    29d8:	0f 90       	pop	r0
    29da:	0f 90       	pop	r0
    29dc:	0f 90       	pop	r0
    29de:	0f 90       	pop	r0
    29e0:	cf 91       	pop	r28
    29e2:	df 91       	pop	r29
    29e4:	08 95       	ret

000029e6 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    29e6:	df 93       	push	r29
    29e8:	cf 93       	push	r28
    29ea:	00 d0       	rcall	.+0      	; 0x29ec <xTaskGetTickCount+0x6>
    29ec:	cd b7       	in	r28, 0x3d	; 61
    29ee:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    29f6:	80 91 fa 02 	lds	r24, 0x02FA
    29fa:	90 91 fb 02 	lds	r25, 0x02FB
    29fe:	9a 83       	std	Y+2, r25	; 0x02
    2a00:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2a02:	0f 90       	pop	r0
    2a04:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
    2a08:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a0a:	0f 90       	pop	r0
    2a0c:	0f 90       	pop	r0
    2a0e:	cf 91       	pop	r28
    2a10:	df 91       	pop	r29
    2a12:	08 95       	ret

00002a14 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2a14:	df 93       	push	r29
    2a16:	cf 93       	push	r28
    2a18:	00 d0       	rcall	.+0      	; 0x2a1a <xTaskGetTickCountFromISR+0x6>
    2a1a:	0f 92       	push	r0
    2a1c:	cd b7       	in	r28, 0x3d	; 61
    2a1e:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a20:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2a22:	80 91 fa 02 	lds	r24, 0x02FA
    2a26:	90 91 fb 02 	lds	r25, 0x02FB
    2a2a:	9b 83       	std	Y+3, r25	; 0x03
    2a2c:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a30:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2a32:	0f 90       	pop	r0
    2a34:	0f 90       	pop	r0
    2a36:	0f 90       	pop	r0
    2a38:	cf 91       	pop	r28
    2a3a:	df 91       	pop	r29
    2a3c:	08 95       	ret

00002a3e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2a3e:	df 93       	push	r29
    2a40:	cf 93       	push	r28
    2a42:	cd b7       	in	r28, 0x3d	; 61
    2a44:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2a46:	80 91 f9 02 	lds	r24, 0x02F9
}
    2a4a:	cf 91       	pop	r28
    2a4c:	df 91       	pop	r29
    2a4e:	08 95       	ret

00002a50 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2a50:	df 93       	push	r29
    2a52:	cf 93       	push	r28
    2a54:	00 d0       	rcall	.+0      	; 0x2a56 <vTaskIncrementTick+0x6>
    2a56:	00 d0       	rcall	.+0      	; 0x2a58 <vTaskIncrementTick+0x8>
    2a58:	00 d0       	rcall	.+0      	; 0x2a5a <vTaskIncrementTick+0xa>
    2a5a:	cd b7       	in	r28, 0x3d	; 61
    2a5c:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2a5e:	80 91 ff 02 	lds	r24, 0x02FF
    2a62:	88 23       	and	r24, r24
    2a64:	09 f0       	breq	.+2      	; 0x2a68 <vTaskIncrementTick+0x18>
    2a66:	bb c0       	rjmp	.+374    	; 0x2bde <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2a68:	80 91 fa 02 	lds	r24, 0x02FA
    2a6c:	90 91 fb 02 	lds	r25, 0x02FB
    2a70:	01 96       	adiw	r24, 0x01	; 1
    2a72:	90 93 fb 02 	sts	0x02FB, r25
    2a76:	80 93 fa 02 	sts	0x02FA, r24
		if( xTickCount == ( portTickType ) 0U )
    2a7a:	80 91 fa 02 	lds	r24, 0x02FA
    2a7e:	90 91 fb 02 	lds	r25, 0x02FB
    2a82:	00 97       	sbiw	r24, 0x00	; 0
    2a84:	d1 f5       	brne	.+116    	; 0x2afa <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2a86:	80 91 28 03 	lds	r24, 0x0328
    2a8a:	90 91 29 03 	lds	r25, 0x0329
    2a8e:	9c 83       	std	Y+4, r25	; 0x04
    2a90:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2a92:	80 91 2a 03 	lds	r24, 0x032A
    2a96:	90 91 2b 03 	lds	r25, 0x032B
    2a9a:	90 93 29 03 	sts	0x0329, r25
    2a9e:	80 93 28 03 	sts	0x0328, r24
			pxOverflowDelayedTaskList = pxTemp;
    2aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa6:	90 93 2b 03 	sts	0x032B, r25
    2aaa:	80 93 2a 03 	sts	0x032A, r24
			xNumOfOverflows++;
    2aae:	80 91 02 03 	lds	r24, 0x0302
    2ab2:	8f 5f       	subi	r24, 0xFF	; 255
    2ab4:	80 93 02 03 	sts	0x0302, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2ab8:	e0 91 28 03 	lds	r30, 0x0328
    2abc:	f0 91 29 03 	lds	r31, 0x0329
    2ac0:	80 81       	ld	r24, Z
    2ac2:	88 23       	and	r24, r24
    2ac4:	39 f4       	brne	.+14     	; 0x2ad4 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2ac6:	8f ef       	ldi	r24, 0xFF	; 255
    2ac8:	9f ef       	ldi	r25, 0xFF	; 255
    2aca:	90 93 b4 00 	sts	0x00B4, r25
    2ace:	80 93 b3 00 	sts	0x00B3, r24
    2ad2:	13 c0       	rjmp	.+38     	; 0x2afa <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2ad4:	e0 91 28 03 	lds	r30, 0x0328
    2ad8:	f0 91 29 03 	lds	r31, 0x0329
    2adc:	05 80       	ldd	r0, Z+5	; 0x05
    2ade:	f6 81       	ldd	r31, Z+6	; 0x06
    2ae0:	e0 2d       	mov	r30, r0
    2ae2:	86 81       	ldd	r24, Z+6	; 0x06
    2ae4:	97 81       	ldd	r25, Z+7	; 0x07
    2ae6:	9e 83       	std	Y+6, r25	; 0x06
    2ae8:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2aea:	ed 81       	ldd	r30, Y+5	; 0x05
    2aec:	fe 81       	ldd	r31, Y+6	; 0x06
    2aee:	82 81       	ldd	r24, Z+2	; 0x02
    2af0:	93 81       	ldd	r25, Z+3	; 0x03
    2af2:	90 93 b4 00 	sts	0x00B4, r25
    2af6:	80 93 b3 00 	sts	0x00B3, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2afa:	20 91 fa 02 	lds	r18, 0x02FA
    2afe:	30 91 fb 02 	lds	r19, 0x02FB
    2b02:	80 91 b3 00 	lds	r24, 0x00B3
    2b06:	90 91 b4 00 	lds	r25, 0x00B4
    2b0a:	28 17       	cp	r18, r24
    2b0c:	39 07       	cpc	r19, r25
    2b0e:	08 f4       	brcc	.+2      	; 0x2b12 <vTaskIncrementTick+0xc2>
    2b10:	6b c0       	rjmp	.+214    	; 0x2be8 <vTaskIncrementTick+0x198>
    2b12:	e0 91 28 03 	lds	r30, 0x0328
    2b16:	f0 91 29 03 	lds	r31, 0x0329
    2b1a:	80 81       	ld	r24, Z
    2b1c:	88 23       	and	r24, r24
    2b1e:	39 f4       	brne	.+14     	; 0x2b2e <vTaskIncrementTick+0xde>
    2b20:	8f ef       	ldi	r24, 0xFF	; 255
    2b22:	9f ef       	ldi	r25, 0xFF	; 255
    2b24:	90 93 b4 00 	sts	0x00B4, r25
    2b28:	80 93 b3 00 	sts	0x00B3, r24
    2b2c:	5d c0       	rjmp	.+186    	; 0x2be8 <vTaskIncrementTick+0x198>
    2b2e:	e0 91 28 03 	lds	r30, 0x0328
    2b32:	f0 91 29 03 	lds	r31, 0x0329
    2b36:	05 80       	ldd	r0, Z+5	; 0x05
    2b38:	f6 81       	ldd	r31, Z+6	; 0x06
    2b3a:	e0 2d       	mov	r30, r0
    2b3c:	86 81       	ldd	r24, Z+6	; 0x06
    2b3e:	97 81       	ldd	r25, Z+7	; 0x07
    2b40:	9e 83       	std	Y+6, r25	; 0x06
    2b42:	8d 83       	std	Y+5, r24	; 0x05
    2b44:	ed 81       	ldd	r30, Y+5	; 0x05
    2b46:	fe 81       	ldd	r31, Y+6	; 0x06
    2b48:	82 81       	ldd	r24, Z+2	; 0x02
    2b4a:	93 81       	ldd	r25, Z+3	; 0x03
    2b4c:	9a 83       	std	Y+2, r25	; 0x02
    2b4e:	89 83       	std	Y+1, r24	; 0x01
    2b50:	20 91 fa 02 	lds	r18, 0x02FA
    2b54:	30 91 fb 02 	lds	r19, 0x02FB
    2b58:	89 81       	ldd	r24, Y+1	; 0x01
    2b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b5c:	28 17       	cp	r18, r24
    2b5e:	39 07       	cpc	r19, r25
    2b60:	38 f4       	brcc	.+14     	; 0x2b70 <vTaskIncrementTick+0x120>
    2b62:	89 81       	ldd	r24, Y+1	; 0x01
    2b64:	9a 81       	ldd	r25, Y+2	; 0x02
    2b66:	90 93 b4 00 	sts	0x00B4, r25
    2b6a:	80 93 b3 00 	sts	0x00B3, r24
    2b6e:	3c c0       	rjmp	.+120    	; 0x2be8 <vTaskIncrementTick+0x198>
    2b70:	8d 81       	ldd	r24, Y+5	; 0x05
    2b72:	9e 81       	ldd	r25, Y+6	; 0x06
    2b74:	02 96       	adiw	r24, 0x02	; 2
    2b76:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
    2b7a:	ed 81       	ldd	r30, Y+5	; 0x05
    2b7c:	fe 81       	ldd	r31, Y+6	; 0x06
    2b7e:	84 89       	ldd	r24, Z+20	; 0x14
    2b80:	95 89       	ldd	r25, Z+21	; 0x15
    2b82:	00 97       	sbiw	r24, 0x00	; 0
    2b84:	29 f0       	breq	.+10     	; 0x2b90 <vTaskIncrementTick+0x140>
    2b86:	8d 81       	ldd	r24, Y+5	; 0x05
    2b88:	9e 81       	ldd	r25, Y+6	; 0x06
    2b8a:	0c 96       	adiw	r24, 0x0c	; 12
    2b8c:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
    2b90:	ed 81       	ldd	r30, Y+5	; 0x05
    2b92:	fe 81       	ldd	r31, Y+6	; 0x06
    2b94:	96 89       	ldd	r25, Z+22	; 0x16
    2b96:	80 91 fd 02 	lds	r24, 0x02FD
    2b9a:	89 17       	cp	r24, r25
    2b9c:	28 f4       	brcc	.+10     	; 0x2ba8 <vTaskIncrementTick+0x158>
    2b9e:	ed 81       	ldd	r30, Y+5	; 0x05
    2ba0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ba2:	86 89       	ldd	r24, Z+22	; 0x16
    2ba4:	80 93 fd 02 	sts	0x02FD, r24
    2ba8:	ed 81       	ldd	r30, Y+5	; 0x05
    2baa:	fe 81       	ldd	r31, Y+6	; 0x06
    2bac:	86 89       	ldd	r24, Z+22	; 0x16
    2bae:	28 2f       	mov	r18, r24
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	c9 01       	movw	r24, r18
    2bb4:	88 0f       	add	r24, r24
    2bb6:	99 1f       	adc	r25, r25
    2bb8:	88 0f       	add	r24, r24
    2bba:	99 1f       	adc	r25, r25
    2bbc:	88 0f       	add	r24, r24
    2bbe:	99 1f       	adc	r25, r25
    2bc0:	82 0f       	add	r24, r18
    2bc2:	93 1f       	adc	r25, r19
    2bc4:	ac 01       	movw	r20, r24
    2bc6:	4c 5f       	subi	r20, 0xFC	; 252
    2bc8:	5c 4f       	sbci	r21, 0xFC	; 252
    2bca:	8d 81       	ldd	r24, Y+5	; 0x05
    2bcc:	9e 81       	ldd	r25, Y+6	; 0x06
    2bce:	9c 01       	movw	r18, r24
    2bd0:	2e 5f       	subi	r18, 0xFE	; 254
    2bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd4:	ca 01       	movw	r24, r20
    2bd6:	b9 01       	movw	r22, r18
    2bd8:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>
    2bdc:	9a cf       	rjmp	.-204    	; 0x2b12 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2bde:	80 91 00 03 	lds	r24, 0x0300
    2be2:	8f 5f       	subi	r24, 0xFF	; 255
    2be4:	80 93 00 03 	sts	0x0300, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2be8:	26 96       	adiw	r28, 0x06	; 6
    2bea:	0f b6       	in	r0, 0x3f	; 63
    2bec:	f8 94       	cli
    2bee:	de bf       	out	0x3e, r29	; 62
    2bf0:	0f be       	out	0x3f, r0	; 63
    2bf2:	cd bf       	out	0x3d, r28	; 61
    2bf4:	cf 91       	pop	r28
    2bf6:	df 91       	pop	r29
    2bf8:	08 95       	ret

00002bfa <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2bfa:	df 93       	push	r29
    2bfc:	cf 93       	push	r28
    2bfe:	00 d0       	rcall	.+0      	; 0x2c00 <vTaskSwitchContext+0x6>
    2c00:	cd b7       	in	r28, 0x3d	; 61
    2c02:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2c04:	80 91 ff 02 	lds	r24, 0x02FF
    2c08:	88 23       	and	r24, r24
    2c0a:	49 f0       	breq	.+18     	; 0x2c1e <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2c0c:	81 e0       	ldi	r24, 0x01	; 1
    2c0e:	80 93 01 03 	sts	0x0301, r24
    2c12:	54 c0       	rjmp	.+168    	; 0x2cbc <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2c14:	80 91 fd 02 	lds	r24, 0x02FD
    2c18:	81 50       	subi	r24, 0x01	; 1
    2c1a:	80 93 fd 02 	sts	0x02FD, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c1e:	80 91 fd 02 	lds	r24, 0x02FD
    2c22:	28 2f       	mov	r18, r24
    2c24:	30 e0       	ldi	r19, 0x00	; 0
    2c26:	c9 01       	movw	r24, r18
    2c28:	88 0f       	add	r24, r24
    2c2a:	99 1f       	adc	r25, r25
    2c2c:	88 0f       	add	r24, r24
    2c2e:	99 1f       	adc	r25, r25
    2c30:	88 0f       	add	r24, r24
    2c32:	99 1f       	adc	r25, r25
    2c34:	82 0f       	add	r24, r18
    2c36:	93 1f       	adc	r25, r19
    2c38:	fc 01       	movw	r30, r24
    2c3a:	ec 5f       	subi	r30, 0xFC	; 252
    2c3c:	fc 4f       	sbci	r31, 0xFC	; 252
    2c3e:	80 81       	ld	r24, Z
    2c40:	88 23       	and	r24, r24
    2c42:	41 f3       	breq	.-48     	; 0x2c14 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2c44:	80 91 fd 02 	lds	r24, 0x02FD
    2c48:	28 2f       	mov	r18, r24
    2c4a:	30 e0       	ldi	r19, 0x00	; 0
    2c4c:	c9 01       	movw	r24, r18
    2c4e:	88 0f       	add	r24, r24
    2c50:	99 1f       	adc	r25, r25
    2c52:	88 0f       	add	r24, r24
    2c54:	99 1f       	adc	r25, r25
    2c56:	88 0f       	add	r24, r24
    2c58:	99 1f       	adc	r25, r25
    2c5a:	82 0f       	add	r24, r18
    2c5c:	93 1f       	adc	r25, r19
    2c5e:	8c 5f       	subi	r24, 0xFC	; 252
    2c60:	9c 4f       	sbci	r25, 0xFC	; 252
    2c62:	9a 83       	std	Y+2, r25	; 0x02
    2c64:	89 83       	std	Y+1, r24	; 0x01
    2c66:	e9 81       	ldd	r30, Y+1	; 0x01
    2c68:	fa 81       	ldd	r31, Y+2	; 0x02
    2c6a:	01 80       	ldd	r0, Z+1	; 0x01
    2c6c:	f2 81       	ldd	r31, Z+2	; 0x02
    2c6e:	e0 2d       	mov	r30, r0
    2c70:	82 81       	ldd	r24, Z+2	; 0x02
    2c72:	93 81       	ldd	r25, Z+3	; 0x03
    2c74:	e9 81       	ldd	r30, Y+1	; 0x01
    2c76:	fa 81       	ldd	r31, Y+2	; 0x02
    2c78:	92 83       	std	Z+2, r25	; 0x02
    2c7a:	81 83       	std	Z+1, r24	; 0x01
    2c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c80:	21 81       	ldd	r18, Z+1	; 0x01
    2c82:	32 81       	ldd	r19, Z+2	; 0x02
    2c84:	89 81       	ldd	r24, Y+1	; 0x01
    2c86:	9a 81       	ldd	r25, Y+2	; 0x02
    2c88:	03 96       	adiw	r24, 0x03	; 3
    2c8a:	28 17       	cp	r18, r24
    2c8c:	39 07       	cpc	r19, r25
    2c8e:	59 f4       	brne	.+22     	; 0x2ca6 <vTaskSwitchContext+0xac>
    2c90:	e9 81       	ldd	r30, Y+1	; 0x01
    2c92:	fa 81       	ldd	r31, Y+2	; 0x02
    2c94:	01 80       	ldd	r0, Z+1	; 0x01
    2c96:	f2 81       	ldd	r31, Z+2	; 0x02
    2c98:	e0 2d       	mov	r30, r0
    2c9a:	82 81       	ldd	r24, Z+2	; 0x02
    2c9c:	93 81       	ldd	r25, Z+3	; 0x03
    2c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca2:	92 83       	std	Z+2, r25	; 0x02
    2ca4:	81 83       	std	Z+1, r24	; 0x01
    2ca6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca8:	fa 81       	ldd	r31, Y+2	; 0x02
    2caa:	01 80       	ldd	r0, Z+1	; 0x01
    2cac:	f2 81       	ldd	r31, Z+2	; 0x02
    2cae:	e0 2d       	mov	r30, r0
    2cb0:	86 81       	ldd	r24, Z+6	; 0x06
    2cb2:	97 81       	ldd	r25, Z+7	; 0x07
    2cb4:	90 93 f7 02 	sts	0x02F7, r25
    2cb8:	80 93 f6 02 	sts	0x02F6, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2cbc:	0f 90       	pop	r0
    2cbe:	0f 90       	pop	r0
    2cc0:	cf 91       	pop	r28
    2cc2:	df 91       	pop	r29
    2cc4:	08 95       	ret

00002cc6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2cc6:	df 93       	push	r29
    2cc8:	cf 93       	push	r28
    2cca:	00 d0       	rcall	.+0      	; 0x2ccc <vTaskPlaceOnEventList+0x6>
    2ccc:	00 d0       	rcall	.+0      	; 0x2cce <vTaskPlaceOnEventList+0x8>
    2cce:	00 d0       	rcall	.+0      	; 0x2cd0 <vTaskPlaceOnEventList+0xa>
    2cd0:	cd b7       	in	r28, 0x3d	; 61
    2cd2:	de b7       	in	r29, 0x3e	; 62
    2cd4:	9c 83       	std	Y+4, r25	; 0x04
    2cd6:	8b 83       	std	Y+3, r24	; 0x03
    2cd8:	7e 83       	std	Y+6, r23	; 0x06
    2cda:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2cdc:	4b 81       	ldd	r20, Y+3	; 0x03
    2cde:	5c 81       	ldd	r21, Y+4	; 0x04
    2ce0:	80 91 f6 02 	lds	r24, 0x02F6
    2ce4:	90 91 f7 02 	lds	r25, 0x02F7
    2ce8:	9c 01       	movw	r18, r24
    2cea:	24 5f       	subi	r18, 0xF4	; 244
    2cec:	3f 4f       	sbci	r19, 0xFF	; 255
    2cee:	ca 01       	movw	r24, r20
    2cf0:	b9 01       	movw	r22, r18
    2cf2:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cf6:	80 91 f6 02 	lds	r24, 0x02F6
    2cfa:	90 91 f7 02 	lds	r25, 0x02F7
    2cfe:	02 96       	adiw	r24, 0x02	; 2
    2d00:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2d04:	20 91 fa 02 	lds	r18, 0x02FA
    2d08:	30 91 fb 02 	lds	r19, 0x02FB
    2d0c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d0e:	9e 81       	ldd	r25, Y+6	; 0x06
    2d10:	82 0f       	add	r24, r18
    2d12:	93 1f       	adc	r25, r19
    2d14:	9a 83       	std	Y+2, r25	; 0x02
    2d16:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2d18:	89 81       	ldd	r24, Y+1	; 0x01
    2d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1c:	0e 94 5d 18 	call	0x30ba	; 0x30ba <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2d20:	26 96       	adiw	r28, 0x06	; 6
    2d22:	0f b6       	in	r0, 0x3f	; 63
    2d24:	f8 94       	cli
    2d26:	de bf       	out	0x3e, r29	; 62
    2d28:	0f be       	out	0x3f, r0	; 63
    2d2a:	cd bf       	out	0x3d, r28	; 61
    2d2c:	cf 91       	pop	r28
    2d2e:	df 91       	pop	r29
    2d30:	08 95       	ret

00002d32 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2d32:	df 93       	push	r29
    2d34:	cf 93       	push	r28
    2d36:	00 d0       	rcall	.+0      	; 0x2d38 <xTaskRemoveFromEventList+0x6>
    2d38:	00 d0       	rcall	.+0      	; 0x2d3a <xTaskRemoveFromEventList+0x8>
    2d3a:	0f 92       	push	r0
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	9d 83       	std	Y+5, r25	; 0x05
    2d42:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2d44:	ec 81       	ldd	r30, Y+4	; 0x04
    2d46:	fd 81       	ldd	r31, Y+5	; 0x05
    2d48:	05 80       	ldd	r0, Z+5	; 0x05
    2d4a:	f6 81       	ldd	r31, Z+6	; 0x06
    2d4c:	e0 2d       	mov	r30, r0
    2d4e:	86 81       	ldd	r24, Z+6	; 0x06
    2d50:	97 81       	ldd	r25, Z+7	; 0x07
    2d52:	9b 83       	std	Y+3, r25	; 0x03
    2d54:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2d56:	8a 81       	ldd	r24, Y+2	; 0x02
    2d58:	9b 81       	ldd	r25, Y+3	; 0x03
    2d5a:	0c 96       	adiw	r24, 0x0c	; 12
    2d5c:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d60:	80 91 ff 02 	lds	r24, 0x02FF
    2d64:	88 23       	and	r24, r24
    2d66:	61 f5       	brne	.+88     	; 0x2dc0 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d68:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d6c:	02 96       	adiw	r24, 0x02	; 2
    2d6e:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2d72:	ea 81       	ldd	r30, Y+2	; 0x02
    2d74:	fb 81       	ldd	r31, Y+3	; 0x03
    2d76:	96 89       	ldd	r25, Z+22	; 0x16
    2d78:	80 91 fd 02 	lds	r24, 0x02FD
    2d7c:	89 17       	cp	r24, r25
    2d7e:	28 f4       	brcc	.+10     	; 0x2d8a <xTaskRemoveFromEventList+0x58>
    2d80:	ea 81       	ldd	r30, Y+2	; 0x02
    2d82:	fb 81       	ldd	r31, Y+3	; 0x03
    2d84:	86 89       	ldd	r24, Z+22	; 0x16
    2d86:	80 93 fd 02 	sts	0x02FD, r24
    2d8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d8e:	86 89       	ldd	r24, Z+22	; 0x16
    2d90:	28 2f       	mov	r18, r24
    2d92:	30 e0       	ldi	r19, 0x00	; 0
    2d94:	c9 01       	movw	r24, r18
    2d96:	88 0f       	add	r24, r24
    2d98:	99 1f       	adc	r25, r25
    2d9a:	88 0f       	add	r24, r24
    2d9c:	99 1f       	adc	r25, r25
    2d9e:	88 0f       	add	r24, r24
    2da0:	99 1f       	adc	r25, r25
    2da2:	82 0f       	add	r24, r18
    2da4:	93 1f       	adc	r25, r19
    2da6:	ac 01       	movw	r20, r24
    2da8:	4c 5f       	subi	r20, 0xFC	; 252
    2daa:	5c 4f       	sbci	r21, 0xFC	; 252
    2dac:	8a 81       	ldd	r24, Y+2	; 0x02
    2dae:	9b 81       	ldd	r25, Y+3	; 0x03
    2db0:	9c 01       	movw	r18, r24
    2db2:	2e 5f       	subi	r18, 0xFE	; 254
    2db4:	3f 4f       	sbci	r19, 0xFF	; 255
    2db6:	ca 01       	movw	r24, r20
    2db8:	b9 01       	movw	r22, r18
    2dba:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>
    2dbe:	0a c0       	rjmp	.+20     	; 0x2dd4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2dc4:	9c 01       	movw	r18, r24
    2dc6:	24 5f       	subi	r18, 0xF4	; 244
    2dc8:	3f 4f       	sbci	r19, 0xFF	; 255
    2dca:	8c e2       	ldi	r24, 0x2C	; 44
    2dcc:	93 e0       	ldi	r25, 0x03	; 3
    2dce:	b9 01       	movw	r22, r18
    2dd0:	0e 94 cd 09 	call	0x139a	; 0x139a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2dd4:	ea 81       	ldd	r30, Y+2	; 0x02
    2dd6:	fb 81       	ldd	r31, Y+3	; 0x03
    2dd8:	96 89       	ldd	r25, Z+22	; 0x16
    2dda:	e0 91 f6 02 	lds	r30, 0x02F6
    2dde:	f0 91 f7 02 	lds	r31, 0x02F7
    2de2:	86 89       	ldd	r24, Z+22	; 0x16
    2de4:	98 17       	cp	r25, r24
    2de6:	18 f0       	brcs	.+6      	; 0x2dee <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2de8:	81 e0       	ldi	r24, 0x01	; 1
    2dea:	89 83       	std	Y+1, r24	; 0x01
    2dec:	01 c0       	rjmp	.+2      	; 0x2df0 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2dee:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2df0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2df2:	0f 90       	pop	r0
    2df4:	0f 90       	pop	r0
    2df6:	0f 90       	pop	r0
    2df8:	0f 90       	pop	r0
    2dfa:	0f 90       	pop	r0
    2dfc:	cf 91       	pop	r28
    2dfe:	df 91       	pop	r29
    2e00:	08 95       	ret

00002e02 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2e02:	df 93       	push	r29
    2e04:	cf 93       	push	r28
    2e06:	00 d0       	rcall	.+0      	; 0x2e08 <vTaskSetTimeOutState+0x6>
    2e08:	cd b7       	in	r28, 0x3d	; 61
    2e0a:	de b7       	in	r29, 0x3e	; 62
    2e0c:	9a 83       	std	Y+2, r25	; 0x02
    2e0e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2e10:	80 91 02 03 	lds	r24, 0x0302
    2e14:	e9 81       	ldd	r30, Y+1	; 0x01
    2e16:	fa 81       	ldd	r31, Y+2	; 0x02
    2e18:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2e1a:	80 91 fa 02 	lds	r24, 0x02FA
    2e1e:	90 91 fb 02 	lds	r25, 0x02FB
    2e22:	e9 81       	ldd	r30, Y+1	; 0x01
    2e24:	fa 81       	ldd	r31, Y+2	; 0x02
    2e26:	92 83       	std	Z+2, r25	; 0x02
    2e28:	81 83       	std	Z+1, r24	; 0x01
}
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	cf 91       	pop	r28
    2e30:	df 91       	pop	r29
    2e32:	08 95       	ret

00002e34 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2e34:	df 93       	push	r29
    2e36:	cf 93       	push	r28
    2e38:	00 d0       	rcall	.+0      	; 0x2e3a <xTaskCheckForTimeOut+0x6>
    2e3a:	00 d0       	rcall	.+0      	; 0x2e3c <xTaskCheckForTimeOut+0x8>
    2e3c:	0f 92       	push	r0
    2e3e:	cd b7       	in	r28, 0x3d	; 61
    2e40:	de b7       	in	r29, 0x3e	; 62
    2e42:	9b 83       	std	Y+3, r25	; 0x03
    2e44:	8a 83       	std	Y+2, r24	; 0x02
    2e46:	7d 83       	std	Y+5, r23	; 0x05
    2e48:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2e4a:	0f b6       	in	r0, 0x3f	; 63
    2e4c:	f8 94       	cli
    2e4e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2e50:	ea 81       	ldd	r30, Y+2	; 0x02
    2e52:	fb 81       	ldd	r31, Y+3	; 0x03
    2e54:	90 81       	ld	r25, Z
    2e56:	80 91 02 03 	lds	r24, 0x0302
    2e5a:	98 17       	cp	r25, r24
    2e5c:	71 f0       	breq	.+28     	; 0x2e7a <xTaskCheckForTimeOut+0x46>
    2e5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e60:	fb 81       	ldd	r31, Y+3	; 0x03
    2e62:	21 81       	ldd	r18, Z+1	; 0x01
    2e64:	32 81       	ldd	r19, Z+2	; 0x02
    2e66:	80 91 fa 02 	lds	r24, 0x02FA
    2e6a:	90 91 fb 02 	lds	r25, 0x02FB
    2e6e:	82 17       	cp	r24, r18
    2e70:	93 07       	cpc	r25, r19
    2e72:	18 f0       	brcs	.+6      	; 0x2e7a <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e74:	81 e0       	ldi	r24, 0x01	; 1
    2e76:	89 83       	std	Y+1, r24	; 0x01
    2e78:	2f c0       	rjmp	.+94     	; 0x2ed8 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2e7a:	20 91 fa 02 	lds	r18, 0x02FA
    2e7e:	30 91 fb 02 	lds	r19, 0x02FB
    2e82:	ea 81       	ldd	r30, Y+2	; 0x02
    2e84:	fb 81       	ldd	r31, Y+3	; 0x03
    2e86:	81 81       	ldd	r24, Z+1	; 0x01
    2e88:	92 81       	ldd	r25, Z+2	; 0x02
    2e8a:	28 1b       	sub	r18, r24
    2e8c:	39 0b       	sbc	r19, r25
    2e8e:	ec 81       	ldd	r30, Y+4	; 0x04
    2e90:	fd 81       	ldd	r31, Y+5	; 0x05
    2e92:	80 81       	ld	r24, Z
    2e94:	91 81       	ldd	r25, Z+1	; 0x01
    2e96:	28 17       	cp	r18, r24
    2e98:	39 07       	cpc	r19, r25
    2e9a:	e0 f4       	brcc	.+56     	; 0x2ed4 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2e9c:	ec 81       	ldd	r30, Y+4	; 0x04
    2e9e:	fd 81       	ldd	r31, Y+5	; 0x05
    2ea0:	40 81       	ld	r20, Z
    2ea2:	51 81       	ldd	r21, Z+1	; 0x01
    2ea4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ea6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ea8:	21 81       	ldd	r18, Z+1	; 0x01
    2eaa:	32 81       	ldd	r19, Z+2	; 0x02
    2eac:	80 91 fa 02 	lds	r24, 0x02FA
    2eb0:	90 91 fb 02 	lds	r25, 0x02FB
    2eb4:	b9 01       	movw	r22, r18
    2eb6:	68 1b       	sub	r22, r24
    2eb8:	79 0b       	sbc	r23, r25
    2eba:	cb 01       	movw	r24, r22
    2ebc:	84 0f       	add	r24, r20
    2ebe:	95 1f       	adc	r25, r21
    2ec0:	ec 81       	ldd	r30, Y+4	; 0x04
    2ec2:	fd 81       	ldd	r31, Y+5	; 0x05
    2ec4:	91 83       	std	Z+1, r25	; 0x01
    2ec6:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eca:	9b 81       	ldd	r25, Y+3	; 0x03
    2ecc:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ed0:	19 82       	std	Y+1, r1	; 0x01
    2ed2:	02 c0       	rjmp	.+4      	; 0x2ed8 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2ed4:	81 e0       	ldi	r24, 0x01	; 1
    2ed6:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ed8:	0f 90       	pop	r0
    2eda:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2edc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ede:	0f 90       	pop	r0
    2ee0:	0f 90       	pop	r0
    2ee2:	0f 90       	pop	r0
    2ee4:	0f 90       	pop	r0
    2ee6:	0f 90       	pop	r0
    2ee8:	cf 91       	pop	r28
    2eea:	df 91       	pop	r29
    2eec:	08 95       	ret

00002eee <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2eee:	df 93       	push	r29
    2ef0:	cf 93       	push	r28
    2ef2:	cd b7       	in	r28, 0x3d	; 61
    2ef4:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2ef6:	81 e0       	ldi	r24, 0x01	; 1
    2ef8:	80 93 01 03 	sts	0x0301, r24
}
    2efc:	cf 91       	pop	r28
    2efe:	df 91       	pop	r29
    2f00:	08 95       	ret

00002f02 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2f02:	df 93       	push	r29
    2f04:	cf 93       	push	r28
    2f06:	00 d0       	rcall	.+0      	; 0x2f08 <prvIdleTask+0x6>
    2f08:	cd b7       	in	r28, 0x3d	; 61
    2f0a:	de b7       	in	r29, 0x3e	; 62
    2f0c:	9a 83       	std	Y+2, r25	; 0x02
    2f0e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2f10:	0e 94 1f 18 	call	0x303e	; 0x303e <prvCheckTasksWaitingTermination>
    2f14:	fd cf       	rjmp	.-6      	; 0x2f10 <prvIdleTask+0xe>

00002f16 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2f16:	0f 93       	push	r16
    2f18:	1f 93       	push	r17
    2f1a:	df 93       	push	r29
    2f1c:	cf 93       	push	r28
    2f1e:	cd b7       	in	r28, 0x3d	; 61
    2f20:	de b7       	in	r29, 0x3e	; 62
    2f22:	29 97       	sbiw	r28, 0x09	; 9
    2f24:	0f b6       	in	r0, 0x3f	; 63
    2f26:	f8 94       	cli
    2f28:	de bf       	out	0x3e, r29	; 62
    2f2a:	0f be       	out	0x3f, r0	; 63
    2f2c:	cd bf       	out	0x3d, r28	; 61
    2f2e:	9a 83       	std	Y+2, r25	; 0x02
    2f30:	89 83       	std	Y+1, r24	; 0x01
    2f32:	7c 83       	std	Y+4, r23	; 0x04
    2f34:	6b 83       	std	Y+3, r22	; 0x03
    2f36:	4d 83       	std	Y+5, r20	; 0x05
    2f38:	3f 83       	std	Y+7, r19	; 0x07
    2f3a:	2e 83       	std	Y+6, r18	; 0x06
    2f3c:	19 87       	std	Y+9, r17	; 0x09
    2f3e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2f40:	89 81       	ldd	r24, Y+1	; 0x01
    2f42:	9a 81       	ldd	r25, Y+2	; 0x02
    2f44:	49 96       	adiw	r24, 0x19	; 25
    2f46:	2b 81       	ldd	r18, Y+3	; 0x03
    2f48:	3c 81       	ldd	r19, Y+4	; 0x04
    2f4a:	b9 01       	movw	r22, r18
    2f4c:	44 e1       	ldi	r20, 0x14	; 20
    2f4e:	50 e0       	ldi	r21, 0x00	; 0
    2f50:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2f54:	e9 81       	ldd	r30, Y+1	; 0x01
    2f56:	fa 81       	ldd	r31, Y+2	; 0x02
    2f58:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2f5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f5c:	82 30       	cpi	r24, 0x02	; 2
    2f5e:	10 f0       	brcs	.+4      	; 0x2f64 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2f60:	81 e0       	ldi	r24, 0x01	; 1
    2f62:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2f64:	e9 81       	ldd	r30, Y+1	; 0x01
    2f66:	fa 81       	ldd	r31, Y+2	; 0x02
    2f68:	8d 81       	ldd	r24, Y+5	; 0x05
    2f6a:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2f6c:	89 81       	ldd	r24, Y+1	; 0x01
    2f6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f70:	02 96       	adiw	r24, 0x02	; 2
    2f72:	0e 94 bd 09 	call	0x137a	; 0x137a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2f76:	89 81       	ldd	r24, Y+1	; 0x01
    2f78:	9a 81       	ldd	r25, Y+2	; 0x02
    2f7a:	0c 96       	adiw	r24, 0x0c	; 12
    2f7c:	0e 94 bd 09 	call	0x137a	; 0x137a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2f80:	e9 81       	ldd	r30, Y+1	; 0x01
    2f82:	fa 81       	ldd	r31, Y+2	; 0x02
    2f84:	89 81       	ldd	r24, Y+1	; 0x01
    2f86:	9a 81       	ldd	r25, Y+2	; 0x02
    2f88:	91 87       	std	Z+9, r25	; 0x09
    2f8a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2f8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f8e:	28 2f       	mov	r18, r24
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	82 e0       	ldi	r24, 0x02	; 2
    2f94:	90 e0       	ldi	r25, 0x00	; 0
    2f96:	82 1b       	sub	r24, r18
    2f98:	93 0b       	sbc	r25, r19
    2f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f9e:	95 87       	std	Z+13, r25	; 0x0d
    2fa0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2faa:	93 8b       	std	Z+19, r25	; 0x13
    2fac:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2fae:	29 96       	adiw	r28, 0x09	; 9
    2fb0:	0f b6       	in	r0, 0x3f	; 63
    2fb2:	f8 94       	cli
    2fb4:	de bf       	out	0x3e, r29	; 62
    2fb6:	0f be       	out	0x3f, r0	; 63
    2fb8:	cd bf       	out	0x3d, r28	; 61
    2fba:	cf 91       	pop	r28
    2fbc:	df 91       	pop	r29
    2fbe:	1f 91       	pop	r17
    2fc0:	0f 91       	pop	r16
    2fc2:	08 95       	ret

00002fc4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2fc4:	df 93       	push	r29
    2fc6:	cf 93       	push	r28
    2fc8:	0f 92       	push	r0
    2fca:	cd b7       	in	r28, 0x3d	; 61
    2fcc:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2fce:	19 82       	std	Y+1, r1	; 0x01
    2fd0:	13 c0       	rjmp	.+38     	; 0x2ff8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2fd2:	89 81       	ldd	r24, Y+1	; 0x01
    2fd4:	28 2f       	mov	r18, r24
    2fd6:	30 e0       	ldi	r19, 0x00	; 0
    2fd8:	c9 01       	movw	r24, r18
    2fda:	88 0f       	add	r24, r24
    2fdc:	99 1f       	adc	r25, r25
    2fde:	88 0f       	add	r24, r24
    2fe0:	99 1f       	adc	r25, r25
    2fe2:	88 0f       	add	r24, r24
    2fe4:	99 1f       	adc	r25, r25
    2fe6:	82 0f       	add	r24, r18
    2fe8:	93 1f       	adc	r25, r19
    2fea:	8c 5f       	subi	r24, 0xFC	; 252
    2fec:	9c 4f       	sbci	r25, 0xFC	; 252
    2fee:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2ff2:	89 81       	ldd	r24, Y+1	; 0x01
    2ff4:	8f 5f       	subi	r24, 0xFF	; 255
    2ff6:	89 83       	std	Y+1, r24	; 0x01
    2ff8:	89 81       	ldd	r24, Y+1	; 0x01
    2ffa:	82 30       	cpi	r24, 0x02	; 2
    2ffc:	50 f3       	brcs	.-44     	; 0x2fd2 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2ffe:	86 e1       	ldi	r24, 0x16	; 22
    3000:	93 e0       	ldi	r25, 0x03	; 3
    3002:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3006:	8f e1       	ldi	r24, 0x1F	; 31
    3008:	93 e0       	ldi	r25, 0x03	; 3
    300a:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    300e:	8c e2       	ldi	r24, 0x2C	; 44
    3010:	93 e0       	ldi	r25, 0x03	; 3
    3012:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    3016:	85 e3       	ldi	r24, 0x35	; 53
    3018:	93 e0       	ldi	r25, 0x03	; 3
    301a:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    301e:	86 e1       	ldi	r24, 0x16	; 22
    3020:	93 e0       	ldi	r25, 0x03	; 3
    3022:	90 93 29 03 	sts	0x0329, r25
    3026:	80 93 28 03 	sts	0x0328, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    302a:	8f e1       	ldi	r24, 0x1F	; 31
    302c:	93 e0       	ldi	r25, 0x03	; 3
    302e:	90 93 2b 03 	sts	0x032B, r25
    3032:	80 93 2a 03 	sts	0x032A, r24
}
    3036:	0f 90       	pop	r0
    3038:	cf 91       	pop	r28
    303a:	df 91       	pop	r29
    303c:	08 95       	ret

0000303e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    303e:	df 93       	push	r29
    3040:	cf 93       	push	r28
    3042:	00 d0       	rcall	.+0      	; 0x3044 <prvCheckTasksWaitingTermination+0x6>
    3044:	0f 92       	push	r0
    3046:	cd b7       	in	r28, 0x3d	; 61
    3048:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    304a:	80 91 f8 02 	lds	r24, 0x02F8
    304e:	88 23       	and	r24, r24
    3050:	71 f1       	breq	.+92     	; 0x30ae <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    3052:	0e 94 5d 14 	call	0x28ba	; 0x28ba <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3056:	80 91 35 03 	lds	r24, 0x0335
    305a:	1b 82       	std	Y+3, r1	; 0x03
    305c:	88 23       	and	r24, r24
    305e:	11 f4       	brne	.+4      	; 0x3064 <prvCheckTasksWaitingTermination+0x26>
    3060:	81 e0       	ldi	r24, 0x01	; 1
    3062:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    3064:	0e 94 69 14 	call	0x28d2	; 0x28d2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3068:	8b 81       	ldd	r24, Y+3	; 0x03
    306a:	88 23       	and	r24, r24
    306c:	01 f5       	brne	.+64     	; 0x30ae <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    306e:	0f b6       	in	r0, 0x3f	; 63
    3070:	f8 94       	cli
    3072:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    3074:	e0 91 3a 03 	lds	r30, 0x033A
    3078:	f0 91 3b 03 	lds	r31, 0x033B
    307c:	86 81       	ldd	r24, Z+6	; 0x06
    307e:	97 81       	ldd	r25, Z+7	; 0x07
    3080:	9a 83       	std	Y+2, r25	; 0x02
    3082:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    3084:	89 81       	ldd	r24, Y+1	; 0x01
    3086:	9a 81       	ldd	r25, Y+2	; 0x02
    3088:	02 96       	adiw	r24, 0x02	; 2
    308a:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
					--uxCurrentNumberOfTasks;
    308e:	80 91 f9 02 	lds	r24, 0x02F9
    3092:	81 50       	subi	r24, 0x01	; 1
    3094:	80 93 f9 02 	sts	0x02F9, r24
					--uxTasksDeleted;
    3098:	80 91 f8 02 	lds	r24, 0x02F8
    309c:	81 50       	subi	r24, 0x01	; 1
    309e:	80 93 f8 02 	sts	0x02F8, r24
				}
				taskEXIT_CRITICAL();
    30a2:	0f 90       	pop	r0
    30a4:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    30a6:	89 81       	ldd	r24, Y+1	; 0x01
    30a8:	9a 81       	ldd	r25, Y+2	; 0x02
    30aa:	0e 94 f6 18 	call	0x31ec	; 0x31ec <prvDeleteTCB>
			}
		}
	}
	#endif
}
    30ae:	0f 90       	pop	r0
    30b0:	0f 90       	pop	r0
    30b2:	0f 90       	pop	r0
    30b4:	cf 91       	pop	r28
    30b6:	df 91       	pop	r29
    30b8:	08 95       	ret

000030ba <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    30ba:	df 93       	push	r29
    30bc:	cf 93       	push	r28
    30be:	00 d0       	rcall	.+0      	; 0x30c0 <prvAddCurrentTaskToDelayedList+0x6>
    30c0:	cd b7       	in	r28, 0x3d	; 61
    30c2:	de b7       	in	r29, 0x3e	; 62
    30c4:	9a 83       	std	Y+2, r25	; 0x02
    30c6:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    30c8:	e0 91 f6 02 	lds	r30, 0x02F6
    30cc:	f0 91 f7 02 	lds	r31, 0x02F7
    30d0:	89 81       	ldd	r24, Y+1	; 0x01
    30d2:	9a 81       	ldd	r25, Y+2	; 0x02
    30d4:	93 83       	std	Z+3, r25	; 0x03
    30d6:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    30d8:	20 91 fa 02 	lds	r18, 0x02FA
    30dc:	30 91 fb 02 	lds	r19, 0x02FB
    30e0:	89 81       	ldd	r24, Y+1	; 0x01
    30e2:	9a 81       	ldd	r25, Y+2	; 0x02
    30e4:	82 17       	cp	r24, r18
    30e6:	93 07       	cpc	r25, r19
    30e8:	70 f4       	brcc	.+28     	; 0x3106 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30ea:	80 91 2a 03 	lds	r24, 0x032A
    30ee:	90 91 2b 03 	lds	r25, 0x032B
    30f2:	20 91 f6 02 	lds	r18, 0x02F6
    30f6:	30 91 f7 02 	lds	r19, 0x02F7
    30fa:	2e 5f       	subi	r18, 0xFE	; 254
    30fc:	3f 4f       	sbci	r19, 0xFF	; 255
    30fe:	b9 01       	movw	r22, r18
    3100:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsert>
    3104:	1e c0       	rjmp	.+60     	; 0x3142 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3106:	40 91 28 03 	lds	r20, 0x0328
    310a:	50 91 29 03 	lds	r21, 0x0329
    310e:	80 91 f6 02 	lds	r24, 0x02F6
    3112:	90 91 f7 02 	lds	r25, 0x02F7
    3116:	9c 01       	movw	r18, r24
    3118:	2e 5f       	subi	r18, 0xFE	; 254
    311a:	3f 4f       	sbci	r19, 0xFF	; 255
    311c:	ca 01       	movw	r24, r20
    311e:	b9 01       	movw	r22, r18
    3120:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3124:	20 91 b3 00 	lds	r18, 0x00B3
    3128:	30 91 b4 00 	lds	r19, 0x00B4
    312c:	89 81       	ldd	r24, Y+1	; 0x01
    312e:	9a 81       	ldd	r25, Y+2	; 0x02
    3130:	82 17       	cp	r24, r18
    3132:	93 07       	cpc	r25, r19
    3134:	30 f4       	brcc	.+12     	; 0x3142 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3136:	89 81       	ldd	r24, Y+1	; 0x01
    3138:	9a 81       	ldd	r25, Y+2	; 0x02
    313a:	90 93 b4 00 	sts	0x00B4, r25
    313e:	80 93 b3 00 	sts	0x00B3, r24
		}
	}
}
    3142:	0f 90       	pop	r0
    3144:	0f 90       	pop	r0
    3146:	cf 91       	pop	r28
    3148:	df 91       	pop	r29
    314a:	08 95       	ret

0000314c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    314c:	df 93       	push	r29
    314e:	cf 93       	push	r28
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	28 97       	sbiw	r28, 0x08	; 8
    3156:	0f b6       	in	r0, 0x3f	; 63
    3158:	f8 94       	cli
    315a:	de bf       	out	0x3e, r29	; 62
    315c:	0f be       	out	0x3f, r0	; 63
    315e:	cd bf       	out	0x3d, r28	; 61
    3160:	9c 83       	std	Y+4, r25	; 0x04
    3162:	8b 83       	std	Y+3, r24	; 0x03
    3164:	7e 83       	std	Y+6, r23	; 0x06
    3166:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    3168:	8d e2       	ldi	r24, 0x2D	; 45
    316a:	90 e0       	ldi	r25, 0x00	; 0
    316c:	0e 94 27 09 	call	0x124e	; 0x124e <pvPortMalloc>
    3170:	9a 83       	std	Y+2, r25	; 0x02
    3172:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3174:	89 81       	ldd	r24, Y+1	; 0x01
    3176:	9a 81       	ldd	r25, Y+2	; 0x02
    3178:	00 97       	sbiw	r24, 0x00	; 0
    317a:	69 f1       	breq	.+90     	; 0x31d6 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    317c:	8d 81       	ldd	r24, Y+5	; 0x05
    317e:	9e 81       	ldd	r25, Y+6	; 0x06
    3180:	00 97       	sbiw	r24, 0x00	; 0
    3182:	39 f4       	brne	.+14     	; 0x3192 <prvAllocateTCBAndStack+0x46>
    3184:	8b 81       	ldd	r24, Y+3	; 0x03
    3186:	9c 81       	ldd	r25, Y+4	; 0x04
    3188:	0e 94 27 09 	call	0x124e	; 0x124e <pvPortMalloc>
    318c:	98 87       	std	Y+8, r25	; 0x08
    318e:	8f 83       	std	Y+7, r24	; 0x07
    3190:	04 c0       	rjmp	.+8      	; 0x319a <prvAllocateTCBAndStack+0x4e>
    3192:	8d 81       	ldd	r24, Y+5	; 0x05
    3194:	9e 81       	ldd	r25, Y+6	; 0x06
    3196:	98 87       	std	Y+8, r25	; 0x08
    3198:	8f 83       	std	Y+7, r24	; 0x07
    319a:	e9 81       	ldd	r30, Y+1	; 0x01
    319c:	fa 81       	ldd	r31, Y+2	; 0x02
    319e:	8f 81       	ldd	r24, Y+7	; 0x07
    31a0:	98 85       	ldd	r25, Y+8	; 0x08
    31a2:	90 8f       	std	Z+24, r25	; 0x18
    31a4:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    31a6:	e9 81       	ldd	r30, Y+1	; 0x01
    31a8:	fa 81       	ldd	r31, Y+2	; 0x02
    31aa:	87 89       	ldd	r24, Z+23	; 0x17
    31ac:	90 8d       	ldd	r25, Z+24	; 0x18
    31ae:	00 97       	sbiw	r24, 0x00	; 0
    31b0:	39 f4       	brne	.+14     	; 0x31c0 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    31b2:	89 81       	ldd	r24, Y+1	; 0x01
    31b4:	9a 81       	ldd	r25, Y+2	; 0x02
    31b6:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
			pxNewTCB = NULL;
    31ba:	1a 82       	std	Y+2, r1	; 0x02
    31bc:	19 82       	std	Y+1, r1	; 0x01
    31be:	0b c0       	rjmp	.+22     	; 0x31d6 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    31c0:	e9 81       	ldd	r30, Y+1	; 0x01
    31c2:	fa 81       	ldd	r31, Y+2	; 0x02
    31c4:	87 89       	ldd	r24, Z+23	; 0x17
    31c6:	90 8d       	ldd	r25, Z+24	; 0x18
    31c8:	2b 81       	ldd	r18, Y+3	; 0x03
    31ca:	3c 81       	ldd	r19, Y+4	; 0x04
    31cc:	65 ea       	ldi	r22, 0xA5	; 165
    31ce:	70 e0       	ldi	r23, 0x00	; 0
    31d0:	a9 01       	movw	r20, r18
    31d2:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <memset>
		}
	}

	return pxNewTCB;
    31d6:	89 81       	ldd	r24, Y+1	; 0x01
    31d8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31da:	28 96       	adiw	r28, 0x08	; 8
    31dc:	0f b6       	in	r0, 0x3f	; 63
    31de:	f8 94       	cli
    31e0:	de bf       	out	0x3e, r29	; 62
    31e2:	0f be       	out	0x3f, r0	; 63
    31e4:	cd bf       	out	0x3d, r28	; 61
    31e6:	cf 91       	pop	r28
    31e8:	df 91       	pop	r29
    31ea:	08 95       	ret

000031ec <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    31ec:	df 93       	push	r29
    31ee:	cf 93       	push	r28
    31f0:	00 d0       	rcall	.+0      	; 0x31f2 <prvDeleteTCB+0x6>
    31f2:	cd b7       	in	r28, 0x3d	; 61
    31f4:	de b7       	in	r29, 0x3e	; 62
    31f6:	9a 83       	std	Y+2, r25	; 0x02
    31f8:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    31fa:	e9 81       	ldd	r30, Y+1	; 0x01
    31fc:	fa 81       	ldd	r31, Y+2	; 0x02
    31fe:	87 89       	ldd	r24, Z+23	; 0x17
    3200:	90 8d       	ldd	r25, Z+24	; 0x18
    3202:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
		vPortFree( pxTCB );
    3206:	89 81       	ldd	r24, Y+1	; 0x01
    3208:	9a 81       	ldd	r25, Y+2	; 0x02
    320a:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
	}
    320e:	0f 90       	pop	r0
    3210:	0f 90       	pop	r0
    3212:	cf 91       	pop	r28
    3214:	df 91       	pop	r29
    3216:	08 95       	ret

00003218 <Keypad_Init>:
#include "Keypad_config.h"
#include "interface.h"
#include "util/delay.h"

void Keypad_Init()
{
    3218:	df 93       	push	r29
    321a:	cf 93       	push	r28
    321c:	cd b7       	in	r28, 0x3d	; 61
    321e:	de b7       	in	r29, 0x3e	; 62
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN0,DIO_u8_PIN_OUTPUT);
    3220:	80 e0       	ldi	r24, 0x00	; 0
    3222:	60 e0       	ldi	r22, 0x00	; 0
    3224:	41 e0       	ldi	r20, 0x01	; 1
    3226:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN1,DIO_u8_PIN_OUTPUT);
    322a:	80 e0       	ldi	r24, 0x00	; 0
    322c:	61 e0       	ldi	r22, 0x01	; 1
    322e:	41 e0       	ldi	r20, 0x01	; 1
    3230:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN2,DIO_u8_PIN_OUTPUT);
    3234:	80 e0       	ldi	r24, 0x00	; 0
    3236:	62 e0       	ldi	r22, 0x02	; 2
    3238:	41 e0       	ldi	r20, 0x01	; 1
    323a:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN3,DIO_u8_PIN_OUTPUT);
    323e:	80 e0       	ldi	r24, 0x00	; 0
    3240:	63 e0       	ldi	r22, 0x03	; 3
    3242:	41 e0       	ldi	r20, 0x01	; 1
    3244:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN4,DIO_u8_PIN_INPUT);
    3248:	80 e0       	ldi	r24, 0x00	; 0
    324a:	64 e0       	ldi	r22, 0x04	; 4
    324c:	40 e0       	ldi	r20, 0x00	; 0
    324e:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN5,DIO_u8_PIN_INPUT);
    3252:	80 e0       	ldi	r24, 0x00	; 0
    3254:	65 e0       	ldi	r22, 0x05	; 5
    3256:	40 e0       	ldi	r20, 0x00	; 0
    3258:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN6,DIO_u8_PIN_INPUT);
    325c:	80 e0       	ldi	r24, 0x00	; 0
    325e:	66 e0       	ldi	r22, 0x06	; 6
    3260:	40 e0       	ldi	r20, 0x00	; 0
    3262:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(KPD_PORT,DIO_u8_PIN7,DIO_u8_PIN_INPUT);
    3266:	80 e0       	ldi	r24, 0x00	; 0
    3268:	67 e0       	ldi	r22, 0x07	; 7
    326a:	40 e0       	ldi	r20, 0x00	; 0
    326c:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
	DIO_u8SetPortValue(KPD_PORT,0xff);
    3270:	80 e0       	ldi	r24, 0x00	; 0
    3272:	6f ef       	ldi	r22, 0xFF	; 255
    3274:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
}
    3278:	cf 91       	pop	r28
    327a:	df 91       	pop	r29
    327c:	08 95       	ret

0000327e <KeypadGetPressed>:
u8 KeypadGetPressed(void)
{
    327e:	df 93       	push	r29
    3280:	cf 93       	push	r28
    3282:	00 d0       	rcall	.+0      	; 0x3284 <KeypadGetPressed+0x6>
    3284:	00 d0       	rcall	.+0      	; 0x3286 <KeypadGetPressed+0x8>
    3286:	0f 92       	push	r0
    3288:	cd b7       	in	r28, 0x3d	; 61
    328a:	de b7       	in	r29, 0x3e	; 62
	u8 PressedKey = ' ';
    328c:	80 e2       	ldi	r24, 0x20	; 32
    328e:	8c 83       	std	Y+4, r24	; 0x04
	u8 ColumnIndex;
	u8 RowIndex;
	u8 IsKeyPreesed = FALSE;
    3290:	19 82       	std	Y+1, r1	; 0x01
for(ColumnIndex=COL_START;ColumnIndex<=COL_END;ColumnIndex++ )
    3292:	1b 82       	std	Y+3, r1	; 0x03
    3294:	3f c0       	rjmp	.+126    	; 0x3314 <KeypadGetPressed+0x96>
	{
		DIO_u8SetPinValue(KPD_PORT,ColumnIndex,DIO_u8_PIN_LOW);
    3296:	80 e0       	ldi	r24, 0x00	; 0
    3298:	6b 81       	ldd	r22, Y+3	; 0x03
    329a:	40 e0       	ldi	r20, 0x00	; 0
    329c:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
		for(RowIndex=ROW_START;RowIndex<=ROW_END;RowIndex++)
    32a0:	84 e0       	ldi	r24, 0x04	; 4
    32a2:	8a 83       	std	Y+2, r24	; 0x02
    32a4:	2c c0       	rjmp	.+88     	; 0x32fe <KeypadGetPressed+0x80>
		{
			if(DIO_u8_PIN_LOW==DIO_u8GetPinValue(KPD_PORT,RowIndex))
    32a6:	80 e0       	ldi	r24, 0x00	; 0
    32a8:	6a 81       	ldd	r22, Y+2	; 0x02
    32aa:	0e 94 96 23 	call	0x472c	; 0x472c <DIO_u8GetPinValue>
    32ae:	88 23       	and	r24, r24
    32b0:	19 f5       	brne	.+70     	; 0x32f8 <KeypadGetPressed+0x7a>
			{
				PressedKey = SwitchesValue[ColumnIndex][RowIndex-ROW_START];
    32b2:	8b 81       	ldd	r24, Y+3	; 0x03
    32b4:	48 2f       	mov	r20, r24
    32b6:	50 e0       	ldi	r21, 0x00	; 0
    32b8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ba:	88 2f       	mov	r24, r24
    32bc:	90 e0       	ldi	r25, 0x00	; 0
    32be:	9c 01       	movw	r18, r24
    32c0:	24 50       	subi	r18, 0x04	; 4
    32c2:	30 40       	sbci	r19, 0x00	; 0
    32c4:	ca 01       	movw	r24, r20
    32c6:	88 0f       	add	r24, r24
    32c8:	99 1f       	adc	r25, r25
    32ca:	88 0f       	add	r24, r24
    32cc:	99 1f       	adc	r25, r25
    32ce:	82 0f       	add	r24, r18
    32d0:	93 1f       	adc	r25, r19
    32d2:	fc 01       	movw	r30, r24
    32d4:	eb 54       	subi	r30, 0x4B	; 75
    32d6:	ff 4f       	sbci	r31, 0xFF	; 255
    32d8:	80 81       	ld	r24, Z
    32da:	8c 83       	std	Y+4, r24	; 0x04

				/*busy wait polling until the key is released*/
				while(DIO_u8_PIN_LOW==DIO_u8GetPinValue(KPD_PORT,RowIndex));
    32dc:	80 e0       	ldi	r24, 0x00	; 0
    32de:	6a 81       	ldd	r22, Y+2	; 0x02
    32e0:	0e 94 96 23 	call	0x472c	; 0x472c <DIO_u8GetPinValue>
    32e4:	88 23       	and	r24, r24
    32e6:	d1 f3       	breq	.-12     	; 0x32dc <KeypadGetPressed+0x5e>

				DIO_u8SetPinValue(KPD_PORT,ColumnIndex,DIO_u8_PIN_HIGH);
    32e8:	80 e0       	ldi	r24, 0x00	; 0
    32ea:	6b 81       	ldd	r22, Y+3	; 0x03
    32ec:	41 e0       	ldi	r20, 0x01	; 1
    32ee:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
				IsKeyPreesed = TRUE;
    32f2:	81 e0       	ldi	r24, 0x01	; 1
    32f4:	89 83       	std	Y+1, r24	; 0x01
    32f6:	06 c0       	rjmp	.+12     	; 0x3304 <KeypadGetPressed+0x86>
	u8 RowIndex;
	u8 IsKeyPreesed = FALSE;
for(ColumnIndex=COL_START;ColumnIndex<=COL_END;ColumnIndex++ )
	{
		DIO_u8SetPinValue(KPD_PORT,ColumnIndex,DIO_u8_PIN_LOW);
		for(RowIndex=ROW_START;RowIndex<=ROW_END;RowIndex++)
    32f8:	8a 81       	ldd	r24, Y+2	; 0x02
    32fa:	8f 5f       	subi	r24, 0xFF	; 255
    32fc:	8a 83       	std	Y+2, r24	; 0x02
    32fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3300:	88 30       	cpi	r24, 0x08	; 8
    3302:	88 f2       	brcs	.-94     	; 0x32a6 <KeypadGetPressed+0x28>
				DIO_u8SetPinValue(KPD_PORT,ColumnIndex,DIO_u8_PIN_HIGH);
				IsKeyPreesed = TRUE;
				break;
			}
		}
		DIO_u8SetPinValue(KPD_PORT,ColumnIndex,DIO_u8_PIN_HIGH);
    3304:	80 e0       	ldi	r24, 0x00	; 0
    3306:	6b 81       	ldd	r22, Y+3	; 0x03
    3308:	41 e0       	ldi	r20, 0x01	; 1
    330a:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
{
	u8 PressedKey = ' ';
	u8 ColumnIndex;
	u8 RowIndex;
	u8 IsKeyPreesed = FALSE;
for(ColumnIndex=COL_START;ColumnIndex<=COL_END;ColumnIndex++ )
    330e:	8b 81       	ldd	r24, Y+3	; 0x03
    3310:	8f 5f       	subi	r24, 0xFF	; 255
    3312:	8b 83       	std	Y+3, r24	; 0x03
    3314:	8b 81       	ldd	r24, Y+3	; 0x03
    3316:	84 30       	cpi	r24, 0x04	; 4
    3318:	08 f4       	brcc	.+2      	; 0x331c <KeypadGetPressed+0x9e>
    331a:	bd cf       	rjmp	.-134    	; 0x3296 <KeypadGetPressed+0x18>
				break;
			}
		}
		DIO_u8SetPinValue(KPD_PORT,ColumnIndex,DIO_u8_PIN_HIGH);
	}
	if(IsKeyPreesed == TRUE)
    331c:	89 81       	ldd	r24, Y+1	; 0x01
    331e:	81 30       	cpi	r24, 0x01	; 1
    3320:	21 f4       	brne	.+8      	; 0x332a <KeypadGetPressed+0xac>
		return PressedKey;
    3322:	8c 81       	ldd	r24, Y+4	; 0x04
    3324:	8d 83       	std	Y+5, r24	; 0x05
}
    3326:	8d 81       	ldd	r24, Y+5	; 0x05
    3328:	00 c0       	rjmp	.+0      	; 0x332a <KeypadGetPressed+0xac>
    332a:	0f 90       	pop	r0
    332c:	0f 90       	pop	r0
    332e:	0f 90       	pop	r0
    3330:	0f 90       	pop	r0
    3332:	0f 90       	pop	r0
    3334:	cf 91       	pop	r28
    3336:	df 91       	pop	r29
    3338:	08 95       	ret

0000333a <LCD_voidInitial>:
#include "lcd_interface.h"
#include "lcd_config.h"


void LCD_voidInitial(void)
{
    333a:	0f 93       	push	r16
    333c:	1f 93       	push	r17
    333e:	df 93       	push	r29
    3340:	cf 93       	push	r28
    3342:	cd b7       	in	r28, 0x3d	; 61
    3344:	de b7       	in	r29, 0x3e	; 62
    3346:	cc 54       	subi	r28, 0x4C	; 76
    3348:	d0 40       	sbci	r29, 0x00	; 0
    334a:	0f b6       	in	r0, 0x3f	; 63
    334c:	f8 94       	cli
    334e:	de bf       	out	0x3e, r29	; 62
    3350:	0f be       	out	0x3f, r0	; 63
    3352:	cd bf       	out	0x3d, r28	; 61
    3354:	fe 01       	movw	r30, r28
    3356:	e7 5b       	subi	r30, 0xB7	; 183
    3358:	ff 4f       	sbci	r31, 0xFF	; 255
    335a:	80 e0       	ldi	r24, 0x00	; 0
    335c:	90 e0       	ldi	r25, 0x00	; 0
    335e:	ac e0       	ldi	r26, 0x0C	; 12
    3360:	b2 e4       	ldi	r27, 0x42	; 66
    3362:	80 83       	st	Z, r24
    3364:	91 83       	std	Z+1, r25	; 0x01
    3366:	a2 83       	std	Z+2, r26	; 0x02
    3368:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    336a:	8e 01       	movw	r16, r28
    336c:	0b 5b       	subi	r16, 0xBB	; 187
    336e:	1f 4f       	sbci	r17, 0xFF	; 255
    3370:	fe 01       	movw	r30, r28
    3372:	e7 5b       	subi	r30, 0xB7	; 183
    3374:	ff 4f       	sbci	r31, 0xFF	; 255
    3376:	60 81       	ld	r22, Z
    3378:	71 81       	ldd	r23, Z+1	; 0x01
    337a:	82 81       	ldd	r24, Z+2	; 0x02
    337c:	93 81       	ldd	r25, Z+3	; 0x03
    337e:	20 e0       	ldi	r18, 0x00	; 0
    3380:	30 e0       	ldi	r19, 0x00	; 0
    3382:	4a ef       	ldi	r20, 0xFA	; 250
    3384:	54 e4       	ldi	r21, 0x44	; 68
    3386:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    338a:	dc 01       	movw	r26, r24
    338c:	cb 01       	movw	r24, r22
    338e:	f8 01       	movw	r30, r16
    3390:	80 83       	st	Z, r24
    3392:	91 83       	std	Z+1, r25	; 0x01
    3394:	a2 83       	std	Z+2, r26	; 0x02
    3396:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3398:	fe 01       	movw	r30, r28
    339a:	eb 5b       	subi	r30, 0xBB	; 187
    339c:	ff 4f       	sbci	r31, 0xFF	; 255
    339e:	60 81       	ld	r22, Z
    33a0:	71 81       	ldd	r23, Z+1	; 0x01
    33a2:	82 81       	ldd	r24, Z+2	; 0x02
    33a4:	93 81       	ldd	r25, Z+3	; 0x03
    33a6:	20 e0       	ldi	r18, 0x00	; 0
    33a8:	30 e0       	ldi	r19, 0x00	; 0
    33aa:	40 e8       	ldi	r20, 0x80	; 128
    33ac:	5f e3       	ldi	r21, 0x3F	; 63
    33ae:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    33b2:	88 23       	and	r24, r24
    33b4:	44 f4       	brge	.+16     	; 0x33c6 <LCD_voidInitial+0x8c>
		__ticks = 1;
    33b6:	fe 01       	movw	r30, r28
    33b8:	ed 5b       	subi	r30, 0xBD	; 189
    33ba:	ff 4f       	sbci	r31, 0xFF	; 255
    33bc:	81 e0       	ldi	r24, 0x01	; 1
    33be:	90 e0       	ldi	r25, 0x00	; 0
    33c0:	91 83       	std	Z+1, r25	; 0x01
    33c2:	80 83       	st	Z, r24
    33c4:	64 c0       	rjmp	.+200    	; 0x348e <LCD_voidInitial+0x154>
	else if (__tmp > 65535)
    33c6:	fe 01       	movw	r30, r28
    33c8:	eb 5b       	subi	r30, 0xBB	; 187
    33ca:	ff 4f       	sbci	r31, 0xFF	; 255
    33cc:	60 81       	ld	r22, Z
    33ce:	71 81       	ldd	r23, Z+1	; 0x01
    33d0:	82 81       	ldd	r24, Z+2	; 0x02
    33d2:	93 81       	ldd	r25, Z+3	; 0x03
    33d4:	20 e0       	ldi	r18, 0x00	; 0
    33d6:	3f ef       	ldi	r19, 0xFF	; 255
    33d8:	4f e7       	ldi	r20, 0x7F	; 127
    33da:	57 e4       	ldi	r21, 0x47	; 71
    33dc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    33e0:	18 16       	cp	r1, r24
    33e2:	0c f0       	brlt	.+2      	; 0x33e6 <LCD_voidInitial+0xac>
    33e4:	43 c0       	rjmp	.+134    	; 0x346c <LCD_voidInitial+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33e6:	fe 01       	movw	r30, r28
    33e8:	e7 5b       	subi	r30, 0xB7	; 183
    33ea:	ff 4f       	sbci	r31, 0xFF	; 255
    33ec:	60 81       	ld	r22, Z
    33ee:	71 81       	ldd	r23, Z+1	; 0x01
    33f0:	82 81       	ldd	r24, Z+2	; 0x02
    33f2:	93 81       	ldd	r25, Z+3	; 0x03
    33f4:	20 e0       	ldi	r18, 0x00	; 0
    33f6:	30 e0       	ldi	r19, 0x00	; 0
    33f8:	40 e2       	ldi	r20, 0x20	; 32
    33fa:	51 e4       	ldi	r21, 0x41	; 65
    33fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3400:	dc 01       	movw	r26, r24
    3402:	cb 01       	movw	r24, r22
    3404:	8e 01       	movw	r16, r28
    3406:	0d 5b       	subi	r16, 0xBD	; 189
    3408:	1f 4f       	sbci	r17, 0xFF	; 255
    340a:	bc 01       	movw	r22, r24
    340c:	cd 01       	movw	r24, r26
    340e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3412:	dc 01       	movw	r26, r24
    3414:	cb 01       	movw	r24, r22
    3416:	f8 01       	movw	r30, r16
    3418:	91 83       	std	Z+1, r25	; 0x01
    341a:	80 83       	st	Z, r24
    341c:	1f c0       	rjmp	.+62     	; 0x345c <LCD_voidInitial+0x122>
    341e:	fe 01       	movw	r30, r28
    3420:	ef 5b       	subi	r30, 0xBF	; 191
    3422:	ff 4f       	sbci	r31, 0xFF	; 255
    3424:	88 ec       	ldi	r24, 0xC8	; 200
    3426:	90 e0       	ldi	r25, 0x00	; 0
    3428:	91 83       	std	Z+1, r25	; 0x01
    342a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    342c:	fe 01       	movw	r30, r28
    342e:	ef 5b       	subi	r30, 0xBF	; 191
    3430:	ff 4f       	sbci	r31, 0xFF	; 255
    3432:	80 81       	ld	r24, Z
    3434:	91 81       	ldd	r25, Z+1	; 0x01
    3436:	01 97       	sbiw	r24, 0x01	; 1
    3438:	f1 f7       	brne	.-4      	; 0x3436 <LCD_voidInitial+0xfc>
    343a:	fe 01       	movw	r30, r28
    343c:	ef 5b       	subi	r30, 0xBF	; 191
    343e:	ff 4f       	sbci	r31, 0xFF	; 255
    3440:	91 83       	std	Z+1, r25	; 0x01
    3442:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3444:	de 01       	movw	r26, r28
    3446:	ad 5b       	subi	r26, 0xBD	; 189
    3448:	bf 4f       	sbci	r27, 0xFF	; 255
    344a:	fe 01       	movw	r30, r28
    344c:	ed 5b       	subi	r30, 0xBD	; 189
    344e:	ff 4f       	sbci	r31, 0xFF	; 255
    3450:	80 81       	ld	r24, Z
    3452:	91 81       	ldd	r25, Z+1	; 0x01
    3454:	01 97       	sbiw	r24, 0x01	; 1
    3456:	11 96       	adiw	r26, 0x01	; 1
    3458:	9c 93       	st	X, r25
    345a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    345c:	fe 01       	movw	r30, r28
    345e:	ed 5b       	subi	r30, 0xBD	; 189
    3460:	ff 4f       	sbci	r31, 0xFF	; 255
    3462:	80 81       	ld	r24, Z
    3464:	91 81       	ldd	r25, Z+1	; 0x01
    3466:	00 97       	sbiw	r24, 0x00	; 0
    3468:	d1 f6       	brne	.-76     	; 0x341e <LCD_voidInitial+0xe4>
    346a:	24 c0       	rjmp	.+72     	; 0x34b4 <LCD_voidInitial+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    346c:	8e 01       	movw	r16, r28
    346e:	0d 5b       	subi	r16, 0xBD	; 189
    3470:	1f 4f       	sbci	r17, 0xFF	; 255
    3472:	fe 01       	movw	r30, r28
    3474:	eb 5b       	subi	r30, 0xBB	; 187
    3476:	ff 4f       	sbci	r31, 0xFF	; 255
    3478:	60 81       	ld	r22, Z
    347a:	71 81       	ldd	r23, Z+1	; 0x01
    347c:	82 81       	ldd	r24, Z+2	; 0x02
    347e:	93 81       	ldd	r25, Z+3	; 0x03
    3480:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3484:	dc 01       	movw	r26, r24
    3486:	cb 01       	movw	r24, r22
    3488:	f8 01       	movw	r30, r16
    348a:	91 83       	std	Z+1, r25	; 0x01
    348c:	80 83       	st	Z, r24
    348e:	fe 01       	movw	r30, r28
    3490:	ed 5b       	subi	r30, 0xBD	; 189
    3492:	ff 4f       	sbci	r31, 0xFF	; 255
    3494:	80 81       	ld	r24, Z
    3496:	91 81       	ldd	r25, Z+1	; 0x01
    3498:	fe 01       	movw	r30, r28
    349a:	ff 96       	adiw	r30, 0x3f	; 63
    349c:	91 83       	std	Z+1, r25	; 0x01
    349e:	80 83       	st	Z, r24
    34a0:	fe 01       	movw	r30, r28
    34a2:	ff 96       	adiw	r30, 0x3f	; 63
    34a4:	80 81       	ld	r24, Z
    34a6:	91 81       	ldd	r25, Z+1	; 0x01
    34a8:	01 97       	sbiw	r24, 0x01	; 1
    34aa:	f1 f7       	brne	.-4      	; 0x34a8 <LCD_voidInitial+0x16e>
    34ac:	fe 01       	movw	r30, r28
    34ae:	ff 96       	adiw	r30, 0x3f	; 63
    34b0:	91 83       	std	Z+1, r25	; 0x01
    34b2:	80 83       	st	Z, r24
		_delay_ms(35);
		LCD_voidSendCommend(0b0000111000);
    34b4:	88 e3       	ldi	r24, 0x38	; 56
    34b6:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
    34ba:	80 e0       	ldi	r24, 0x00	; 0
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	a0 e2       	ldi	r26, 0x20	; 32
    34c0:	b2 e4       	ldi	r27, 0x42	; 66
    34c2:	8b af       	std	Y+59, r24	; 0x3b
    34c4:	9c af       	std	Y+60, r25	; 0x3c
    34c6:	ad af       	std	Y+61, r26	; 0x3d
    34c8:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    34ca:	6b ad       	ldd	r22, Y+59	; 0x3b
    34cc:	7c ad       	ldd	r23, Y+60	; 0x3c
    34ce:	8d ad       	ldd	r24, Y+61	; 0x3d
    34d0:	9e ad       	ldd	r25, Y+62	; 0x3e
    34d2:	2b ea       	ldi	r18, 0xAB	; 171
    34d4:	3a ea       	ldi	r19, 0xAA	; 170
    34d6:	4a e2       	ldi	r20, 0x2A	; 42
    34d8:	50 e4       	ldi	r21, 0x40	; 64
    34da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    34de:	dc 01       	movw	r26, r24
    34e0:	cb 01       	movw	r24, r22
    34e2:	8f ab       	std	Y+55, r24	; 0x37
    34e4:	98 af       	std	Y+56, r25	; 0x38
    34e6:	a9 af       	std	Y+57, r26	; 0x39
    34e8:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    34ea:	6f a9       	ldd	r22, Y+55	; 0x37
    34ec:	78 ad       	ldd	r23, Y+56	; 0x38
    34ee:	89 ad       	ldd	r24, Y+57	; 0x39
    34f0:	9a ad       	ldd	r25, Y+58	; 0x3a
    34f2:	20 e0       	ldi	r18, 0x00	; 0
    34f4:	30 e0       	ldi	r19, 0x00	; 0
    34f6:	40 e8       	ldi	r20, 0x80	; 128
    34f8:	5f e3       	ldi	r21, 0x3F	; 63
    34fa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    34fe:	88 23       	and	r24, r24
    3500:	1c f4       	brge	.+6      	; 0x3508 <LCD_voidInitial+0x1ce>
		__ticks = 1;
    3502:	81 e0       	ldi	r24, 0x01	; 1
    3504:	8e ab       	std	Y+54, r24	; 0x36
    3506:	91 c0       	rjmp	.+290    	; 0x362a <LCD_voidInitial+0x2f0>
	else if (__tmp > 255)
    3508:	6f a9       	ldd	r22, Y+55	; 0x37
    350a:	78 ad       	ldd	r23, Y+56	; 0x38
    350c:	89 ad       	ldd	r24, Y+57	; 0x39
    350e:	9a ad       	ldd	r25, Y+58	; 0x3a
    3510:	20 e0       	ldi	r18, 0x00	; 0
    3512:	30 e0       	ldi	r19, 0x00	; 0
    3514:	4f e7       	ldi	r20, 0x7F	; 127
    3516:	53 e4       	ldi	r21, 0x43	; 67
    3518:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    351c:	18 16       	cp	r1, r24
    351e:	0c f0       	brlt	.+2      	; 0x3522 <LCD_voidInitial+0x1e8>
    3520:	7b c0       	rjmp	.+246    	; 0x3618 <LCD_voidInitial+0x2de>
	{
		_delay_ms(__us / 1000.0);
    3522:	6b ad       	ldd	r22, Y+59	; 0x3b
    3524:	7c ad       	ldd	r23, Y+60	; 0x3c
    3526:	8d ad       	ldd	r24, Y+61	; 0x3d
    3528:	9e ad       	ldd	r25, Y+62	; 0x3e
    352a:	20 e0       	ldi	r18, 0x00	; 0
    352c:	30 e0       	ldi	r19, 0x00	; 0
    352e:	4a e7       	ldi	r20, 0x7A	; 122
    3530:	54 e4       	ldi	r21, 0x44	; 68
    3532:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3536:	dc 01       	movw	r26, r24
    3538:	cb 01       	movw	r24, r22
    353a:	8a ab       	std	Y+50, r24	; 0x32
    353c:	9b ab       	std	Y+51, r25	; 0x33
    353e:	ac ab       	std	Y+52, r26	; 0x34
    3540:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3542:	6a a9       	ldd	r22, Y+50	; 0x32
    3544:	7b a9       	ldd	r23, Y+51	; 0x33
    3546:	8c a9       	ldd	r24, Y+52	; 0x34
    3548:	9d a9       	ldd	r25, Y+53	; 0x35
    354a:	20 e0       	ldi	r18, 0x00	; 0
    354c:	30 e0       	ldi	r19, 0x00	; 0
    354e:	4a ef       	ldi	r20, 0xFA	; 250
    3550:	54 e4       	ldi	r21, 0x44	; 68
    3552:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3556:	dc 01       	movw	r26, r24
    3558:	cb 01       	movw	r24, r22
    355a:	8e a7       	std	Y+46, r24	; 0x2e
    355c:	9f a7       	std	Y+47, r25	; 0x2f
    355e:	a8 ab       	std	Y+48, r26	; 0x30
    3560:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    3562:	6e a5       	ldd	r22, Y+46	; 0x2e
    3564:	7f a5       	ldd	r23, Y+47	; 0x2f
    3566:	88 a9       	ldd	r24, Y+48	; 0x30
    3568:	99 a9       	ldd	r25, Y+49	; 0x31
    356a:	20 e0       	ldi	r18, 0x00	; 0
    356c:	30 e0       	ldi	r19, 0x00	; 0
    356e:	40 e8       	ldi	r20, 0x80	; 128
    3570:	5f e3       	ldi	r21, 0x3F	; 63
    3572:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3576:	88 23       	and	r24, r24
    3578:	2c f4       	brge	.+10     	; 0x3584 <LCD_voidInitial+0x24a>
		__ticks = 1;
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	9d a7       	std	Y+45, r25	; 0x2d
    3580:	8c a7       	std	Y+44, r24	; 0x2c
    3582:	3f c0       	rjmp	.+126    	; 0x3602 <LCD_voidInitial+0x2c8>
	else if (__tmp > 65535)
    3584:	6e a5       	ldd	r22, Y+46	; 0x2e
    3586:	7f a5       	ldd	r23, Y+47	; 0x2f
    3588:	88 a9       	ldd	r24, Y+48	; 0x30
    358a:	99 a9       	ldd	r25, Y+49	; 0x31
    358c:	20 e0       	ldi	r18, 0x00	; 0
    358e:	3f ef       	ldi	r19, 0xFF	; 255
    3590:	4f e7       	ldi	r20, 0x7F	; 127
    3592:	57 e4       	ldi	r21, 0x47	; 71
    3594:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3598:	18 16       	cp	r1, r24
    359a:	4c f5       	brge	.+82     	; 0x35ee <LCD_voidInitial+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    359c:	6a a9       	ldd	r22, Y+50	; 0x32
    359e:	7b a9       	ldd	r23, Y+51	; 0x33
    35a0:	8c a9       	ldd	r24, Y+52	; 0x34
    35a2:	9d a9       	ldd	r25, Y+53	; 0x35
    35a4:	20 e0       	ldi	r18, 0x00	; 0
    35a6:	30 e0       	ldi	r19, 0x00	; 0
    35a8:	40 e2       	ldi	r20, 0x20	; 32
    35aa:	51 e4       	ldi	r21, 0x41	; 65
    35ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35b0:	dc 01       	movw	r26, r24
    35b2:	cb 01       	movw	r24, r22
    35b4:	bc 01       	movw	r22, r24
    35b6:	cd 01       	movw	r24, r26
    35b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35bc:	dc 01       	movw	r26, r24
    35be:	cb 01       	movw	r24, r22
    35c0:	9d a7       	std	Y+45, r25	; 0x2d
    35c2:	8c a7       	std	Y+44, r24	; 0x2c
    35c4:	0f c0       	rjmp	.+30     	; 0x35e4 <LCD_voidInitial+0x2aa>
    35c6:	88 ec       	ldi	r24, 0xC8	; 200
    35c8:	90 e0       	ldi	r25, 0x00	; 0
    35ca:	9b a7       	std	Y+43, r25	; 0x2b
    35cc:	8a a7       	std	Y+42, r24	; 0x2a
    35ce:	8a a5       	ldd	r24, Y+42	; 0x2a
    35d0:	9b a5       	ldd	r25, Y+43	; 0x2b
    35d2:	01 97       	sbiw	r24, 0x01	; 1
    35d4:	f1 f7       	brne	.-4      	; 0x35d2 <LCD_voidInitial+0x298>
    35d6:	9b a7       	std	Y+43, r25	; 0x2b
    35d8:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35da:	8c a5       	ldd	r24, Y+44	; 0x2c
    35dc:	9d a5       	ldd	r25, Y+45	; 0x2d
    35de:	01 97       	sbiw	r24, 0x01	; 1
    35e0:	9d a7       	std	Y+45, r25	; 0x2d
    35e2:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35e4:	8c a5       	ldd	r24, Y+44	; 0x2c
    35e6:	9d a5       	ldd	r25, Y+45	; 0x2d
    35e8:	00 97       	sbiw	r24, 0x00	; 0
    35ea:	69 f7       	brne	.-38     	; 0x35c6 <LCD_voidInitial+0x28c>
    35ec:	24 c0       	rjmp	.+72     	; 0x3636 <LCD_voidInitial+0x2fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35ee:	6e a5       	ldd	r22, Y+46	; 0x2e
    35f0:	7f a5       	ldd	r23, Y+47	; 0x2f
    35f2:	88 a9       	ldd	r24, Y+48	; 0x30
    35f4:	99 a9       	ldd	r25, Y+49	; 0x31
    35f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35fa:	dc 01       	movw	r26, r24
    35fc:	cb 01       	movw	r24, r22
    35fe:	9d a7       	std	Y+45, r25	; 0x2d
    3600:	8c a7       	std	Y+44, r24	; 0x2c
    3602:	8c a5       	ldd	r24, Y+44	; 0x2c
    3604:	9d a5       	ldd	r25, Y+45	; 0x2d
    3606:	99 a7       	std	Y+41, r25	; 0x29
    3608:	88 a7       	std	Y+40, r24	; 0x28
    360a:	88 a5       	ldd	r24, Y+40	; 0x28
    360c:	99 a5       	ldd	r25, Y+41	; 0x29
    360e:	01 97       	sbiw	r24, 0x01	; 1
    3610:	f1 f7       	brne	.-4      	; 0x360e <LCD_voidInitial+0x2d4>
    3612:	99 a7       	std	Y+41, r25	; 0x29
    3614:	88 a7       	std	Y+40, r24	; 0x28
    3616:	0f c0       	rjmp	.+30     	; 0x3636 <LCD_voidInitial+0x2fc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3618:	6f a9       	ldd	r22, Y+55	; 0x37
    361a:	78 ad       	ldd	r23, Y+56	; 0x38
    361c:	89 ad       	ldd	r24, Y+57	; 0x39
    361e:	9a ad       	ldd	r25, Y+58	; 0x3a
    3620:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3624:	dc 01       	movw	r26, r24
    3626:	cb 01       	movw	r24, r22
    3628:	8e ab       	std	Y+54, r24	; 0x36
    362a:	8e a9       	ldd	r24, Y+54	; 0x36
    362c:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    362e:	8f a1       	ldd	r24, Y+39	; 0x27
    3630:	8a 95       	dec	r24
    3632:	f1 f7       	brne	.-4      	; 0x3630 <LCD_voidInitial+0x2f6>
    3634:	8f a3       	std	Y+39, r24	; 0x27
		_delay_us(40);
		LCD_voidSendCommend(0b0000001111);
    3636:	8f e0       	ldi	r24, 0x0F	; 15
    3638:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
    363c:	80 e0       	ldi	r24, 0x00	; 0
    363e:	90 e0       	ldi	r25, 0x00	; 0
    3640:	a0 e2       	ldi	r26, 0x20	; 32
    3642:	b2 e4       	ldi	r27, 0x42	; 66
    3644:	8b a3       	std	Y+35, r24	; 0x23
    3646:	9c a3       	std	Y+36, r25	; 0x24
    3648:	ad a3       	std	Y+37, r26	; 0x25
    364a:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    364c:	6b a1       	ldd	r22, Y+35	; 0x23
    364e:	7c a1       	ldd	r23, Y+36	; 0x24
    3650:	8d a1       	ldd	r24, Y+37	; 0x25
    3652:	9e a1       	ldd	r25, Y+38	; 0x26
    3654:	2b ea       	ldi	r18, 0xAB	; 171
    3656:	3a ea       	ldi	r19, 0xAA	; 170
    3658:	4a e2       	ldi	r20, 0x2A	; 42
    365a:	50 e4       	ldi	r21, 0x40	; 64
    365c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3660:	dc 01       	movw	r26, r24
    3662:	cb 01       	movw	r24, r22
    3664:	8f 8f       	std	Y+31, r24	; 0x1f
    3666:	98 a3       	std	Y+32, r25	; 0x20
    3668:	a9 a3       	std	Y+33, r26	; 0x21
    366a:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    366c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    366e:	78 a1       	ldd	r23, Y+32	; 0x20
    3670:	89 a1       	ldd	r24, Y+33	; 0x21
    3672:	9a a1       	ldd	r25, Y+34	; 0x22
    3674:	20 e0       	ldi	r18, 0x00	; 0
    3676:	30 e0       	ldi	r19, 0x00	; 0
    3678:	40 e8       	ldi	r20, 0x80	; 128
    367a:	5f e3       	ldi	r21, 0x3F	; 63
    367c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3680:	88 23       	and	r24, r24
    3682:	1c f4       	brge	.+6      	; 0x368a <LCD_voidInitial+0x350>
		__ticks = 1;
    3684:	81 e0       	ldi	r24, 0x01	; 1
    3686:	8e 8f       	std	Y+30, r24	; 0x1e
    3688:	91 c0       	rjmp	.+290    	; 0x37ac <LCD_voidInitial+0x472>
	else if (__tmp > 255)
    368a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    368c:	78 a1       	ldd	r23, Y+32	; 0x20
    368e:	89 a1       	ldd	r24, Y+33	; 0x21
    3690:	9a a1       	ldd	r25, Y+34	; 0x22
    3692:	20 e0       	ldi	r18, 0x00	; 0
    3694:	30 e0       	ldi	r19, 0x00	; 0
    3696:	4f e7       	ldi	r20, 0x7F	; 127
    3698:	53 e4       	ldi	r21, 0x43	; 67
    369a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    369e:	18 16       	cp	r1, r24
    36a0:	0c f0       	brlt	.+2      	; 0x36a4 <LCD_voidInitial+0x36a>
    36a2:	7b c0       	rjmp	.+246    	; 0x379a <LCD_voidInitial+0x460>
	{
		_delay_ms(__us / 1000.0);
    36a4:	6b a1       	ldd	r22, Y+35	; 0x23
    36a6:	7c a1       	ldd	r23, Y+36	; 0x24
    36a8:	8d a1       	ldd	r24, Y+37	; 0x25
    36aa:	9e a1       	ldd	r25, Y+38	; 0x26
    36ac:	20 e0       	ldi	r18, 0x00	; 0
    36ae:	30 e0       	ldi	r19, 0x00	; 0
    36b0:	4a e7       	ldi	r20, 0x7A	; 122
    36b2:	54 e4       	ldi	r21, 0x44	; 68
    36b4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    36b8:	dc 01       	movw	r26, r24
    36ba:	cb 01       	movw	r24, r22
    36bc:	8a 8f       	std	Y+26, r24	; 0x1a
    36be:	9b 8f       	std	Y+27, r25	; 0x1b
    36c0:	ac 8f       	std	Y+28, r26	; 0x1c
    36c2:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36c4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    36c6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    36c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    36ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    36cc:	20 e0       	ldi	r18, 0x00	; 0
    36ce:	30 e0       	ldi	r19, 0x00	; 0
    36d0:	4a ef       	ldi	r20, 0xFA	; 250
    36d2:	54 e4       	ldi	r21, 0x44	; 68
    36d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36d8:	dc 01       	movw	r26, r24
    36da:	cb 01       	movw	r24, r22
    36dc:	8e 8b       	std	Y+22, r24	; 0x16
    36de:	9f 8b       	std	Y+23, r25	; 0x17
    36e0:	a8 8f       	std	Y+24, r26	; 0x18
    36e2:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    36e4:	6e 89       	ldd	r22, Y+22	; 0x16
    36e6:	7f 89       	ldd	r23, Y+23	; 0x17
    36e8:	88 8d       	ldd	r24, Y+24	; 0x18
    36ea:	99 8d       	ldd	r25, Y+25	; 0x19
    36ec:	20 e0       	ldi	r18, 0x00	; 0
    36ee:	30 e0       	ldi	r19, 0x00	; 0
    36f0:	40 e8       	ldi	r20, 0x80	; 128
    36f2:	5f e3       	ldi	r21, 0x3F	; 63
    36f4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    36f8:	88 23       	and	r24, r24
    36fa:	2c f4       	brge	.+10     	; 0x3706 <LCD_voidInitial+0x3cc>
		__ticks = 1;
    36fc:	81 e0       	ldi	r24, 0x01	; 1
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	9d 8b       	std	Y+21, r25	; 0x15
    3702:	8c 8b       	std	Y+20, r24	; 0x14
    3704:	3f c0       	rjmp	.+126    	; 0x3784 <LCD_voidInitial+0x44a>
	else if (__tmp > 65535)
    3706:	6e 89       	ldd	r22, Y+22	; 0x16
    3708:	7f 89       	ldd	r23, Y+23	; 0x17
    370a:	88 8d       	ldd	r24, Y+24	; 0x18
    370c:	99 8d       	ldd	r25, Y+25	; 0x19
    370e:	20 e0       	ldi	r18, 0x00	; 0
    3710:	3f ef       	ldi	r19, 0xFF	; 255
    3712:	4f e7       	ldi	r20, 0x7F	; 127
    3714:	57 e4       	ldi	r21, 0x47	; 71
    3716:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    371a:	18 16       	cp	r1, r24
    371c:	4c f5       	brge	.+82     	; 0x3770 <LCD_voidInitial+0x436>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    371e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3720:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3722:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3724:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3726:	20 e0       	ldi	r18, 0x00	; 0
    3728:	30 e0       	ldi	r19, 0x00	; 0
    372a:	40 e2       	ldi	r20, 0x20	; 32
    372c:	51 e4       	ldi	r21, 0x41	; 65
    372e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3732:	dc 01       	movw	r26, r24
    3734:	cb 01       	movw	r24, r22
    3736:	bc 01       	movw	r22, r24
    3738:	cd 01       	movw	r24, r26
    373a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    373e:	dc 01       	movw	r26, r24
    3740:	cb 01       	movw	r24, r22
    3742:	9d 8b       	std	Y+21, r25	; 0x15
    3744:	8c 8b       	std	Y+20, r24	; 0x14
    3746:	0f c0       	rjmp	.+30     	; 0x3766 <LCD_voidInitial+0x42c>
    3748:	88 ec       	ldi	r24, 0xC8	; 200
    374a:	90 e0       	ldi	r25, 0x00	; 0
    374c:	9b 8b       	std	Y+19, r25	; 0x13
    374e:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3750:	8a 89       	ldd	r24, Y+18	; 0x12
    3752:	9b 89       	ldd	r25, Y+19	; 0x13
    3754:	01 97       	sbiw	r24, 0x01	; 1
    3756:	f1 f7       	brne	.-4      	; 0x3754 <LCD_voidInitial+0x41a>
    3758:	9b 8b       	std	Y+19, r25	; 0x13
    375a:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    375c:	8c 89       	ldd	r24, Y+20	; 0x14
    375e:	9d 89       	ldd	r25, Y+21	; 0x15
    3760:	01 97       	sbiw	r24, 0x01	; 1
    3762:	9d 8b       	std	Y+21, r25	; 0x15
    3764:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3766:	8c 89       	ldd	r24, Y+20	; 0x14
    3768:	9d 89       	ldd	r25, Y+21	; 0x15
    376a:	00 97       	sbiw	r24, 0x00	; 0
    376c:	69 f7       	brne	.-38     	; 0x3748 <LCD_voidInitial+0x40e>
    376e:	24 c0       	rjmp	.+72     	; 0x37b8 <LCD_voidInitial+0x47e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3770:	6e 89       	ldd	r22, Y+22	; 0x16
    3772:	7f 89       	ldd	r23, Y+23	; 0x17
    3774:	88 8d       	ldd	r24, Y+24	; 0x18
    3776:	99 8d       	ldd	r25, Y+25	; 0x19
    3778:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    377c:	dc 01       	movw	r26, r24
    377e:	cb 01       	movw	r24, r22
    3780:	9d 8b       	std	Y+21, r25	; 0x15
    3782:	8c 8b       	std	Y+20, r24	; 0x14
    3784:	8c 89       	ldd	r24, Y+20	; 0x14
    3786:	9d 89       	ldd	r25, Y+21	; 0x15
    3788:	99 8b       	std	Y+17, r25	; 0x11
    378a:	88 8b       	std	Y+16, r24	; 0x10
    378c:	88 89       	ldd	r24, Y+16	; 0x10
    378e:	99 89       	ldd	r25, Y+17	; 0x11
    3790:	01 97       	sbiw	r24, 0x01	; 1
    3792:	f1 f7       	brne	.-4      	; 0x3790 <LCD_voidInitial+0x456>
    3794:	99 8b       	std	Y+17, r25	; 0x11
    3796:	88 8b       	std	Y+16, r24	; 0x10
    3798:	0f c0       	rjmp	.+30     	; 0x37b8 <LCD_voidInitial+0x47e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    379a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    379c:	78 a1       	ldd	r23, Y+32	; 0x20
    379e:	89 a1       	ldd	r24, Y+33	; 0x21
    37a0:	9a a1       	ldd	r25, Y+34	; 0x22
    37a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37a6:	dc 01       	movw	r26, r24
    37a8:	cb 01       	movw	r24, r22
    37aa:	8e 8f       	std	Y+30, r24	; 0x1e
    37ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    37ae:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    37b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    37b2:	8a 95       	dec	r24
    37b4:	f1 f7       	brne	.-4      	; 0x37b2 <LCD_voidInitial+0x478>
    37b6:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_us(40);
		LCD_voidSendCommend(0b0000000001);
    37b8:	81 e0       	ldi	r24, 0x01	; 1
    37ba:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
    37be:	80 e0       	ldi	r24, 0x00	; 0
    37c0:	90 e0       	ldi	r25, 0x00	; 0
    37c2:	a0 e0       	ldi	r26, 0x00	; 0
    37c4:	b0 e4       	ldi	r27, 0x40	; 64
    37c6:	8b 87       	std	Y+11, r24	; 0x0b
    37c8:	9c 87       	std	Y+12, r25	; 0x0c
    37ca:	ad 87       	std	Y+13, r26	; 0x0d
    37cc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37ce:	6b 85       	ldd	r22, Y+11	; 0x0b
    37d0:	7c 85       	ldd	r23, Y+12	; 0x0c
    37d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    37d4:	9e 85       	ldd	r25, Y+14	; 0x0e
    37d6:	20 e0       	ldi	r18, 0x00	; 0
    37d8:	30 e0       	ldi	r19, 0x00	; 0
    37da:	4a ef       	ldi	r20, 0xFA	; 250
    37dc:	54 e4       	ldi	r21, 0x44	; 68
    37de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    37e2:	dc 01       	movw	r26, r24
    37e4:	cb 01       	movw	r24, r22
    37e6:	8f 83       	std	Y+7, r24	; 0x07
    37e8:	98 87       	std	Y+8, r25	; 0x08
    37ea:	a9 87       	std	Y+9, r26	; 0x09
    37ec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    37ee:	6f 81       	ldd	r22, Y+7	; 0x07
    37f0:	78 85       	ldd	r23, Y+8	; 0x08
    37f2:	89 85       	ldd	r24, Y+9	; 0x09
    37f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    37f6:	20 e0       	ldi	r18, 0x00	; 0
    37f8:	30 e0       	ldi	r19, 0x00	; 0
    37fa:	40 e8       	ldi	r20, 0x80	; 128
    37fc:	5f e3       	ldi	r21, 0x3F	; 63
    37fe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3802:	88 23       	and	r24, r24
    3804:	2c f4       	brge	.+10     	; 0x3810 <LCD_voidInitial+0x4d6>
		__ticks = 1;
    3806:	81 e0       	ldi	r24, 0x01	; 1
    3808:	90 e0       	ldi	r25, 0x00	; 0
    380a:	9e 83       	std	Y+6, r25	; 0x06
    380c:	8d 83       	std	Y+5, r24	; 0x05
    380e:	3f c0       	rjmp	.+126    	; 0x388e <LCD_voidInitial+0x554>
	else if (__tmp > 65535)
    3810:	6f 81       	ldd	r22, Y+7	; 0x07
    3812:	78 85       	ldd	r23, Y+8	; 0x08
    3814:	89 85       	ldd	r24, Y+9	; 0x09
    3816:	9a 85       	ldd	r25, Y+10	; 0x0a
    3818:	20 e0       	ldi	r18, 0x00	; 0
    381a:	3f ef       	ldi	r19, 0xFF	; 255
    381c:	4f e7       	ldi	r20, 0x7F	; 127
    381e:	57 e4       	ldi	r21, 0x47	; 71
    3820:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3824:	18 16       	cp	r1, r24
    3826:	4c f5       	brge	.+82     	; 0x387a <LCD_voidInitial+0x540>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3828:	6b 85       	ldd	r22, Y+11	; 0x0b
    382a:	7c 85       	ldd	r23, Y+12	; 0x0c
    382c:	8d 85       	ldd	r24, Y+13	; 0x0d
    382e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3830:	20 e0       	ldi	r18, 0x00	; 0
    3832:	30 e0       	ldi	r19, 0x00	; 0
    3834:	40 e2       	ldi	r20, 0x20	; 32
    3836:	51 e4       	ldi	r21, 0x41	; 65
    3838:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    383c:	dc 01       	movw	r26, r24
    383e:	cb 01       	movw	r24, r22
    3840:	bc 01       	movw	r22, r24
    3842:	cd 01       	movw	r24, r26
    3844:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3848:	dc 01       	movw	r26, r24
    384a:	cb 01       	movw	r24, r22
    384c:	9e 83       	std	Y+6, r25	; 0x06
    384e:	8d 83       	std	Y+5, r24	; 0x05
    3850:	0f c0       	rjmp	.+30     	; 0x3870 <LCD_voidInitial+0x536>
    3852:	88 ec       	ldi	r24, 0xC8	; 200
    3854:	90 e0       	ldi	r25, 0x00	; 0
    3856:	9c 83       	std	Y+4, r25	; 0x04
    3858:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    385a:	8b 81       	ldd	r24, Y+3	; 0x03
    385c:	9c 81       	ldd	r25, Y+4	; 0x04
    385e:	01 97       	sbiw	r24, 0x01	; 1
    3860:	f1 f7       	brne	.-4      	; 0x385e <LCD_voidInitial+0x524>
    3862:	9c 83       	std	Y+4, r25	; 0x04
    3864:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3866:	8d 81       	ldd	r24, Y+5	; 0x05
    3868:	9e 81       	ldd	r25, Y+6	; 0x06
    386a:	01 97       	sbiw	r24, 0x01	; 1
    386c:	9e 83       	std	Y+6, r25	; 0x06
    386e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3870:	8d 81       	ldd	r24, Y+5	; 0x05
    3872:	9e 81       	ldd	r25, Y+6	; 0x06
    3874:	00 97       	sbiw	r24, 0x00	; 0
    3876:	69 f7       	brne	.-38     	; 0x3852 <LCD_voidInitial+0x518>
    3878:	14 c0       	rjmp	.+40     	; 0x38a2 <LCD_voidInitial+0x568>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    387a:	6f 81       	ldd	r22, Y+7	; 0x07
    387c:	78 85       	ldd	r23, Y+8	; 0x08
    387e:	89 85       	ldd	r24, Y+9	; 0x09
    3880:	9a 85       	ldd	r25, Y+10	; 0x0a
    3882:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3886:	dc 01       	movw	r26, r24
    3888:	cb 01       	movw	r24, r22
    388a:	9e 83       	std	Y+6, r25	; 0x06
    388c:	8d 83       	std	Y+5, r24	; 0x05
    388e:	8d 81       	ldd	r24, Y+5	; 0x05
    3890:	9e 81       	ldd	r25, Y+6	; 0x06
    3892:	9a 83       	std	Y+2, r25	; 0x02
    3894:	89 83       	std	Y+1, r24	; 0x01
    3896:	89 81       	ldd	r24, Y+1	; 0x01
    3898:	9a 81       	ldd	r25, Y+2	; 0x02
    389a:	01 97       	sbiw	r24, 0x01	; 1
    389c:	f1 f7       	brne	.-4      	; 0x389a <LCD_voidInitial+0x560>
    389e:	9a 83       	std	Y+2, r25	; 0x02
    38a0:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);
		LCD_voidSendCommend(0b0000000110);
    38a2:	86 e0       	ldi	r24, 0x06	; 6
    38a4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>

}
    38a8:	c4 5b       	subi	r28, 0xB4	; 180
    38aa:	df 4f       	sbci	r29, 0xFF	; 255
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	1f 91       	pop	r17
    38bc:	0f 91       	pop	r16
    38be:	08 95       	ret

000038c0 <LCD_voidSendCommend>:
void LCD_voidSendCommend(u8 Copy_u8Commend)
{
    38c0:	df 93       	push	r29
    38c2:	cf 93       	push	r28
    38c4:	cd b7       	in	r28, 0x3d	; 61
    38c6:	de b7       	in	r29, 0x3e	; 62
    38c8:	69 97       	sbiw	r28, 0x19	; 25
    38ca:	0f b6       	in	r0, 0x3f	; 63
    38cc:	f8 94       	cli
    38ce:	de bf       	out	0x3e, r29	; 62
    38d0:	0f be       	out	0x3f, r0	; 63
    38d2:	cd bf       	out	0x3d, r28	; 61
    38d4:	89 8f       	std	Y+25, r24	; 0x19
		/******RS = 0******/
		DIO_u8SetPinDirection(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RS_PIN ,DIO_u8_PIN_OUTPUT);
    38d6:	82 e0       	ldi	r24, 0x02	; 2
    38d8:	60 e0       	ldi	r22, 0x00	; 0
    38da:	41 e0       	ldi	r20, 0x01	; 1
    38dc:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RS_PIN ,DIO_u8_PIN_LOW);
    38e0:	82 e0       	ldi	r24, 0x02	; 2
    38e2:	60 e0       	ldi	r22, 0x00	; 0
    38e4:	40 e0       	ldi	r20, 0x00	; 0
    38e6:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
		/*****RW =0*******/
		DIO_u8SetPinDirection(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RW_PIN ,DIO_u8_PIN_OUTPUT);
    38ea:	82 e0       	ldi	r24, 0x02	; 2
    38ec:	61 e0       	ldi	r22, 0x01	; 1
    38ee:	41 e0       	ldi	r20, 0x01	; 1
    38f0:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RW_PIN ,DIO_u8_PIN_LOW);
    38f4:	82 e0       	ldi	r24, 0x02	; 2
    38f6:	61 e0       	ldi	r22, 0x01	; 1
    38f8:	40 e0       	ldi	r20, 0x00	; 0
    38fa:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
		/*****Send Command byte to data pin******/
		DIO_u8SetPortDirection(LCD_u8_DATA_PINS_INITIAL_PORT,DIO_u8_PORT_OUTPUT);
    38fe:	81 e0       	ldi	r24, 0x01	; 1
    3900:	6f ef       	ldi	r22, 0xFF	; 255
    3902:	0e 94 18 24 	call	0x4830	; 0x4830 <DIO_u8SetPortDirection>
		DIO_u8SetPortValue(LCD_u8_DATA_PINS_INITIAL_PORT,Copy_u8Commend);
    3906:	81 e0       	ldi	r24, 0x01	; 1
    3908:	69 8d       	ldd	r22, Y+25	; 0x19
    390a:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
		/*******SEND PULSE ON ENABLE PIN****/
		DIO_u8SetPinDirection(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_E_PIN ,DIO_u8_PIN_OUTPUT);
    390e:	82 e0       	ldi	r24, 0x02	; 2
    3910:	62 e0       	ldi	r22, 0x02	; 2
    3912:	41 e0       	ldi	r20, 0x01	; 1
    3914:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_E_PIN ,DIO_u8_PIN_HIGH);
    3918:	82 e0       	ldi	r24, 0x02	; 2
    391a:	62 e0       	ldi	r22, 0x02	; 2
    391c:	41 e0       	ldi	r20, 0x01	; 1
    391e:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
    3922:	80 e0       	ldi	r24, 0x00	; 0
    3924:	90 e0       	ldi	r25, 0x00	; 0
    3926:	a0 e8       	ldi	r26, 0x80	; 128
    3928:	bf e3       	ldi	r27, 0x3F	; 63
    392a:	8d 8b       	std	Y+21, r24	; 0x15
    392c:	9e 8b       	std	Y+22, r25	; 0x16
    392e:	af 8b       	std	Y+23, r26	; 0x17
    3930:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3932:	6d 89       	ldd	r22, Y+21	; 0x15
    3934:	7e 89       	ldd	r23, Y+22	; 0x16
    3936:	8f 89       	ldd	r24, Y+23	; 0x17
    3938:	98 8d       	ldd	r25, Y+24	; 0x18
    393a:	2b ea       	ldi	r18, 0xAB	; 171
    393c:	3a ea       	ldi	r19, 0xAA	; 170
    393e:	4a e2       	ldi	r20, 0x2A	; 42
    3940:	50 e4       	ldi	r21, 0x40	; 64
    3942:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3946:	dc 01       	movw	r26, r24
    3948:	cb 01       	movw	r24, r22
    394a:	89 8b       	std	Y+17, r24	; 0x11
    394c:	9a 8b       	std	Y+18, r25	; 0x12
    394e:	ab 8b       	std	Y+19, r26	; 0x13
    3950:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3952:	69 89       	ldd	r22, Y+17	; 0x11
    3954:	7a 89       	ldd	r23, Y+18	; 0x12
    3956:	8b 89       	ldd	r24, Y+19	; 0x13
    3958:	9c 89       	ldd	r25, Y+20	; 0x14
    395a:	20 e0       	ldi	r18, 0x00	; 0
    395c:	30 e0       	ldi	r19, 0x00	; 0
    395e:	40 e8       	ldi	r20, 0x80	; 128
    3960:	5f e3       	ldi	r21, 0x3F	; 63
    3962:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3966:	88 23       	and	r24, r24
    3968:	1c f4       	brge	.+6      	; 0x3970 <LCD_voidSendCommend+0xb0>
		__ticks = 1;
    396a:	81 e0       	ldi	r24, 0x01	; 1
    396c:	88 8b       	std	Y+16, r24	; 0x10
    396e:	91 c0       	rjmp	.+290    	; 0x3a92 <LCD_voidSendCommend+0x1d2>
	else if (__tmp > 255)
    3970:	69 89       	ldd	r22, Y+17	; 0x11
    3972:	7a 89       	ldd	r23, Y+18	; 0x12
    3974:	8b 89       	ldd	r24, Y+19	; 0x13
    3976:	9c 89       	ldd	r25, Y+20	; 0x14
    3978:	20 e0       	ldi	r18, 0x00	; 0
    397a:	30 e0       	ldi	r19, 0x00	; 0
    397c:	4f e7       	ldi	r20, 0x7F	; 127
    397e:	53 e4       	ldi	r21, 0x43	; 67
    3980:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3984:	18 16       	cp	r1, r24
    3986:	0c f0       	brlt	.+2      	; 0x398a <LCD_voidSendCommend+0xca>
    3988:	7b c0       	rjmp	.+246    	; 0x3a80 <LCD_voidSendCommend+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    398a:	6d 89       	ldd	r22, Y+21	; 0x15
    398c:	7e 89       	ldd	r23, Y+22	; 0x16
    398e:	8f 89       	ldd	r24, Y+23	; 0x17
    3990:	98 8d       	ldd	r25, Y+24	; 0x18
    3992:	20 e0       	ldi	r18, 0x00	; 0
    3994:	30 e0       	ldi	r19, 0x00	; 0
    3996:	4a e7       	ldi	r20, 0x7A	; 122
    3998:	54 e4       	ldi	r21, 0x44	; 68
    399a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    399e:	dc 01       	movw	r26, r24
    39a0:	cb 01       	movw	r24, r22
    39a2:	8c 87       	std	Y+12, r24	; 0x0c
    39a4:	9d 87       	std	Y+13, r25	; 0x0d
    39a6:	ae 87       	std	Y+14, r26	; 0x0e
    39a8:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    39aa:	6c 85       	ldd	r22, Y+12	; 0x0c
    39ac:	7d 85       	ldd	r23, Y+13	; 0x0d
    39ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    39b0:	9f 85       	ldd	r25, Y+15	; 0x0f
    39b2:	20 e0       	ldi	r18, 0x00	; 0
    39b4:	30 e0       	ldi	r19, 0x00	; 0
    39b6:	4a ef       	ldi	r20, 0xFA	; 250
    39b8:	54 e4       	ldi	r21, 0x44	; 68
    39ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39be:	dc 01       	movw	r26, r24
    39c0:	cb 01       	movw	r24, r22
    39c2:	88 87       	std	Y+8, r24	; 0x08
    39c4:	99 87       	std	Y+9, r25	; 0x09
    39c6:	aa 87       	std	Y+10, r26	; 0x0a
    39c8:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    39ca:	68 85       	ldd	r22, Y+8	; 0x08
    39cc:	79 85       	ldd	r23, Y+9	; 0x09
    39ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    39d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    39d2:	20 e0       	ldi	r18, 0x00	; 0
    39d4:	30 e0       	ldi	r19, 0x00	; 0
    39d6:	40 e8       	ldi	r20, 0x80	; 128
    39d8:	5f e3       	ldi	r21, 0x3F	; 63
    39da:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    39de:	88 23       	and	r24, r24
    39e0:	2c f4       	brge	.+10     	; 0x39ec <LCD_voidSendCommend+0x12c>
		__ticks = 1;
    39e2:	81 e0       	ldi	r24, 0x01	; 1
    39e4:	90 e0       	ldi	r25, 0x00	; 0
    39e6:	9f 83       	std	Y+7, r25	; 0x07
    39e8:	8e 83       	std	Y+6, r24	; 0x06
    39ea:	3f c0       	rjmp	.+126    	; 0x3a6a <LCD_voidSendCommend+0x1aa>
	else if (__tmp > 65535)
    39ec:	68 85       	ldd	r22, Y+8	; 0x08
    39ee:	79 85       	ldd	r23, Y+9	; 0x09
    39f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    39f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    39f4:	20 e0       	ldi	r18, 0x00	; 0
    39f6:	3f ef       	ldi	r19, 0xFF	; 255
    39f8:	4f e7       	ldi	r20, 0x7F	; 127
    39fa:	57 e4       	ldi	r21, 0x47	; 71
    39fc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3a00:	18 16       	cp	r1, r24
    3a02:	4c f5       	brge	.+82     	; 0x3a56 <LCD_voidSendCommend+0x196>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3a04:	6c 85       	ldd	r22, Y+12	; 0x0c
    3a06:	7d 85       	ldd	r23, Y+13	; 0x0d
    3a08:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a0a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a0c:	20 e0       	ldi	r18, 0x00	; 0
    3a0e:	30 e0       	ldi	r19, 0x00	; 0
    3a10:	40 e2       	ldi	r20, 0x20	; 32
    3a12:	51 e4       	ldi	r21, 0x41	; 65
    3a14:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3a18:	dc 01       	movw	r26, r24
    3a1a:	cb 01       	movw	r24, r22
    3a1c:	bc 01       	movw	r22, r24
    3a1e:	cd 01       	movw	r24, r26
    3a20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a24:	dc 01       	movw	r26, r24
    3a26:	cb 01       	movw	r24, r22
    3a28:	9f 83       	std	Y+7, r25	; 0x07
    3a2a:	8e 83       	std	Y+6, r24	; 0x06
    3a2c:	0f c0       	rjmp	.+30     	; 0x3a4c <LCD_voidSendCommend+0x18c>
    3a2e:	88 ec       	ldi	r24, 0xC8	; 200
    3a30:	90 e0       	ldi	r25, 0x00	; 0
    3a32:	9d 83       	std	Y+5, r25	; 0x05
    3a34:	8c 83       	std	Y+4, r24	; 0x04
    3a36:	8c 81       	ldd	r24, Y+4	; 0x04
    3a38:	9d 81       	ldd	r25, Y+5	; 0x05
    3a3a:	01 97       	sbiw	r24, 0x01	; 1
    3a3c:	f1 f7       	brne	.-4      	; 0x3a3a <LCD_voidSendCommend+0x17a>
    3a3e:	9d 83       	std	Y+5, r25	; 0x05
    3a40:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3a42:	8e 81       	ldd	r24, Y+6	; 0x06
    3a44:	9f 81       	ldd	r25, Y+7	; 0x07
    3a46:	01 97       	sbiw	r24, 0x01	; 1
    3a48:	9f 83       	std	Y+7, r25	; 0x07
    3a4a:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3a4c:	8e 81       	ldd	r24, Y+6	; 0x06
    3a4e:	9f 81       	ldd	r25, Y+7	; 0x07
    3a50:	00 97       	sbiw	r24, 0x00	; 0
    3a52:	69 f7       	brne	.-38     	; 0x3a2e <LCD_voidSendCommend+0x16e>
    3a54:	24 c0       	rjmp	.+72     	; 0x3a9e <LCD_voidSendCommend+0x1de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a56:	68 85       	ldd	r22, Y+8	; 0x08
    3a58:	79 85       	ldd	r23, Y+9	; 0x09
    3a5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a5e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a62:	dc 01       	movw	r26, r24
    3a64:	cb 01       	movw	r24, r22
    3a66:	9f 83       	std	Y+7, r25	; 0x07
    3a68:	8e 83       	std	Y+6, r24	; 0x06
    3a6a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a6c:	9f 81       	ldd	r25, Y+7	; 0x07
    3a6e:	9b 83       	std	Y+3, r25	; 0x03
    3a70:	8a 83       	std	Y+2, r24	; 0x02
    3a72:	8a 81       	ldd	r24, Y+2	; 0x02
    3a74:	9b 81       	ldd	r25, Y+3	; 0x03
    3a76:	01 97       	sbiw	r24, 0x01	; 1
    3a78:	f1 f7       	brne	.-4      	; 0x3a76 <LCD_voidSendCommend+0x1b6>
    3a7a:	9b 83       	std	Y+3, r25	; 0x03
    3a7c:	8a 83       	std	Y+2, r24	; 0x02
    3a7e:	0f c0       	rjmp	.+30     	; 0x3a9e <LCD_voidSendCommend+0x1de>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3a80:	69 89       	ldd	r22, Y+17	; 0x11
    3a82:	7a 89       	ldd	r23, Y+18	; 0x12
    3a84:	8b 89       	ldd	r24, Y+19	; 0x13
    3a86:	9c 89       	ldd	r25, Y+20	; 0x14
    3a88:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a8c:	dc 01       	movw	r26, r24
    3a8e:	cb 01       	movw	r24, r22
    3a90:	88 8b       	std	Y+16, r24	; 0x10
    3a92:	88 89       	ldd	r24, Y+16	; 0x10
    3a94:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a96:	89 81       	ldd	r24, Y+1	; 0x01
    3a98:	8a 95       	dec	r24
    3a9a:	f1 f7       	brne	.-4      	; 0x3a98 <LCD_voidSendCommend+0x1d8>
    3a9c:	89 83       	std	Y+1, r24	; 0x01
		_delay_us(1);
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_E_PIN ,DIO_u8_PIN_LOW);
    3a9e:	82 e0       	ldi	r24, 0x02	; 2
    3aa0:	62 e0       	ldi	r22, 0x02	; 2
    3aa2:	40 e0       	ldi	r20, 0x00	; 0
    3aa4:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
}
    3aa8:	69 96       	adiw	r28, 0x19	; 25
    3aaa:	0f b6       	in	r0, 0x3f	; 63
    3aac:	f8 94       	cli
    3aae:	de bf       	out	0x3e, r29	; 62
    3ab0:	0f be       	out	0x3f, r0	; 63
    3ab2:	cd bf       	out	0x3d, r28	; 61
    3ab4:	cf 91       	pop	r28
    3ab6:	df 91       	pop	r29
    3ab8:	08 95       	ret

00003aba <LCD_voidSendChar>:
void LCD_voidSendChar(u8 Copy_u8Char)
{
    3aba:	df 93       	push	r29
    3abc:	cf 93       	push	r28
    3abe:	cd b7       	in	r28, 0x3d	; 61
    3ac0:	de b7       	in	r29, 0x3e	; 62
    3ac2:	69 97       	sbiw	r28, 0x19	; 25
    3ac4:	0f b6       	in	r0, 0x3f	; 63
    3ac6:	f8 94       	cli
    3ac8:	de bf       	out	0x3e, r29	; 62
    3aca:	0f be       	out	0x3f, r0	; 63
    3acc:	cd bf       	out	0x3d, r28	; 61
    3ace:	89 8f       	std	Y+25, r24	; 0x19
		/******RS = 1******/
		DIO_u8SetPinDirection(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RS_PIN ,DIO_u8_PIN_OUTPUT);
    3ad0:	82 e0       	ldi	r24, 0x02	; 2
    3ad2:	60 e0       	ldi	r22, 0x00	; 0
    3ad4:	41 e0       	ldi	r20, 0x01	; 1
    3ad6:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RS_PIN ,DIO_u8_PIN_HIGH);
    3ada:	82 e0       	ldi	r24, 0x02	; 2
    3adc:	60 e0       	ldi	r22, 0x00	; 0
    3ade:	41 e0       	ldi	r20, 0x01	; 1
    3ae0:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
		/*****RW =0*******/
		DIO_u8SetPinDirection(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RW_PIN ,DIO_u8_PIN_OUTPUT);
    3ae4:	82 e0       	ldi	r24, 0x02	; 2
    3ae6:	61 e0       	ldi	r22, 0x01	; 1
    3ae8:	41 e0       	ldi	r20, 0x01	; 1
    3aea:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_RW_PIN ,DIO_u8_PIN_LOW);
    3aee:	82 e0       	ldi	r24, 0x02	; 2
    3af0:	61 e0       	ldi	r22, 0x01	; 1
    3af2:	40 e0       	ldi	r20, 0x00	; 0
    3af4:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
		/*****Send Command byte to data pin******/
		DIO_u8SetPortDirection(LCD_u8_DATA_PINS_INITIAL_PORT,DIO_u8_PORT_OUTPUT);
    3af8:	81 e0       	ldi	r24, 0x01	; 1
    3afa:	6f ef       	ldi	r22, 0xFF	; 255
    3afc:	0e 94 18 24 	call	0x4830	; 0x4830 <DIO_u8SetPortDirection>
		DIO_u8SetPortValue(LCD_u8_DATA_PINS_INITIAL_PORT,Copy_u8Char);
    3b00:	81 e0       	ldi	r24, 0x01	; 1
    3b02:	69 8d       	ldd	r22, Y+25	; 0x19
    3b04:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
		/*******SEND PULSE ON ENABLE PIN****/
		DIO_u8SetPinDirection(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_E_PIN ,DIO_u8_PIN_OUTPUT);
    3b08:	82 e0       	ldi	r24, 0x02	; 2
    3b0a:	62 e0       	ldi	r22, 0x02	; 2
    3b0c:	41 e0       	ldi	r20, 0x01	; 1
    3b0e:	0e 94 48 21 	call	0x4290	; 0x4290 <DIO_u8SetPinDirection>
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_E_PIN ,DIO_u8_PIN_HIGH);
    3b12:	82 e0       	ldi	r24, 0x02	; 2
    3b14:	62 e0       	ldi	r22, 0x02	; 2
    3b16:	41 e0       	ldi	r20, 0x01	; 1
    3b18:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
    3b1c:	80 e0       	ldi	r24, 0x00	; 0
    3b1e:	90 e0       	ldi	r25, 0x00	; 0
    3b20:	a0 e8       	ldi	r26, 0x80	; 128
    3b22:	bf e3       	ldi	r27, 0x3F	; 63
    3b24:	8d 8b       	std	Y+21, r24	; 0x15
    3b26:	9e 8b       	std	Y+22, r25	; 0x16
    3b28:	af 8b       	std	Y+23, r26	; 0x17
    3b2a:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3b2c:	6d 89       	ldd	r22, Y+21	; 0x15
    3b2e:	7e 89       	ldd	r23, Y+22	; 0x16
    3b30:	8f 89       	ldd	r24, Y+23	; 0x17
    3b32:	98 8d       	ldd	r25, Y+24	; 0x18
    3b34:	2b ea       	ldi	r18, 0xAB	; 171
    3b36:	3a ea       	ldi	r19, 0xAA	; 170
    3b38:	4a e2       	ldi	r20, 0x2A	; 42
    3b3a:	50 e4       	ldi	r21, 0x40	; 64
    3b3c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b40:	dc 01       	movw	r26, r24
    3b42:	cb 01       	movw	r24, r22
    3b44:	89 8b       	std	Y+17, r24	; 0x11
    3b46:	9a 8b       	std	Y+18, r25	; 0x12
    3b48:	ab 8b       	std	Y+19, r26	; 0x13
    3b4a:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3b4c:	69 89       	ldd	r22, Y+17	; 0x11
    3b4e:	7a 89       	ldd	r23, Y+18	; 0x12
    3b50:	8b 89       	ldd	r24, Y+19	; 0x13
    3b52:	9c 89       	ldd	r25, Y+20	; 0x14
    3b54:	20 e0       	ldi	r18, 0x00	; 0
    3b56:	30 e0       	ldi	r19, 0x00	; 0
    3b58:	40 e8       	ldi	r20, 0x80	; 128
    3b5a:	5f e3       	ldi	r21, 0x3F	; 63
    3b5c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b60:	88 23       	and	r24, r24
    3b62:	1c f4       	brge	.+6      	; 0x3b6a <LCD_voidSendChar+0xb0>
		__ticks = 1;
    3b64:	81 e0       	ldi	r24, 0x01	; 1
    3b66:	88 8b       	std	Y+16, r24	; 0x10
    3b68:	91 c0       	rjmp	.+290    	; 0x3c8c <LCD_voidSendChar+0x1d2>
	else if (__tmp > 255)
    3b6a:	69 89       	ldd	r22, Y+17	; 0x11
    3b6c:	7a 89       	ldd	r23, Y+18	; 0x12
    3b6e:	8b 89       	ldd	r24, Y+19	; 0x13
    3b70:	9c 89       	ldd	r25, Y+20	; 0x14
    3b72:	20 e0       	ldi	r18, 0x00	; 0
    3b74:	30 e0       	ldi	r19, 0x00	; 0
    3b76:	4f e7       	ldi	r20, 0x7F	; 127
    3b78:	53 e4       	ldi	r21, 0x43	; 67
    3b7a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b7e:	18 16       	cp	r1, r24
    3b80:	0c f0       	brlt	.+2      	; 0x3b84 <LCD_voidSendChar+0xca>
    3b82:	7b c0       	rjmp	.+246    	; 0x3c7a <LCD_voidSendChar+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    3b84:	6d 89       	ldd	r22, Y+21	; 0x15
    3b86:	7e 89       	ldd	r23, Y+22	; 0x16
    3b88:	8f 89       	ldd	r24, Y+23	; 0x17
    3b8a:	98 8d       	ldd	r25, Y+24	; 0x18
    3b8c:	20 e0       	ldi	r18, 0x00	; 0
    3b8e:	30 e0       	ldi	r19, 0x00	; 0
    3b90:	4a e7       	ldi	r20, 0x7A	; 122
    3b92:	54 e4       	ldi	r21, 0x44	; 68
    3b94:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3b98:	dc 01       	movw	r26, r24
    3b9a:	cb 01       	movw	r24, r22
    3b9c:	8c 87       	std	Y+12, r24	; 0x0c
    3b9e:	9d 87       	std	Y+13, r25	; 0x0d
    3ba0:	ae 87       	std	Y+14, r26	; 0x0e
    3ba2:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3ba4:	6c 85       	ldd	r22, Y+12	; 0x0c
    3ba6:	7d 85       	ldd	r23, Y+13	; 0x0d
    3ba8:	8e 85       	ldd	r24, Y+14	; 0x0e
    3baa:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bac:	20 e0       	ldi	r18, 0x00	; 0
    3bae:	30 e0       	ldi	r19, 0x00	; 0
    3bb0:	4a ef       	ldi	r20, 0xFA	; 250
    3bb2:	54 e4       	ldi	r21, 0x44	; 68
    3bb4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3bb8:	dc 01       	movw	r26, r24
    3bba:	cb 01       	movw	r24, r22
    3bbc:	88 87       	std	Y+8, r24	; 0x08
    3bbe:	99 87       	std	Y+9, r25	; 0x09
    3bc0:	aa 87       	std	Y+10, r26	; 0x0a
    3bc2:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    3bc4:	68 85       	ldd	r22, Y+8	; 0x08
    3bc6:	79 85       	ldd	r23, Y+9	; 0x09
    3bc8:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bca:	9b 85       	ldd	r25, Y+11	; 0x0b
    3bcc:	20 e0       	ldi	r18, 0x00	; 0
    3bce:	30 e0       	ldi	r19, 0x00	; 0
    3bd0:	40 e8       	ldi	r20, 0x80	; 128
    3bd2:	5f e3       	ldi	r21, 0x3F	; 63
    3bd4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3bd8:	88 23       	and	r24, r24
    3bda:	2c f4       	brge	.+10     	; 0x3be6 <LCD_voidSendChar+0x12c>
		__ticks = 1;
    3bdc:	81 e0       	ldi	r24, 0x01	; 1
    3bde:	90 e0       	ldi	r25, 0x00	; 0
    3be0:	9f 83       	std	Y+7, r25	; 0x07
    3be2:	8e 83       	std	Y+6, r24	; 0x06
    3be4:	3f c0       	rjmp	.+126    	; 0x3c64 <LCD_voidSendChar+0x1aa>
	else if (__tmp > 65535)
    3be6:	68 85       	ldd	r22, Y+8	; 0x08
    3be8:	79 85       	ldd	r23, Y+9	; 0x09
    3bea:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bec:	9b 85       	ldd	r25, Y+11	; 0x0b
    3bee:	20 e0       	ldi	r18, 0x00	; 0
    3bf0:	3f ef       	ldi	r19, 0xFF	; 255
    3bf2:	4f e7       	ldi	r20, 0x7F	; 127
    3bf4:	57 e4       	ldi	r21, 0x47	; 71
    3bf6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3bfa:	18 16       	cp	r1, r24
    3bfc:	4c f5       	brge	.+82     	; 0x3c50 <LCD_voidSendChar+0x196>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bfe:	6c 85       	ldd	r22, Y+12	; 0x0c
    3c00:	7d 85       	ldd	r23, Y+13	; 0x0d
    3c02:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c04:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c06:	20 e0       	ldi	r18, 0x00	; 0
    3c08:	30 e0       	ldi	r19, 0x00	; 0
    3c0a:	40 e2       	ldi	r20, 0x20	; 32
    3c0c:	51 e4       	ldi	r21, 0x41	; 65
    3c0e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3c12:	dc 01       	movw	r26, r24
    3c14:	cb 01       	movw	r24, r22
    3c16:	bc 01       	movw	r22, r24
    3c18:	cd 01       	movw	r24, r26
    3c1a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c1e:	dc 01       	movw	r26, r24
    3c20:	cb 01       	movw	r24, r22
    3c22:	9f 83       	std	Y+7, r25	; 0x07
    3c24:	8e 83       	std	Y+6, r24	; 0x06
    3c26:	0f c0       	rjmp	.+30     	; 0x3c46 <LCD_voidSendChar+0x18c>
    3c28:	88 ec       	ldi	r24, 0xC8	; 200
    3c2a:	90 e0       	ldi	r25, 0x00	; 0
    3c2c:	9d 83       	std	Y+5, r25	; 0x05
    3c2e:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c30:	8c 81       	ldd	r24, Y+4	; 0x04
    3c32:	9d 81       	ldd	r25, Y+5	; 0x05
    3c34:	01 97       	sbiw	r24, 0x01	; 1
    3c36:	f1 f7       	brne	.-4      	; 0x3c34 <LCD_voidSendChar+0x17a>
    3c38:	9d 83       	std	Y+5, r25	; 0x05
    3c3a:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c3c:	8e 81       	ldd	r24, Y+6	; 0x06
    3c3e:	9f 81       	ldd	r25, Y+7	; 0x07
    3c40:	01 97       	sbiw	r24, 0x01	; 1
    3c42:	9f 83       	std	Y+7, r25	; 0x07
    3c44:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c46:	8e 81       	ldd	r24, Y+6	; 0x06
    3c48:	9f 81       	ldd	r25, Y+7	; 0x07
    3c4a:	00 97       	sbiw	r24, 0x00	; 0
    3c4c:	69 f7       	brne	.-38     	; 0x3c28 <LCD_voidSendChar+0x16e>
    3c4e:	24 c0       	rjmp	.+72     	; 0x3c98 <LCD_voidSendChar+0x1de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c50:	68 85       	ldd	r22, Y+8	; 0x08
    3c52:	79 85       	ldd	r23, Y+9	; 0x09
    3c54:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c56:	9b 85       	ldd	r25, Y+11	; 0x0b
    3c58:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c5c:	dc 01       	movw	r26, r24
    3c5e:	cb 01       	movw	r24, r22
    3c60:	9f 83       	std	Y+7, r25	; 0x07
    3c62:	8e 83       	std	Y+6, r24	; 0x06
    3c64:	8e 81       	ldd	r24, Y+6	; 0x06
    3c66:	9f 81       	ldd	r25, Y+7	; 0x07
    3c68:	9b 83       	std	Y+3, r25	; 0x03
    3c6a:	8a 83       	std	Y+2, r24	; 0x02
    3c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c6e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c70:	01 97       	sbiw	r24, 0x01	; 1
    3c72:	f1 f7       	brne	.-4      	; 0x3c70 <LCD_voidSendChar+0x1b6>
    3c74:	9b 83       	std	Y+3, r25	; 0x03
    3c76:	8a 83       	std	Y+2, r24	; 0x02
    3c78:	0f c0       	rjmp	.+30     	; 0x3c98 <LCD_voidSendChar+0x1de>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c7a:	69 89       	ldd	r22, Y+17	; 0x11
    3c7c:	7a 89       	ldd	r23, Y+18	; 0x12
    3c7e:	8b 89       	ldd	r24, Y+19	; 0x13
    3c80:	9c 89       	ldd	r25, Y+20	; 0x14
    3c82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c86:	dc 01       	movw	r26, r24
    3c88:	cb 01       	movw	r24, r22
    3c8a:	88 8b       	std	Y+16, r24	; 0x10
    3c8c:	88 89       	ldd	r24, Y+16	; 0x10
    3c8e:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3c90:	89 81       	ldd	r24, Y+1	; 0x01
    3c92:	8a 95       	dec	r24
    3c94:	f1 f7       	brne	.-4      	; 0x3c92 <LCD_voidSendChar+0x1d8>
    3c96:	89 83       	std	Y+1, r24	; 0x01
		_delay_us(1);
		DIO_u8SetPinValue(LCD_u8_CONTROL_PINS_INITIAL_PORT,LCD_u8_E_PIN ,DIO_u8_PIN_LOW);
    3c98:	82 e0       	ldi	r24, 0x02	; 2
    3c9a:	62 e0       	ldi	r22, 0x02	; 2
    3c9c:	40 e0       	ldi	r20, 0x00	; 0
    3c9e:	0e 94 6f 22 	call	0x44de	; 0x44de <DIO_u8SetPinValue>
}
    3ca2:	69 96       	adiw	r28, 0x19	; 25
    3ca4:	0f b6       	in	r0, 0x3f	; 63
    3ca6:	f8 94       	cli
    3ca8:	de bf       	out	0x3e, r29	; 62
    3caa:	0f be       	out	0x3f, r0	; 63
    3cac:	cd bf       	out	0x3d, r28	; 61
    3cae:	cf 91       	pop	r28
    3cb0:	df 91       	pop	r29
    3cb2:	08 95       	ret

00003cb4 <LCD_voidSendStr>:
void LCD_voidSendStr(u8 s[])
{
    3cb4:	df 93       	push	r29
    3cb6:	cf 93       	push	r28
    3cb8:	cd b7       	in	r28, 0x3d	; 61
    3cba:	de b7       	in	r29, 0x3e	; 62
    3cbc:	62 97       	sbiw	r28, 0x12	; 18
    3cbe:	0f b6       	in	r0, 0x3f	; 63
    3cc0:	f8 94       	cli
    3cc2:	de bf       	out	0x3e, r29	; 62
    3cc4:	0f be       	out	0x3f, r0	; 63
    3cc6:	cd bf       	out	0x3d, r28	; 61
    3cc8:	9a 8b       	std	Y+18, r25	; 0x12
    3cca:	89 8b       	std	Y+17, r24	; 0x11
		u8 i=0;
    3ccc:	18 8a       	std	Y+16, r1	; 0x10
		u8 size=strlen(s);
    3cce:	89 89       	ldd	r24, Y+17	; 0x11
    3cd0:	9a 89       	ldd	r25, Y+18	; 0x12
    3cd2:	0e 94 35 26 	call	0x4c6a	; 0x4c6a <strlen>
    3cd6:	8f 87       	std	Y+15, r24	; 0x0f
    3cd8:	80 c0       	rjmp	.+256    	; 0x3dda <LCD_voidSendStr+0x126>
		while(i<size)
			{
			    LCD_voidSendChar(s[i]);
    3cda:	88 89       	ldd	r24, Y+16	; 0x10
    3cdc:	28 2f       	mov	r18, r24
    3cde:	30 e0       	ldi	r19, 0x00	; 0
    3ce0:	89 89       	ldd	r24, Y+17	; 0x11
    3ce2:	9a 89       	ldd	r25, Y+18	; 0x12
    3ce4:	fc 01       	movw	r30, r24
    3ce6:	e2 0f       	add	r30, r18
    3ce8:	f3 1f       	adc	r31, r19
    3cea:	80 81       	ld	r24, Z
    3cec:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <LCD_voidSendChar>
				i++;
    3cf0:	88 89       	ldd	r24, Y+16	; 0x10
    3cf2:	8f 5f       	subi	r24, 0xFF	; 255
    3cf4:	88 8b       	std	Y+16, r24	; 0x10
    3cf6:	80 e0       	ldi	r24, 0x00	; 0
    3cf8:	90 e0       	ldi	r25, 0x00	; 0
    3cfa:	a0 e0       	ldi	r26, 0x00	; 0
    3cfc:	b0 e4       	ldi	r27, 0x40	; 64
    3cfe:	8b 87       	std	Y+11, r24	; 0x0b
    3d00:	9c 87       	std	Y+12, r25	; 0x0c
    3d02:	ad 87       	std	Y+13, r26	; 0x0d
    3d04:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d06:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d08:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d0a:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d0c:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d0e:	20 e0       	ldi	r18, 0x00	; 0
    3d10:	30 e0       	ldi	r19, 0x00	; 0
    3d12:	4a ef       	ldi	r20, 0xFA	; 250
    3d14:	54 e4       	ldi	r21, 0x44	; 68
    3d16:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d1a:	dc 01       	movw	r26, r24
    3d1c:	cb 01       	movw	r24, r22
    3d1e:	8f 83       	std	Y+7, r24	; 0x07
    3d20:	98 87       	std	Y+8, r25	; 0x08
    3d22:	a9 87       	std	Y+9, r26	; 0x09
    3d24:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3d26:	6f 81       	ldd	r22, Y+7	; 0x07
    3d28:	78 85       	ldd	r23, Y+8	; 0x08
    3d2a:	89 85       	ldd	r24, Y+9	; 0x09
    3d2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d2e:	20 e0       	ldi	r18, 0x00	; 0
    3d30:	30 e0       	ldi	r19, 0x00	; 0
    3d32:	40 e8       	ldi	r20, 0x80	; 128
    3d34:	5f e3       	ldi	r21, 0x3F	; 63
    3d36:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3d3a:	88 23       	and	r24, r24
    3d3c:	2c f4       	brge	.+10     	; 0x3d48 <LCD_voidSendStr+0x94>
		__ticks = 1;
    3d3e:	81 e0       	ldi	r24, 0x01	; 1
    3d40:	90 e0       	ldi	r25, 0x00	; 0
    3d42:	9e 83       	std	Y+6, r25	; 0x06
    3d44:	8d 83       	std	Y+5, r24	; 0x05
    3d46:	3f c0       	rjmp	.+126    	; 0x3dc6 <LCD_voidSendStr+0x112>
	else if (__tmp > 65535)
    3d48:	6f 81       	ldd	r22, Y+7	; 0x07
    3d4a:	78 85       	ldd	r23, Y+8	; 0x08
    3d4c:	89 85       	ldd	r24, Y+9	; 0x09
    3d4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d50:	20 e0       	ldi	r18, 0x00	; 0
    3d52:	3f ef       	ldi	r19, 0xFF	; 255
    3d54:	4f e7       	ldi	r20, 0x7F	; 127
    3d56:	57 e4       	ldi	r21, 0x47	; 71
    3d58:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3d5c:	18 16       	cp	r1, r24
    3d5e:	4c f5       	brge	.+82     	; 0x3db2 <LCD_voidSendStr+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d60:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d62:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d64:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d66:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d68:	20 e0       	ldi	r18, 0x00	; 0
    3d6a:	30 e0       	ldi	r19, 0x00	; 0
    3d6c:	40 e2       	ldi	r20, 0x20	; 32
    3d6e:	51 e4       	ldi	r21, 0x41	; 65
    3d70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d74:	dc 01       	movw	r26, r24
    3d76:	cb 01       	movw	r24, r22
    3d78:	bc 01       	movw	r22, r24
    3d7a:	cd 01       	movw	r24, r26
    3d7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d80:	dc 01       	movw	r26, r24
    3d82:	cb 01       	movw	r24, r22
    3d84:	9e 83       	std	Y+6, r25	; 0x06
    3d86:	8d 83       	std	Y+5, r24	; 0x05
    3d88:	0f c0       	rjmp	.+30     	; 0x3da8 <LCD_voidSendStr+0xf4>
    3d8a:	88 ec       	ldi	r24, 0xC8	; 200
    3d8c:	90 e0       	ldi	r25, 0x00	; 0
    3d8e:	9c 83       	std	Y+4, r25	; 0x04
    3d90:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3d92:	8b 81       	ldd	r24, Y+3	; 0x03
    3d94:	9c 81       	ldd	r25, Y+4	; 0x04
    3d96:	01 97       	sbiw	r24, 0x01	; 1
    3d98:	f1 f7       	brne	.-4      	; 0x3d96 <LCD_voidSendStr+0xe2>
    3d9a:	9c 83       	std	Y+4, r25	; 0x04
    3d9c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    3da0:	9e 81       	ldd	r25, Y+6	; 0x06
    3da2:	01 97       	sbiw	r24, 0x01	; 1
    3da4:	9e 83       	std	Y+6, r25	; 0x06
    3da6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3da8:	8d 81       	ldd	r24, Y+5	; 0x05
    3daa:	9e 81       	ldd	r25, Y+6	; 0x06
    3dac:	00 97       	sbiw	r24, 0x00	; 0
    3dae:	69 f7       	brne	.-38     	; 0x3d8a <LCD_voidSendStr+0xd6>
    3db0:	14 c0       	rjmp	.+40     	; 0x3dda <LCD_voidSendStr+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3db2:	6f 81       	ldd	r22, Y+7	; 0x07
    3db4:	78 85       	ldd	r23, Y+8	; 0x08
    3db6:	89 85       	ldd	r24, Y+9	; 0x09
    3db8:	9a 85       	ldd	r25, Y+10	; 0x0a
    3dba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3dbe:	dc 01       	movw	r26, r24
    3dc0:	cb 01       	movw	r24, r22
    3dc2:	9e 83       	std	Y+6, r25	; 0x06
    3dc4:	8d 83       	std	Y+5, r24	; 0x05
    3dc6:	8d 81       	ldd	r24, Y+5	; 0x05
    3dc8:	9e 81       	ldd	r25, Y+6	; 0x06
    3dca:	9a 83       	std	Y+2, r25	; 0x02
    3dcc:	89 83       	std	Y+1, r24	; 0x01
    3dce:	89 81       	ldd	r24, Y+1	; 0x01
    3dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3dd2:	01 97       	sbiw	r24, 0x01	; 1
    3dd4:	f1 f7       	brne	.-4      	; 0x3dd2 <LCD_voidSendStr+0x11e>
    3dd6:	9a 83       	std	Y+2, r25	; 0x02
    3dd8:	89 83       	std	Y+1, r24	; 0x01
}
void LCD_voidSendStr(u8 s[])
{
		u8 i=0;
		u8 size=strlen(s);
		while(i<size)
    3dda:	98 89       	ldd	r25, Y+16	; 0x10
    3ddc:	8f 85       	ldd	r24, Y+15	; 0x0f
    3dde:	98 17       	cp	r25, r24
    3de0:	08 f4       	brcc	.+2      	; 0x3de4 <LCD_voidSendStr+0x130>
    3de2:	7b cf       	rjmp	.-266    	; 0x3cda <LCD_voidSendStr+0x26>
			{
			    LCD_voidSendChar(s[i]);
				i++;
				_delay_ms(2);
			}
}
    3de4:	62 96       	adiw	r28, 0x12	; 18
    3de6:	0f b6       	in	r0, 0x3f	; 63
    3de8:	f8 94       	cli
    3dea:	de bf       	out	0x3e, r29	; 62
    3dec:	0f be       	out	0x3f, r0	; 63
    3dee:	cd bf       	out	0x3d, r28	; 61
    3df0:	cf 91       	pop	r28
    3df2:	df 91       	pop	r29
    3df4:	08 95       	ret

00003df6 <LCD_voidGoToXY>:
void LCD_voidGoToXY(u8 Copy_u8X,u8  Copy_u8Y)
{
    3df6:	df 93       	push	r29
    3df8:	cf 93       	push	r28
    3dfa:	00 d0       	rcall	.+0      	; 0x3dfc <LCD_voidGoToXY+0x6>
    3dfc:	00 d0       	rcall	.+0      	; 0x3dfe <LCD_voidGoToXY+0x8>
    3dfe:	cd b7       	in	r28, 0x3d	; 61
    3e00:	de b7       	in	r29, 0x3e	; 62
    3e02:	89 83       	std	Y+1, r24	; 0x01
    3e04:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8X)
    3e06:	89 81       	ldd	r24, Y+1	; 0x01
    3e08:	28 2f       	mov	r18, r24
    3e0a:	30 e0       	ldi	r19, 0x00	; 0
    3e0c:	3c 83       	std	Y+4, r19	; 0x04
    3e0e:	2b 83       	std	Y+3, r18	; 0x03
    3e10:	8b 81       	ldd	r24, Y+3	; 0x03
    3e12:	9c 81       	ldd	r25, Y+4	; 0x04
    3e14:	00 97       	sbiw	r24, 0x00	; 0
    3e16:	31 f0       	breq	.+12     	; 0x3e24 <LCD_voidGoToXY+0x2e>
    3e18:	2b 81       	ldd	r18, Y+3	; 0x03
    3e1a:	3c 81       	ldd	r19, Y+4	; 0x04
    3e1c:	21 30       	cpi	r18, 0x01	; 1
    3e1e:	31 05       	cpc	r19, r1
    3e20:	31 f0       	breq	.+12     	; 0x3e2e <LCD_voidGoToXY+0x38>
    3e22:	09 c0       	rjmp	.+18     	; 0x3e36 <LCD_voidGoToXY+0x40>
	{
	case(LCD_u8_LINE0):
	{
		LCD_voidSendCommend((0x80+(Copy_u8Y)));
    3e24:	8a 81       	ldd	r24, Y+2	; 0x02
    3e26:	80 58       	subi	r24, 0x80	; 128
    3e28:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
    3e2c:	04 c0       	rjmp	.+8      	; 0x3e36 <LCD_voidGoToXY+0x40>
		break;
	}
	case(LCD_u8_LINE1):
	{
		LCD_voidSendCommend((0xC0+(Copy_u8Y)));
    3e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e30:	80 54       	subi	r24, 0x40	; 64
    3e32:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
		break;
	}
	}
}
    3e36:	0f 90       	pop	r0
    3e38:	0f 90       	pop	r0
    3e3a:	0f 90       	pop	r0
    3e3c:	0f 90       	pop	r0
    3e3e:	cf 91       	pop	r28
    3e40:	df 91       	pop	r29
    3e42:	08 95       	ret

00003e44 <LCD_voidClear>:
void LCD_voidClear(void)
{
    3e44:	df 93       	push	r29
    3e46:	cf 93       	push	r28
    3e48:	cd b7       	in	r28, 0x3d	; 61
    3e4a:	de b7       	in	r29, 0x3e	; 62
    3e4c:	2e 97       	sbiw	r28, 0x0e	; 14
    3e4e:	0f b6       	in	r0, 0x3f	; 63
    3e50:	f8 94       	cli
    3e52:	de bf       	out	0x3e, r29	; 62
    3e54:	0f be       	out	0x3f, r0	; 63
    3e56:	cd bf       	out	0x3d, r28	; 61
	LCD_voidSendCommend(0b0000000001);
    3e58:	81 e0       	ldi	r24, 0x01	; 1
    3e5a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
    3e5e:	80 e0       	ldi	r24, 0x00	; 0
    3e60:	90 e0       	ldi	r25, 0x00	; 0
    3e62:	a0 e0       	ldi	r26, 0x00	; 0
    3e64:	b0 e4       	ldi	r27, 0x40	; 64
    3e66:	8b 87       	std	Y+11, r24	; 0x0b
    3e68:	9c 87       	std	Y+12, r25	; 0x0c
    3e6a:	ad 87       	std	Y+13, r26	; 0x0d
    3e6c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e6e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e70:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e72:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e74:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e76:	20 e0       	ldi	r18, 0x00	; 0
    3e78:	30 e0       	ldi	r19, 0x00	; 0
    3e7a:	4a ef       	ldi	r20, 0xFA	; 250
    3e7c:	54 e4       	ldi	r21, 0x44	; 68
    3e7e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e82:	dc 01       	movw	r26, r24
    3e84:	cb 01       	movw	r24, r22
    3e86:	8f 83       	std	Y+7, r24	; 0x07
    3e88:	98 87       	std	Y+8, r25	; 0x08
    3e8a:	a9 87       	std	Y+9, r26	; 0x09
    3e8c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3e8e:	6f 81       	ldd	r22, Y+7	; 0x07
    3e90:	78 85       	ldd	r23, Y+8	; 0x08
    3e92:	89 85       	ldd	r24, Y+9	; 0x09
    3e94:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e96:	20 e0       	ldi	r18, 0x00	; 0
    3e98:	30 e0       	ldi	r19, 0x00	; 0
    3e9a:	40 e8       	ldi	r20, 0x80	; 128
    3e9c:	5f e3       	ldi	r21, 0x3F	; 63
    3e9e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3ea2:	88 23       	and	r24, r24
    3ea4:	2c f4       	brge	.+10     	; 0x3eb0 <LCD_voidClear+0x6c>
		__ticks = 1;
    3ea6:	81 e0       	ldi	r24, 0x01	; 1
    3ea8:	90 e0       	ldi	r25, 0x00	; 0
    3eaa:	9e 83       	std	Y+6, r25	; 0x06
    3eac:	8d 83       	std	Y+5, r24	; 0x05
    3eae:	3f c0       	rjmp	.+126    	; 0x3f2e <LCD_voidClear+0xea>
	else if (__tmp > 65535)
    3eb0:	6f 81       	ldd	r22, Y+7	; 0x07
    3eb2:	78 85       	ldd	r23, Y+8	; 0x08
    3eb4:	89 85       	ldd	r24, Y+9	; 0x09
    3eb6:	9a 85       	ldd	r25, Y+10	; 0x0a
    3eb8:	20 e0       	ldi	r18, 0x00	; 0
    3eba:	3f ef       	ldi	r19, 0xFF	; 255
    3ebc:	4f e7       	ldi	r20, 0x7F	; 127
    3ebe:	57 e4       	ldi	r21, 0x47	; 71
    3ec0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3ec4:	18 16       	cp	r1, r24
    3ec6:	4c f5       	brge	.+82     	; 0x3f1a <LCD_voidClear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ec8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3eca:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ecc:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ece:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ed0:	20 e0       	ldi	r18, 0x00	; 0
    3ed2:	30 e0       	ldi	r19, 0x00	; 0
    3ed4:	40 e2       	ldi	r20, 0x20	; 32
    3ed6:	51 e4       	ldi	r21, 0x41	; 65
    3ed8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3edc:	dc 01       	movw	r26, r24
    3ede:	cb 01       	movw	r24, r22
    3ee0:	bc 01       	movw	r22, r24
    3ee2:	cd 01       	movw	r24, r26
    3ee4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ee8:	dc 01       	movw	r26, r24
    3eea:	cb 01       	movw	r24, r22
    3eec:	9e 83       	std	Y+6, r25	; 0x06
    3eee:	8d 83       	std	Y+5, r24	; 0x05
    3ef0:	0f c0       	rjmp	.+30     	; 0x3f10 <LCD_voidClear+0xcc>
    3ef2:	88 ec       	ldi	r24, 0xC8	; 200
    3ef4:	90 e0       	ldi	r25, 0x00	; 0
    3ef6:	9c 83       	std	Y+4, r25	; 0x04
    3ef8:	8b 83       	std	Y+3, r24	; 0x03
    3efa:	8b 81       	ldd	r24, Y+3	; 0x03
    3efc:	9c 81       	ldd	r25, Y+4	; 0x04
    3efe:	01 97       	sbiw	r24, 0x01	; 1
    3f00:	f1 f7       	brne	.-4      	; 0x3efe <LCD_voidClear+0xba>
    3f02:	9c 83       	std	Y+4, r25	; 0x04
    3f04:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f06:	8d 81       	ldd	r24, Y+5	; 0x05
    3f08:	9e 81       	ldd	r25, Y+6	; 0x06
    3f0a:	01 97       	sbiw	r24, 0x01	; 1
    3f0c:	9e 83       	std	Y+6, r25	; 0x06
    3f0e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f10:	8d 81       	ldd	r24, Y+5	; 0x05
    3f12:	9e 81       	ldd	r25, Y+6	; 0x06
    3f14:	00 97       	sbiw	r24, 0x00	; 0
    3f16:	69 f7       	brne	.-38     	; 0x3ef2 <LCD_voidClear+0xae>
    3f18:	14 c0       	rjmp	.+40     	; 0x3f42 <LCD_voidClear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f1a:	6f 81       	ldd	r22, Y+7	; 0x07
    3f1c:	78 85       	ldd	r23, Y+8	; 0x08
    3f1e:	89 85       	ldd	r24, Y+9	; 0x09
    3f20:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f22:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f26:	dc 01       	movw	r26, r24
    3f28:	cb 01       	movw	r24, r22
    3f2a:	9e 83       	std	Y+6, r25	; 0x06
    3f2c:	8d 83       	std	Y+5, r24	; 0x05
    3f2e:	8d 81       	ldd	r24, Y+5	; 0x05
    3f30:	9e 81       	ldd	r25, Y+6	; 0x06
    3f32:	9a 83       	std	Y+2, r25	; 0x02
    3f34:	89 83       	std	Y+1, r24	; 0x01
    3f36:	89 81       	ldd	r24, Y+1	; 0x01
    3f38:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3a:	01 97       	sbiw	r24, 0x01	; 1
    3f3c:	f1 f7       	brne	.-4      	; 0x3f3a <LCD_voidClear+0xf6>
    3f3e:	9a 83       	std	Y+2, r25	; 0x02
    3f40:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    3f42:	2e 96       	adiw	r28, 0x0e	; 14
    3f44:	0f b6       	in	r0, 0x3f	; 63
    3f46:	f8 94       	cli
    3f48:	de bf       	out	0x3e, r29	; 62
    3f4a:	0f be       	out	0x3f, r0	; 63
    3f4c:	cd bf       	out	0x3d, r28	; 61
    3f4e:	cf 91       	pop	r28
    3f50:	df 91       	pop	r29
    3f52:	08 95       	ret

00003f54 <LCD_voidSpecialChar>:
void LCD_voidSpecialChar(u8 Copy_u8Char,u8 *Copy_pu8Pattern)
{
    3f54:	df 93       	push	r29
    3f56:	cf 93       	push	r28
    3f58:	00 d0       	rcall	.+0      	; 0x3f5a <LCD_voidSpecialChar+0x6>
    3f5a:	00 d0       	rcall	.+0      	; 0x3f5c <LCD_voidSpecialChar+0x8>
    3f5c:	cd b7       	in	r28, 0x3d	; 61
    3f5e:	de b7       	in	r29, 0x3e	; 62
    3f60:	8a 83       	std	Y+2, r24	; 0x02
    3f62:	7c 83       	std	Y+4, r23	; 0x04
    3f64:	6b 83       	std	Y+3, r22	; 0x03
	LCD_voidSendCommend(Copy_u8Char);
    3f66:	8a 81       	ldd	r24, Y+2	; 0x02
    3f68:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
	u8 i;
	for(i=0;i<8;i++)
    3f6c:	19 82       	std	Y+1, r1	; 0x01
    3f6e:	0e c0       	rjmp	.+28     	; 0x3f8c <LCD_voidSpecialChar+0x38>
	{
		LCD_voidSendChar(Copy_pu8Pattern[i]);
    3f70:	89 81       	ldd	r24, Y+1	; 0x01
    3f72:	28 2f       	mov	r18, r24
    3f74:	30 e0       	ldi	r19, 0x00	; 0
    3f76:	8b 81       	ldd	r24, Y+3	; 0x03
    3f78:	9c 81       	ldd	r25, Y+4	; 0x04
    3f7a:	fc 01       	movw	r30, r24
    3f7c:	e2 0f       	add	r30, r18
    3f7e:	f3 1f       	adc	r31, r19
    3f80:	80 81       	ld	r24, Z
    3f82:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <LCD_voidSendChar>
}
void LCD_voidSpecialChar(u8 Copy_u8Char,u8 *Copy_pu8Pattern)
{
	LCD_voidSendCommend(Copy_u8Char);
	u8 i;
	for(i=0;i<8;i++)
    3f86:	89 81       	ldd	r24, Y+1	; 0x01
    3f88:	8f 5f       	subi	r24, 0xFF	; 255
    3f8a:	89 83       	std	Y+1, r24	; 0x01
    3f8c:	89 81       	ldd	r24, Y+1	; 0x01
    3f8e:	88 30       	cpi	r24, 0x08	; 8
    3f90:	78 f3       	brcs	.-34     	; 0x3f70 <LCD_voidSpecialChar+0x1c>
	{
		LCD_voidSendChar(Copy_pu8Pattern[i]);
	}
}
    3f92:	0f 90       	pop	r0
    3f94:	0f 90       	pop	r0
    3f96:	0f 90       	pop	r0
    3f98:	0f 90       	pop	r0
    3f9a:	cf 91       	pop	r28
    3f9c:	df 91       	pop	r29
    3f9e:	08 95       	ret

00003fa0 <LCD_voidShift>:
void LCD_voidShift(u8 Copy_u8Direction)
{
    3fa0:	df 93       	push	r29
    3fa2:	cf 93       	push	r28
    3fa4:	00 d0       	rcall	.+0      	; 0x3fa6 <LCD_voidShift+0x6>
    3fa6:	0f 92       	push	r0
    3fa8:	cd b7       	in	r28, 0x3d	; 61
    3faa:	de b7       	in	r29, 0x3e	; 62
    3fac:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8Direction)
    3fae:	89 81       	ldd	r24, Y+1	; 0x01
    3fb0:	28 2f       	mov	r18, r24
    3fb2:	30 e0       	ldi	r19, 0x00	; 0
    3fb4:	3b 83       	std	Y+3, r19	; 0x03
    3fb6:	2a 83       	std	Y+2, r18	; 0x02
    3fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    3fba:	9b 81       	ldd	r25, Y+3	; 0x03
    3fbc:	88 31       	cpi	r24, 0x18	; 24
    3fbe:	91 05       	cpc	r25, r1
    3fc0:	31 f0       	breq	.+12     	; 0x3fce <LCD_voidShift+0x2e>
    3fc2:	2a 81       	ldd	r18, Y+2	; 0x02
    3fc4:	3b 81       	ldd	r19, Y+3	; 0x03
    3fc6:	2c 31       	cpi	r18, 0x1C	; 28
    3fc8:	31 05       	cpc	r19, r1
    3fca:	29 f0       	breq	.+10     	; 0x3fd6 <LCD_voidShift+0x36>
    3fcc:	07 c0       	rjmp	.+14     	; 0x3fdc <LCD_voidShift+0x3c>
	{
	case(LCD_u8_LEFT):
	    {
		    LCD_voidSendCommend(0b0000011000);
    3fce:	88 e1       	ldi	r24, 0x18	; 24
    3fd0:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
    3fd4:	03 c0       	rjmp	.+6      	; 0x3fdc <LCD_voidShift+0x3c>
		    break ;
	    }
	case(LCD_u8_RIGHT):
		{
		    LCD_voidSendCommend(0b0000011100);
    3fd6:	8c e1       	ldi	r24, 0x1C	; 28
    3fd8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <LCD_voidSendCommend>
			break ;
		}
	}
}
    3fdc:	0f 90       	pop	r0
    3fde:	0f 90       	pop	r0
    3fe0:	0f 90       	pop	r0
    3fe2:	cf 91       	pop	r28
    3fe4:	df 91       	pop	r29
    3fe6:	08 95       	ret

00003fe8 <LCD_voidSendNum>:
void LCD_voidSendNum(s16 Copy_u16Number)
{
    3fe8:	df 93       	push	r29
    3fea:	cf 93       	push	r28
    3fec:	cd b7       	in	r28, 0x3d	; 61
    3fee:	de b7       	in	r29, 0x3e	; 62
    3ff0:	29 97       	sbiw	r28, 0x09	; 9
    3ff2:	0f b6       	in	r0, 0x3f	; 63
    3ff4:	f8 94       	cli
    3ff6:	de bf       	out	0x3e, r29	; 62
    3ff8:	0f be       	out	0x3f, r0	; 63
    3ffa:	cd bf       	out	0x3d, r28	; 61
    3ffc:	98 87       	std	Y+8, r25	; 0x08
    3ffe:	8f 83       	std	Y+7, r24	; 0x07
	s8 count=0,reminder;
    4000:	1e 82       	std	Y+6, r1	; 0x06
	s16 Local_u16Reversed=0;
    4002:	1c 82       	std	Y+4, r1	; 0x04
    4004:	1b 82       	std	Y+3, r1	; 0x03
	if(Copy_u16Number==0)
    4006:	8f 81       	ldd	r24, Y+7	; 0x07
    4008:	98 85       	ldd	r25, Y+8	; 0x08
    400a:	00 97       	sbiw	r24, 0x00	; 0
    400c:	21 f4       	brne	.+8      	; 0x4016 <LCD_voidSendNum+0x2e>
	{
		LCD_voidSendChar(0+48);
    400e:	80 e3       	ldi	r24, 0x30	; 48
    4010:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <LCD_voidSendChar>
    4014:	0e c0       	rjmp	.+28     	; 0x4032 <LCD_voidSendNum+0x4a>
	}
	else if(Copy_u16Number<0)
    4016:	8f 81       	ldd	r24, Y+7	; 0x07
    4018:	98 85       	ldd	r25, Y+8	; 0x08
    401a:	99 23       	and	r25, r25
    401c:	54 f4       	brge	.+20     	; 0x4032 <LCD_voidSendNum+0x4a>
	{
		LCD_voidSendChar('-');
    401e:	8d e2       	ldi	r24, 0x2D	; 45
    4020:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <LCD_voidSendChar>
		Copy_u16Number*=-1;
    4024:	8f 81       	ldd	r24, Y+7	; 0x07
    4026:	98 85       	ldd	r25, Y+8	; 0x08
    4028:	90 95       	com	r25
    402a:	81 95       	neg	r24
    402c:	9f 4f       	sbci	r25, 0xFF	; 255
    402e:	98 87       	std	Y+8, r25	; 0x08
    4030:	8f 83       	std	Y+7, r24	; 0x07
	}
	s16 test=Copy_u16Number;
    4032:	8f 81       	ldd	r24, Y+7	; 0x07
    4034:	98 85       	ldd	r25, Y+8	; 0x08
    4036:	9a 83       	std	Y+2, r25	; 0x02
    4038:	89 83       	std	Y+1, r24	; 0x01
    403a:	29 c0       	rjmp	.+82     	; 0x408e <LCD_voidSendNum+0xa6>
	while(test)
	{
	reminder=test % 10;
    403c:	89 81       	ldd	r24, Y+1	; 0x01
    403e:	9a 81       	ldd	r25, Y+2	; 0x02
    4040:	2a e0       	ldi	r18, 0x0A	; 10
    4042:	30 e0       	ldi	r19, 0x00	; 0
    4044:	b9 01       	movw	r22, r18
    4046:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divmodhi4>
    404a:	8d 83       	std	Y+5, r24	; 0x05
	Local_u16Reversed=(Local_u16Reversed*10)+reminder;
    404c:	8b 81       	ldd	r24, Y+3	; 0x03
    404e:	9c 81       	ldd	r25, Y+4	; 0x04
    4050:	9c 01       	movw	r18, r24
    4052:	22 0f       	add	r18, r18
    4054:	33 1f       	adc	r19, r19
    4056:	c9 01       	movw	r24, r18
    4058:	88 0f       	add	r24, r24
    405a:	99 1f       	adc	r25, r25
    405c:	88 0f       	add	r24, r24
    405e:	99 1f       	adc	r25, r25
    4060:	28 0f       	add	r18, r24
    4062:	39 1f       	adc	r19, r25
    4064:	8d 81       	ldd	r24, Y+5	; 0x05
    4066:	99 27       	eor	r25, r25
    4068:	87 fd       	sbrc	r24, 7
    406a:	90 95       	com	r25
    406c:	82 0f       	add	r24, r18
    406e:	93 1f       	adc	r25, r19
    4070:	9c 83       	std	Y+4, r25	; 0x04
    4072:	8b 83       	std	Y+3, r24	; 0x03
	test/=10;
    4074:	89 81       	ldd	r24, Y+1	; 0x01
    4076:	9a 81       	ldd	r25, Y+2	; 0x02
    4078:	2a e0       	ldi	r18, 0x0A	; 10
    407a:	30 e0       	ldi	r19, 0x00	; 0
    407c:	b9 01       	movw	r22, r18
    407e:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divmodhi4>
    4082:	cb 01       	movw	r24, r22
    4084:	9a 83       	std	Y+2, r25	; 0x02
    4086:	89 83       	std	Y+1, r24	; 0x01
	count++;
    4088:	8e 81       	ldd	r24, Y+6	; 0x06
    408a:	8f 5f       	subi	r24, 0xFF	; 255
    408c:	8e 83       	std	Y+6, r24	; 0x06
	{
		LCD_voidSendChar('-');
		Copy_u16Number*=-1;
	}
	s16 test=Copy_u16Number;
	while(test)
    408e:	89 81       	ldd	r24, Y+1	; 0x01
    4090:	9a 81       	ldd	r25, Y+2	; 0x02
    4092:	00 97       	sbiw	r24, 0x00	; 0
    4094:	99 f6       	brne	.-90     	; 0x403c <LCD_voidSendNum+0x54>
    4096:	16 c0       	rjmp	.+44     	; 0x40c4 <LCD_voidSendNum+0xdc>
	test/=10;
	count++;
	}
	while(count--)
	{
	reminder=Local_u16Reversed % 10;
    4098:	8b 81       	ldd	r24, Y+3	; 0x03
    409a:	9c 81       	ldd	r25, Y+4	; 0x04
    409c:	2a e0       	ldi	r18, 0x0A	; 10
    409e:	30 e0       	ldi	r19, 0x00	; 0
    40a0:	b9 01       	movw	r22, r18
    40a2:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divmodhi4>
    40a6:	8d 83       	std	Y+5, r24	; 0x05
	LCD_voidSendChar(reminder+48);
    40a8:	8d 81       	ldd	r24, Y+5	; 0x05
    40aa:	80 5d       	subi	r24, 0xD0	; 208
    40ac:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <LCD_voidSendChar>
	Local_u16Reversed/=10;
    40b0:	8b 81       	ldd	r24, Y+3	; 0x03
    40b2:	9c 81       	ldd	r25, Y+4	; 0x04
    40b4:	2a e0       	ldi	r18, 0x0A	; 10
    40b6:	30 e0       	ldi	r19, 0x00	; 0
    40b8:	b9 01       	movw	r22, r18
    40ba:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <__divmodhi4>
    40be:	cb 01       	movw	r24, r22
    40c0:	9c 83       	std	Y+4, r25	; 0x04
    40c2:	8b 83       	std	Y+3, r24	; 0x03
	reminder=test % 10;
	Local_u16Reversed=(Local_u16Reversed*10)+reminder;
	test/=10;
	count++;
	}
	while(count--)
    40c4:	8e 81       	ldd	r24, Y+6	; 0x06
    40c6:	89 87       	std	Y+9, r24	; 0x09
    40c8:	89 85       	ldd	r24, Y+9	; 0x09
    40ca:	88 23       	and	r24, r24
    40cc:	11 f0       	breq	.+4      	; 0x40d2 <LCD_voidSendNum+0xea>
    40ce:	81 e0       	ldi	r24, 0x01	; 1
    40d0:	89 87       	std	Y+9, r24	; 0x09
    40d2:	89 85       	ldd	r24, Y+9	; 0x09
    40d4:	9e 81       	ldd	r25, Y+6	; 0x06
    40d6:	91 50       	subi	r25, 0x01	; 1
    40d8:	9e 83       	std	Y+6, r25	; 0x06
    40da:	88 23       	and	r24, r24
    40dc:	e9 f6       	brne	.-70     	; 0x4098 <LCD_voidSendNum+0xb0>
	reminder=Local_u16Reversed % 10;
	LCD_voidSendChar(reminder+48);
	Local_u16Reversed/=10;

	}
}
    40de:	29 96       	adiw	r28, 0x09	; 9
    40e0:	0f b6       	in	r0, 0x3f	; 63
    40e2:	f8 94       	cli
    40e4:	de bf       	out	0x3e, r29	; 62
    40e6:	0f be       	out	0x3f, r0	; 63
    40e8:	cd bf       	out	0x3d, r28	; 61
    40ea:	cf 91       	pop	r28
    40ec:	df 91       	pop	r29
    40ee:	08 95       	ret

000040f0 <main>:
void LCDTask(void);

xQueueHandle QueueName;

int main()
{
    40f0:	af 92       	push	r10
    40f2:	bf 92       	push	r11
    40f4:	cf 92       	push	r12
    40f6:	df 92       	push	r13
    40f8:	ef 92       	push	r14
    40fa:	ff 92       	push	r15
    40fc:	0f 93       	push	r16
    40fe:	df 93       	push	r29
    4100:	cf 93       	push	r28
    4102:	cd b7       	in	r28, 0x3d	; 61
    4104:	de b7       	in	r29, 0x3e	; 62
	DIO_u8IntialDirection();
    4106:	0e 94 31 21 	call	0x4262	; 0x4262 <DIO_u8IntialDirection>
	DIO_u8IntialValue();
    410a:	0e 94 1b 21 	call	0x4236	; 0x4236 <DIO_u8IntialValue>
	Keypad_Init();
    410e:	0e 94 0c 19 	call	0x3218	; 0x3218 <Keypad_Init>
	LCD_voidInitial();
    4112:	0e 94 9d 19 	call	0x333a	; 0x333a <LCD_voidInitial>

	if((QueueName = xQueueCreate(5,sizeof(u8))) == NULL)
    4116:	85 e0       	ldi	r24, 0x05	; 5
    4118:	61 e0       	ldi	r22, 0x01	; 1
    411a:	0e 94 a0 0d 	call	0x1b40	; 0x1b40 <xQueueCreate>
    411e:	90 93 3f 03 	sts	0x033F, r25
    4122:	80 93 3e 03 	sts	0x033E, r24
    4126:	80 91 3e 03 	lds	r24, 0x033E
    412a:	90 91 3f 03 	lds	r25, 0x033F
    412e:	00 97       	sbiw	r24, 0x00	; 0
    4130:	21 f4       	brne	.+8      	; 0x413a <main+0x4a>
		LCD_voidSendStr("Queue is not created");
    4132:	85 e6       	ldi	r24, 0x65	; 101
    4134:	90 e0       	ldi	r25, 0x00	; 0
    4136:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <LCD_voidSendStr>
	if(xTaskCreate(LCDTask,"N2",100,NULL,2,NULL) == NULL)
    413a:	82 ef       	ldi	r24, 0xF2	; 242
    413c:	90 e2       	ldi	r25, 0x20	; 32
    413e:	2a e7       	ldi	r18, 0x7A	; 122
    4140:	30 e0       	ldi	r19, 0x00	; 0
    4142:	b9 01       	movw	r22, r18
    4144:	44 e6       	ldi	r20, 0x64	; 100
    4146:	50 e0       	ldi	r21, 0x00	; 0
    4148:	20 e0       	ldi	r18, 0x00	; 0
    414a:	30 e0       	ldi	r19, 0x00	; 0
    414c:	02 e0       	ldi	r16, 0x02	; 2
    414e:	ee 24       	eor	r14, r14
    4150:	ff 24       	eor	r15, r15
    4152:	cc 24       	eor	r12, r12
    4154:	dd 24       	eor	r13, r13
    4156:	aa 24       	eor	r10, r10
    4158:	bb 24       	eor	r11, r11
    415a:	0e 94 21 12 	call	0x2442	; 0x2442 <xTaskGenericCreate>
    415e:	99 27       	eor	r25, r25
    4160:	87 fd       	sbrc	r24, 7
    4162:	90 95       	com	r25
    4164:	00 97       	sbiw	r24, 0x00	; 0
    4166:	21 f4       	brne	.+8      	; 0x4170 <main+0x80>
		LCD_voidSendStr("LCDTask not created");
    4168:	8d e7       	ldi	r24, 0x7D	; 125
    416a:	90 e0       	ldi	r25, 0x00	; 0
    416c:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <LCD_voidSendStr>
	if(xTaskCreate(KeyPadTask,"N1",100,NULL,1,NULL) == NULL)
    4170:	86 ed       	ldi	r24, 0xD6	; 214
    4172:	90 e2       	ldi	r25, 0x20	; 32
    4174:	21 e9       	ldi	r18, 0x91	; 145
    4176:	30 e0       	ldi	r19, 0x00	; 0
    4178:	b9 01       	movw	r22, r18
    417a:	44 e6       	ldi	r20, 0x64	; 100
    417c:	50 e0       	ldi	r21, 0x00	; 0
    417e:	20 e0       	ldi	r18, 0x00	; 0
    4180:	30 e0       	ldi	r19, 0x00	; 0
    4182:	01 e0       	ldi	r16, 0x01	; 1
    4184:	ee 24       	eor	r14, r14
    4186:	ff 24       	eor	r15, r15
    4188:	cc 24       	eor	r12, r12
    418a:	dd 24       	eor	r13, r13
    418c:	aa 24       	eor	r10, r10
    418e:	bb 24       	eor	r11, r11
    4190:	0e 94 21 12 	call	0x2442	; 0x2442 <xTaskGenericCreate>
    4194:	99 27       	eor	r25, r25
    4196:	87 fd       	sbrc	r24, 7
    4198:	90 95       	com	r25
    419a:	00 97       	sbiw	r24, 0x00	; 0
    419c:	21 f4       	brne	.+8      	; 0x41a6 <main+0xb6>
		LCD_voidSendStr("KeyPadTask not created");
    419e:	84 e9       	ldi	r24, 0x94	; 148
    41a0:	90 e0       	ldi	r25, 0x00	; 0
    41a2:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <LCD_voidSendStr>

	vTaskStartScheduler();
    41a6:	0e 94 1a 14 	call	0x2834	; 0x2834 <vTaskStartScheduler>
    41aa:	ff cf       	rjmp	.-2      	; 0x41aa <main+0xba>

000041ac <KeyPadTask>:
	while(1);
	return 0;
}

void KeyPadTask(void)
{
    41ac:	df 93       	push	r29
    41ae:	cf 93       	push	r28
    41b0:	0f 92       	push	r0
    41b2:	cd b7       	in	r28, 0x3d	; 61
    41b4:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		u8 Var = 0;
    41b6:	19 82       	std	Y+1, r1	; 0x01
		Var = KeypadGetPressed();
    41b8:	0e 94 3f 19 	call	0x327e	; 0x327e <KeypadGetPressed>
    41bc:	89 83       	std	Y+1, r24	; 0x01
		xQueueSendToBack(QueueName,&Var,200);
    41be:	80 91 3e 03 	lds	r24, 0x033E
    41c2:	90 91 3f 03 	lds	r25, 0x033F
    41c6:	9e 01       	movw	r18, r28
    41c8:	2f 5f       	subi	r18, 0xFF	; 255
    41ca:	3f 4f       	sbci	r19, 0xFF	; 255
    41cc:	b9 01       	movw	r22, r18
    41ce:	48 ec       	ldi	r20, 0xC8	; 200
    41d0:	50 e0       	ldi	r21, 0x00	; 0
    41d2:	20 e0       	ldi	r18, 0x00	; 0
    41d4:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <xQueueGenericSend>
		Var = 0;
    41d8:	19 82       	std	Y+1, r1	; 0x01
		vTaskDelay(50);
    41da:	82 e3       	ldi	r24, 0x32	; 50
    41dc:	90 e0       	ldi	r25, 0x00	; 0
    41de:	0e 94 e5 13 	call	0x27ca	; 0x27ca <vTaskDelay>
    41e2:	e9 cf       	rjmp	.-46     	; 0x41b6 <KeyPadTask+0xa>

000041e4 <LCDTask>:
	}
}
void LCDTask(void)
{
    41e4:	df 93       	push	r29
    41e6:	cf 93       	push	r28
    41e8:	0f 92       	push	r0
    41ea:	cd b7       	in	r28, 0x3d	; 61
    41ec:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		u8 Var = 0;
    41ee:	19 82       	std	Y+1, r1	; 0x01
		xQueueReceive(QueueName,&Var,200);
    41f0:	80 91 3e 03 	lds	r24, 0x033E
    41f4:	90 91 3f 03 	lds	r25, 0x033F
    41f8:	9e 01       	movw	r18, r28
    41fa:	2f 5f       	subi	r18, 0xFF	; 255
    41fc:	3f 4f       	sbci	r19, 0xFF	; 255
    41fe:	b9 01       	movw	r22, r18
    4200:	48 ec       	ldi	r20, 0xC8	; 200
    4202:	50 e0       	ldi	r21, 0x00	; 0
    4204:	20 e0       	ldi	r18, 0x00	; 0
    4206:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xQueueGenericReceive>
		if(Var == 'o')
    420a:	89 81       	ldd	r24, Y+1	; 0x01
    420c:	8f 36       	cpi	r24, 0x6F	; 111
    420e:	39 f4       	brne	.+14     	; 0x421e <LCDTask+0x3a>
		{
			LCD_voidClear();
    4210:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <LCD_voidClear>
			LCD_voidGoToXY(0,0);
    4214:	80 e0       	ldi	r24, 0x00	; 0
    4216:	60 e0       	ldi	r22, 0x00	; 0
    4218:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <LCD_voidGoToXY>
    421c:	06 c0       	rjmp	.+12     	; 0x422a <LCDTask+0x46>
		}
		else if(Var == 0)
    421e:	89 81       	ldd	r24, Y+1	; 0x01
    4220:	88 23       	and	r24, r24
    4222:	29 f3       	breq	.-54     	; 0x41ee <LCDTask+0xa>
		{
			continue;
		}
		else
			LCD_voidSendChar(Var);
    4224:	89 81       	ldd	r24, Y+1	; 0x01
    4226:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <LCD_voidSendChar>
		Var = 0;
    422a:	19 82       	std	Y+1, r1	; 0x01
		vTaskDelay(50);
    422c:	82 e3       	ldi	r24, 0x32	; 50
    422e:	90 e0       	ldi	r25, 0x00	; 0
    4230:	0e 94 e5 13 	call	0x27ca	; 0x27ca <vTaskDelay>
    4234:	dc cf       	rjmp	.-72     	; 0x41ee <LCDTask+0xa>

00004236 <DIO_u8IntialValue>:
#include "private.h"
#include "config.h"
#include "interface.h"

void DIO_u8IntialValue    (void)
{
    4236:	df 93       	push	r29
    4238:	cf 93       	push	r28
    423a:	cd b7       	in	r28, 0x3d	; 61
    423c:	de b7       	in	r29, 0x3e	; 62
	PORTA_u8_REG = CONC(DIO_u8_PORTA_PIN7_INITIAL_VALUE ,DIO_u8_PORTA_PIN6_INITIAL_VALUE,DIO_u8_PORTA_PIN5_INITIAL_VALUE,DIO_u8_PORTA_PIN4_INITIAL_VALUE,
    423e:	eb e3       	ldi	r30, 0x3B	; 59
    4240:	f0 e0       	ldi	r31, 0x00	; 0
    4242:	88 ef       	ldi	r24, 0xF8	; 248
    4244:	80 83       	st	Z, r24
			            DIO_u8_PORTA_PIN3_INITIAL_VALUE,DIO_u8_PORTA_PIN2_INITIAL_VALUE,DIO_u8_PORTA_PIN1_INITIAL_VALUE,DIO_u8_PORTA_PIN0_INITIAL_VALUE);
	PORTB_u8_REG = CONC(DIO_u8_PORTB_PIN7_INITIAL_VALUE ,DIO_u8_PORTB_PIN6_INITIAL_VALUE,DIO_u8_PORTB_PIN5_INITIAL_VALUE,DIO_u8_PORTB_PIN4_INITIAL_VALUE,
    4246:	e8 e3       	ldi	r30, 0x38	; 56
    4248:	f0 e0       	ldi	r31, 0x00	; 0
    424a:	10 82       	st	Z, r1
                        DIO_u8_PORTB_PIN3_INITIAL_VALUE,DIO_u8_PORTB_PIN2_INITIAL_VALUE,DIO_u8_PORTB_PIN1_INITIAL_VALUE,DIO_u8_PORTB_PIN0_INITIAL_VALUE);
	PORTC_u8_REG = CONC(DIO_u8_PORTC_PIN7_INITIAL_VALUE ,DIO_u8_PORTC_PIN6_INITIAL_VALUE,DIO_u8_PORTC_PIN5_INITIAL_VALUE,DIO_u8_PORTC_PIN4_INITIAL_VALUE,
    424c:	e5 e3       	ldi	r30, 0x35	; 53
    424e:	f0 e0       	ldi	r31, 0x00	; 0
    4250:	84 e0       	ldi	r24, 0x04	; 4
    4252:	80 83       	st	Z, r24
                         DIO_u8_PORTC_PIN3_INITIAL_VALUE,DIO_u8_PORTC_PIN2_INITIAL_VALUE,DIO_u8_PORTC_PIN1_INITIAL_VALUE,DIO_u8_PORTC_PIN0_INITIAL_VALUE);
	PORTD_u8_REG = CONC(DIO_u8_PORTD_PIN7_INITIAL_VALUE ,DIO_u8_PORTD_PIN6_INITIAL_VALUE,DIO_u8_PORTD_PIN5_INITIAL_VALUE,DIO_u8_PORTD_PIN4_INITIAL_VALUE,
    4254:	e2 e3       	ldi	r30, 0x32	; 50
    4256:	f0 e0       	ldi	r31, 0x00	; 0
    4258:	81 e0       	ldi	r24, 0x01	; 1
    425a:	80 83       	st	Z, r24
                         DIO_u8_PORTD_PIN3_INITIAL_VALUE,DIO_u8_PORTD_PIN2_INITIAL_VALUE,DIO_u8_PORTD_PIN1_INITIAL_VALUE,DIO_u8_PORTD_PIN0_INITIAL_VALUE);
}
    425c:	cf 91       	pop	r28
    425e:	df 91       	pop	r29
    4260:	08 95       	ret

00004262 <DIO_u8IntialDirection>:
void DIO_u8IntialDirection    (void)
{
    4262:	df 93       	push	r29
    4264:	cf 93       	push	r28
    4266:	cd b7       	in	r28, 0x3d	; 61
    4268:	de b7       	in	r29, 0x3e	; 62
	DDRA_u8_REG = CONC(DIO_u8_PORTA_PIN7_INITIAL_DIRECTION,DIO_u8_PORTA_PIN6_INITIAL_DIRECTION,DIO_u8_PORTA_PIN5_INITIAL_DIRECTION,DIO_u8_PORTA_PIN4_INITIAL_DIRECTION,
    426a:	ea e3       	ldi	r30, 0x3A	; 58
    426c:	f0 e0       	ldi	r31, 0x00	; 0
    426e:	8f e0       	ldi	r24, 0x0F	; 15
    4270:	80 83       	st	Z, r24
			           DIO_u8_PORTA_PIN3_INITIAL_DIRECTION,DIO_u8_PORTA_PIN2_INITIAL_DIRECTION,DIO_u8_PORTA_PIN1_INITIAL_DIRECTION,DIO_u8_PORTA_PIN0_INITIAL_DIRECTION);
	DDRB_u8_REG = CONC(DIO_u8_PORTB_PIN7_INITIAL_DIRECTION,DIO_u8_PORTB_PIN6_INITIAL_DIRECTION,DIO_u8_PORTB_PIN5_INITIAL_DIRECTION,DIO_u8_PORTB_PIN4_INITIAL_DIRECTION,
    4272:	e7 e3       	ldi	r30, 0x37	; 55
    4274:	f0 e0       	ldi	r31, 0x00	; 0
    4276:	8f ef       	ldi	r24, 0xFF	; 255
    4278:	80 83       	st	Z, r24
	                   DIO_u8_PORTB_PIN3_INITIAL_DIRECTION,DIO_u8_PORTB_PIN2_INITIAL_DIRECTION,DIO_u8_PORTB_PIN1_INITIAL_DIRECTION,DIO_u8_PORTB_PIN0_INITIAL_DIRECTION);
	DDRC_u8_REG = CONC(DIO_u8_PORTC_PIN7_INITIAL_DIRECTION,DIO_u8_PORTC_PIN6_INITIAL_DIRECTION,DIO_u8_PORTC_PIN5_INITIAL_DIRECTION,DIO_u8_PORTC_PIN4_INITIAL_DIRECTION,
    427a:	e4 e3       	ldi	r30, 0x34	; 52
    427c:	f0 e0       	ldi	r31, 0x00	; 0
    427e:	8f ef       	ldi	r24, 0xFF	; 255
    4280:	80 83       	st	Z, r24
	                   DIO_u8_PORTC_PIN3_INITIAL_DIRECTION,DIO_u8_PORTC_PIN2_INITIAL_DIRECTION,DIO_u8_PORTC_PIN1_INITIAL_DIRECTION,DIO_u8_PORTC_PIN0_INITIAL_DIRECTION);
	DDRD_u8_REG = CONC(DIO_u8_PORTD_PIN7_INITIAL_DIRECTION,DIO_u8_PORTD_PIN6_INITIAL_DIRECTION,DIO_u8_PORTD_PIN5_INITIAL_DIRECTION,DIO_u8_PORTD_PIN4_INITIAL_DIRECTION,
    4282:	e1 e3       	ldi	r30, 0x31	; 49
    4284:	f0 e0       	ldi	r31, 0x00	; 0
    4286:	8b ef       	ldi	r24, 0xFB	; 251
    4288:	80 83       	st	Z, r24
	                   DIO_u8_PORTD_PIN3_INITIAL_DIRECTION,DIO_u8_PORTD_PIN2_INITIAL_DIRECTION,DIO_u8_PORTD_PIN1_INITIAL_DIRECTION,DIO_u8_PORTD_PIN0_INITIAL_DIRECTION);
}
    428a:	cf 91       	pop	r28
    428c:	df 91       	pop	r29
    428e:	08 95       	ret

00004290 <DIO_u8SetPinDirection>:

u8 DIO_u8SetPinDirection(u8 Copy_u8PortId,u8 Copy_u8PinId,u8 Copy_u8PinDirection)
{
    4290:	df 93       	push	r29
    4292:	cf 93       	push	r28
    4294:	cd b7       	in	r28, 0x3d	; 61
    4296:	de b7       	in	r29, 0x3e	; 62
    4298:	2e 97       	sbiw	r28, 0x0e	; 14
    429a:	0f b6       	in	r0, 0x3f	; 63
    429c:	f8 94       	cli
    429e:	de bf       	out	0x3e, r29	; 62
    42a0:	0f be       	out	0x3f, r0	; 63
    42a2:	cd bf       	out	0x3d, r28	; 61
    42a4:	8a 83       	std	Y+2, r24	; 0x02
    42a6:	6b 83       	std	Y+3, r22	; 0x03
    42a8:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ReturnedState=OK;
    42aa:	81 e0       	ldi	r24, 0x01	; 1
    42ac:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD)&&(Copy_u8PinId <= DIO_u8_PIN7)&&(Copy_u8PinDirection <= DIO_u8_PIN_OUTPUT))                                                     
    42ae:	8a 81       	ldd	r24, Y+2	; 0x02
    42b0:	84 30       	cpi	r24, 0x04	; 4
    42b2:	08 f0       	brcs	.+2      	; 0x42b6 <DIO_u8SetPinDirection+0x26>
    42b4:	09 c1       	rjmp	.+530    	; 0x44c8 <DIO_u8SetPinDirection+0x238>
    42b6:	8b 81       	ldd	r24, Y+3	; 0x03
    42b8:	88 30       	cpi	r24, 0x08	; 8
    42ba:	08 f0       	brcs	.+2      	; 0x42be <DIO_u8SetPinDirection+0x2e>
    42bc:	05 c1       	rjmp	.+522    	; 0x44c8 <DIO_u8SetPinDirection+0x238>
    42be:	8c 81       	ldd	r24, Y+4	; 0x04
    42c0:	82 30       	cpi	r24, 0x02	; 2
    42c2:	08 f0       	brcs	.+2      	; 0x42c6 <DIO_u8SetPinDirection+0x36>
    42c4:	01 c1       	rjmp	.+514    	; 0x44c8 <DIO_u8SetPinDirection+0x238>
	{
		switch(Copy_u8PortId)
    42c6:	8a 81       	ldd	r24, Y+2	; 0x02
    42c8:	28 2f       	mov	r18, r24
    42ca:	30 e0       	ldi	r19, 0x00	; 0
    42cc:	3e 87       	std	Y+14, r19	; 0x0e
    42ce:	2d 87       	std	Y+13, r18	; 0x0d
    42d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    42d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    42d4:	81 30       	cpi	r24, 0x01	; 1
    42d6:	91 05       	cpc	r25, r1
    42d8:	09 f4       	brne	.+2      	; 0x42dc <DIO_u8SetPinDirection+0x4c>
    42da:	4f c0       	rjmp	.+158    	; 0x437a <DIO_u8SetPinDirection+0xea>
    42dc:	2d 85       	ldd	r18, Y+13	; 0x0d
    42de:	3e 85       	ldd	r19, Y+14	; 0x0e
    42e0:	22 30       	cpi	r18, 0x02	; 2
    42e2:	31 05       	cpc	r19, r1
    42e4:	2c f4       	brge	.+10     	; 0x42f0 <DIO_u8SetPinDirection+0x60>
    42e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    42e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    42ea:	00 97       	sbiw	r24, 0x00	; 0
    42ec:	71 f0       	breq	.+28     	; 0x430a <DIO_u8SetPinDirection+0x7a>
    42ee:	ed c0       	rjmp	.+474    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
    42f0:	2d 85       	ldd	r18, Y+13	; 0x0d
    42f2:	3e 85       	ldd	r19, Y+14	; 0x0e
    42f4:	22 30       	cpi	r18, 0x02	; 2
    42f6:	31 05       	cpc	r19, r1
    42f8:	09 f4       	brne	.+2      	; 0x42fc <DIO_u8SetPinDirection+0x6c>
    42fa:	77 c0       	rjmp	.+238    	; 0x43ea <DIO_u8SetPinDirection+0x15a>
    42fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    42fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    4300:	83 30       	cpi	r24, 0x03	; 3
    4302:	91 05       	cpc	r25, r1
    4304:	09 f4       	brne	.+2      	; 0x4308 <DIO_u8SetPinDirection+0x78>
    4306:	a9 c0       	rjmp	.+338    	; 0x445a <DIO_u8SetPinDirection+0x1ca>
    4308:	e0 c0       	rjmp	.+448    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
		{
			case (DIO_u8_PORTA):
			{
				switch(Copy_u8PinDirection)
    430a:	8c 81       	ldd	r24, Y+4	; 0x04
    430c:	28 2f       	mov	r18, r24
    430e:	30 e0       	ldi	r19, 0x00	; 0
    4310:	3c 87       	std	Y+12, r19	; 0x0c
    4312:	2b 87       	std	Y+11, r18	; 0x0b
    4314:	8b 85       	ldd	r24, Y+11	; 0x0b
    4316:	9c 85       	ldd	r25, Y+12	; 0x0c
    4318:	00 97       	sbiw	r24, 0x00	; 0
    431a:	d1 f0       	breq	.+52     	; 0x4350 <DIO_u8SetPinDirection+0xc0>
    431c:	2b 85       	ldd	r18, Y+11	; 0x0b
    431e:	3c 85       	ldd	r19, Y+12	; 0x0c
    4320:	21 30       	cpi	r18, 0x01	; 1
    4322:	31 05       	cpc	r19, r1
    4324:	09 f0       	breq	.+2      	; 0x4328 <DIO_u8SetPinDirection+0x98>
    4326:	d1 c0       	rjmp	.+418    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				{
					case(DIO_u8_PIN_OUTPUT):
					{
						SET_BIT(DDRA_u8_REG,Copy_u8PinId);
    4328:	aa e3       	ldi	r26, 0x3A	; 58
    432a:	b0 e0       	ldi	r27, 0x00	; 0
    432c:	ea e3       	ldi	r30, 0x3A	; 58
    432e:	f0 e0       	ldi	r31, 0x00	; 0
    4330:	80 81       	ld	r24, Z
    4332:	48 2f       	mov	r20, r24
    4334:	8b 81       	ldd	r24, Y+3	; 0x03
    4336:	28 2f       	mov	r18, r24
    4338:	30 e0       	ldi	r19, 0x00	; 0
    433a:	81 e0       	ldi	r24, 0x01	; 1
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	02 2e       	mov	r0, r18
    4340:	02 c0       	rjmp	.+4      	; 0x4346 <DIO_u8SetPinDirection+0xb6>
    4342:	88 0f       	add	r24, r24
    4344:	99 1f       	adc	r25, r25
    4346:	0a 94       	dec	r0
    4348:	e2 f7       	brpl	.-8      	; 0x4342 <DIO_u8SetPinDirection+0xb2>
    434a:	84 2b       	or	r24, r20
    434c:	8c 93       	st	X, r24
    434e:	bd c0       	rjmp	.+378    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
						break;
					}
					case(DIO_u8_PIN_INPUT):
					{
						CLEAR_BIT(DDRA_u8_REG,Copy_u8PinId);
    4350:	aa e3       	ldi	r26, 0x3A	; 58
    4352:	b0 e0       	ldi	r27, 0x00	; 0
    4354:	ea e3       	ldi	r30, 0x3A	; 58
    4356:	f0 e0       	ldi	r31, 0x00	; 0
    4358:	80 81       	ld	r24, Z
    435a:	48 2f       	mov	r20, r24
    435c:	8b 81       	ldd	r24, Y+3	; 0x03
    435e:	28 2f       	mov	r18, r24
    4360:	30 e0       	ldi	r19, 0x00	; 0
    4362:	81 e0       	ldi	r24, 0x01	; 1
    4364:	90 e0       	ldi	r25, 0x00	; 0
    4366:	02 2e       	mov	r0, r18
    4368:	02 c0       	rjmp	.+4      	; 0x436e <DIO_u8SetPinDirection+0xde>
    436a:	88 0f       	add	r24, r24
    436c:	99 1f       	adc	r25, r25
    436e:	0a 94       	dec	r0
    4370:	e2 f7       	brpl	.-8      	; 0x436a <DIO_u8SetPinDirection+0xda>
    4372:	80 95       	com	r24
    4374:	84 23       	and	r24, r20
    4376:	8c 93       	st	X, r24
    4378:	a8 c0       	rjmp	.+336    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				}
				break;
			}
			case (DIO_u8_PORTB):
			{
				switch(Copy_u8PinDirection)
    437a:	8c 81       	ldd	r24, Y+4	; 0x04
    437c:	28 2f       	mov	r18, r24
    437e:	30 e0       	ldi	r19, 0x00	; 0
    4380:	3a 87       	std	Y+10, r19	; 0x0a
    4382:	29 87       	std	Y+9, r18	; 0x09
    4384:	89 85       	ldd	r24, Y+9	; 0x09
    4386:	9a 85       	ldd	r25, Y+10	; 0x0a
    4388:	00 97       	sbiw	r24, 0x00	; 0
    438a:	d1 f0       	breq	.+52     	; 0x43c0 <DIO_u8SetPinDirection+0x130>
    438c:	29 85       	ldd	r18, Y+9	; 0x09
    438e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4390:	21 30       	cpi	r18, 0x01	; 1
    4392:	31 05       	cpc	r19, r1
    4394:	09 f0       	breq	.+2      	; 0x4398 <DIO_u8SetPinDirection+0x108>
    4396:	99 c0       	rjmp	.+306    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				{
					case (DIO_u8_PIN_OUTPUT):
					{
						SET_BIT(DDRB_u8_REG,Copy_u8PinId);
    4398:	a7 e3       	ldi	r26, 0x37	; 55
    439a:	b0 e0       	ldi	r27, 0x00	; 0
    439c:	e7 e3       	ldi	r30, 0x37	; 55
    439e:	f0 e0       	ldi	r31, 0x00	; 0
    43a0:	80 81       	ld	r24, Z
    43a2:	48 2f       	mov	r20, r24
    43a4:	8b 81       	ldd	r24, Y+3	; 0x03
    43a6:	28 2f       	mov	r18, r24
    43a8:	30 e0       	ldi	r19, 0x00	; 0
    43aa:	81 e0       	ldi	r24, 0x01	; 1
    43ac:	90 e0       	ldi	r25, 0x00	; 0
    43ae:	02 2e       	mov	r0, r18
    43b0:	02 c0       	rjmp	.+4      	; 0x43b6 <DIO_u8SetPinDirection+0x126>
    43b2:	88 0f       	add	r24, r24
    43b4:	99 1f       	adc	r25, r25
    43b6:	0a 94       	dec	r0
    43b8:	e2 f7       	brpl	.-8      	; 0x43b2 <DIO_u8SetPinDirection+0x122>
    43ba:	84 2b       	or	r24, r20
    43bc:	8c 93       	st	X, r24
    43be:	85 c0       	rjmp	.+266    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
						break;
					}
					case(DIO_u8_PIN_INPUT):
					{
						CLEAR_BIT(DDRB_u8_REG,Copy_u8PinId);
    43c0:	a7 e3       	ldi	r26, 0x37	; 55
    43c2:	b0 e0       	ldi	r27, 0x00	; 0
    43c4:	e7 e3       	ldi	r30, 0x37	; 55
    43c6:	f0 e0       	ldi	r31, 0x00	; 0
    43c8:	80 81       	ld	r24, Z
    43ca:	48 2f       	mov	r20, r24
    43cc:	8b 81       	ldd	r24, Y+3	; 0x03
    43ce:	28 2f       	mov	r18, r24
    43d0:	30 e0       	ldi	r19, 0x00	; 0
    43d2:	81 e0       	ldi	r24, 0x01	; 1
    43d4:	90 e0       	ldi	r25, 0x00	; 0
    43d6:	02 2e       	mov	r0, r18
    43d8:	02 c0       	rjmp	.+4      	; 0x43de <DIO_u8SetPinDirection+0x14e>
    43da:	88 0f       	add	r24, r24
    43dc:	99 1f       	adc	r25, r25
    43de:	0a 94       	dec	r0
    43e0:	e2 f7       	brpl	.-8      	; 0x43da <DIO_u8SetPinDirection+0x14a>
    43e2:	80 95       	com	r24
    43e4:	84 23       	and	r24, r20
    43e6:	8c 93       	st	X, r24
    43e8:	70 c0       	rjmp	.+224    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				}
				break;
			}
			case(DIO_u8_PORTC):
			{
				switch(Copy_u8PinDirection)
    43ea:	8c 81       	ldd	r24, Y+4	; 0x04
    43ec:	28 2f       	mov	r18, r24
    43ee:	30 e0       	ldi	r19, 0x00	; 0
    43f0:	38 87       	std	Y+8, r19	; 0x08
    43f2:	2f 83       	std	Y+7, r18	; 0x07
    43f4:	8f 81       	ldd	r24, Y+7	; 0x07
    43f6:	98 85       	ldd	r25, Y+8	; 0x08
    43f8:	00 97       	sbiw	r24, 0x00	; 0
    43fa:	d1 f0       	breq	.+52     	; 0x4430 <DIO_u8SetPinDirection+0x1a0>
    43fc:	2f 81       	ldd	r18, Y+7	; 0x07
    43fe:	38 85       	ldd	r19, Y+8	; 0x08
    4400:	21 30       	cpi	r18, 0x01	; 1
    4402:	31 05       	cpc	r19, r1
    4404:	09 f0       	breq	.+2      	; 0x4408 <DIO_u8SetPinDirection+0x178>
    4406:	61 c0       	rjmp	.+194    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				{
					case(DIO_u8_PIN_OUTPUT):
					{
						SET_BIT(DDRC_u8_REG,Copy_u8PinId);
    4408:	a4 e3       	ldi	r26, 0x34	; 52
    440a:	b0 e0       	ldi	r27, 0x00	; 0
    440c:	e4 e3       	ldi	r30, 0x34	; 52
    440e:	f0 e0       	ldi	r31, 0x00	; 0
    4410:	80 81       	ld	r24, Z
    4412:	48 2f       	mov	r20, r24
    4414:	8b 81       	ldd	r24, Y+3	; 0x03
    4416:	28 2f       	mov	r18, r24
    4418:	30 e0       	ldi	r19, 0x00	; 0
    441a:	81 e0       	ldi	r24, 0x01	; 1
    441c:	90 e0       	ldi	r25, 0x00	; 0
    441e:	02 2e       	mov	r0, r18
    4420:	02 c0       	rjmp	.+4      	; 0x4426 <DIO_u8SetPinDirection+0x196>
    4422:	88 0f       	add	r24, r24
    4424:	99 1f       	adc	r25, r25
    4426:	0a 94       	dec	r0
    4428:	e2 f7       	brpl	.-8      	; 0x4422 <DIO_u8SetPinDirection+0x192>
    442a:	84 2b       	or	r24, r20
    442c:	8c 93       	st	X, r24
    442e:	4d c0       	rjmp	.+154    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
						break;
					}
					case(DIO_u8_PIN_INPUT):
					{
						CLEAR_BIT(DDRC_u8_REG,Copy_u8PinId);
    4430:	a4 e3       	ldi	r26, 0x34	; 52
    4432:	b0 e0       	ldi	r27, 0x00	; 0
    4434:	e4 e3       	ldi	r30, 0x34	; 52
    4436:	f0 e0       	ldi	r31, 0x00	; 0
    4438:	80 81       	ld	r24, Z
    443a:	48 2f       	mov	r20, r24
    443c:	8b 81       	ldd	r24, Y+3	; 0x03
    443e:	28 2f       	mov	r18, r24
    4440:	30 e0       	ldi	r19, 0x00	; 0
    4442:	81 e0       	ldi	r24, 0x01	; 1
    4444:	90 e0       	ldi	r25, 0x00	; 0
    4446:	02 2e       	mov	r0, r18
    4448:	02 c0       	rjmp	.+4      	; 0x444e <DIO_u8SetPinDirection+0x1be>
    444a:	88 0f       	add	r24, r24
    444c:	99 1f       	adc	r25, r25
    444e:	0a 94       	dec	r0
    4450:	e2 f7       	brpl	.-8      	; 0x444a <DIO_u8SetPinDirection+0x1ba>
    4452:	80 95       	com	r24
    4454:	84 23       	and	r24, r20
    4456:	8c 93       	st	X, r24
    4458:	38 c0       	rjmp	.+112    	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				}
				break;
			}
			case(DIO_u8_PORTD):
			{
				switch(Copy_u8PinDirection)
    445a:	8c 81       	ldd	r24, Y+4	; 0x04
    445c:	28 2f       	mov	r18, r24
    445e:	30 e0       	ldi	r19, 0x00	; 0
    4460:	3e 83       	std	Y+6, r19	; 0x06
    4462:	2d 83       	std	Y+5, r18	; 0x05
    4464:	8d 81       	ldd	r24, Y+5	; 0x05
    4466:	9e 81       	ldd	r25, Y+6	; 0x06
    4468:	00 97       	sbiw	r24, 0x00	; 0
    446a:	c9 f0       	breq	.+50     	; 0x449e <DIO_u8SetPinDirection+0x20e>
    446c:	2d 81       	ldd	r18, Y+5	; 0x05
    446e:	3e 81       	ldd	r19, Y+6	; 0x06
    4470:	21 30       	cpi	r18, 0x01	; 1
    4472:	31 05       	cpc	r19, r1
    4474:	51 f5       	brne	.+84     	; 0x44ca <DIO_u8SetPinDirection+0x23a>
				{
					case(DIO_u8_PIN_OUTPUT):
					{
						SET_BIT(DDRD_u8_REG,Copy_u8PinId);
    4476:	a1 e3       	ldi	r26, 0x31	; 49
    4478:	b0 e0       	ldi	r27, 0x00	; 0
    447a:	e1 e3       	ldi	r30, 0x31	; 49
    447c:	f0 e0       	ldi	r31, 0x00	; 0
    447e:	80 81       	ld	r24, Z
    4480:	48 2f       	mov	r20, r24
    4482:	8b 81       	ldd	r24, Y+3	; 0x03
    4484:	28 2f       	mov	r18, r24
    4486:	30 e0       	ldi	r19, 0x00	; 0
    4488:	81 e0       	ldi	r24, 0x01	; 1
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	02 2e       	mov	r0, r18
    448e:	02 c0       	rjmp	.+4      	; 0x4494 <DIO_u8SetPinDirection+0x204>
    4490:	88 0f       	add	r24, r24
    4492:	99 1f       	adc	r25, r25
    4494:	0a 94       	dec	r0
    4496:	e2 f7       	brpl	.-8      	; 0x4490 <DIO_u8SetPinDirection+0x200>
    4498:	84 2b       	or	r24, r20
    449a:	8c 93       	st	X, r24
    449c:	16 c0       	rjmp	.+44     	; 0x44ca <DIO_u8SetPinDirection+0x23a>
						break;
					}
					case(DIO_u8_PIN_INPUT):
					{
						CLEAR_BIT(DDRD_u8_REG,Copy_u8PinId);
    449e:	a1 e3       	ldi	r26, 0x31	; 49
    44a0:	b0 e0       	ldi	r27, 0x00	; 0
    44a2:	e1 e3       	ldi	r30, 0x31	; 49
    44a4:	f0 e0       	ldi	r31, 0x00	; 0
    44a6:	80 81       	ld	r24, Z
    44a8:	48 2f       	mov	r20, r24
    44aa:	8b 81       	ldd	r24, Y+3	; 0x03
    44ac:	28 2f       	mov	r18, r24
    44ae:	30 e0       	ldi	r19, 0x00	; 0
    44b0:	81 e0       	ldi	r24, 0x01	; 1
    44b2:	90 e0       	ldi	r25, 0x00	; 0
    44b4:	02 2e       	mov	r0, r18
    44b6:	02 c0       	rjmp	.+4      	; 0x44bc <DIO_u8SetPinDirection+0x22c>
    44b8:	88 0f       	add	r24, r24
    44ba:	99 1f       	adc	r25, r25
    44bc:	0a 94       	dec	r0
    44be:	e2 f7       	brpl	.-8      	; 0x44b8 <DIO_u8SetPinDirection+0x228>
    44c0:	80 95       	com	r24
    44c2:	84 23       	and	r24, r20
    44c4:	8c 93       	st	X, r24
    44c6:	01 c0       	rjmp	.+2      	; 0x44ca <DIO_u8SetPinDirection+0x23a>
			}
		}
	}
	else
	{
		Local_u8ReturnedState = NOT_OK;
    44c8:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnedState;
    44ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    44cc:	2e 96       	adiw	r28, 0x0e	; 14
    44ce:	0f b6       	in	r0, 0x3f	; 63
    44d0:	f8 94       	cli
    44d2:	de bf       	out	0x3e, r29	; 62
    44d4:	0f be       	out	0x3f, r0	; 63
    44d6:	cd bf       	out	0x3d, r28	; 61
    44d8:	cf 91       	pop	r28
    44da:	df 91       	pop	r29
    44dc:	08 95       	ret

000044de <DIO_u8SetPinValue>:
u8 DIO_u8SetPinValue(u8 Copy_u8PortId,u8 Copy_u8PinId,u8 Copy_u8PinValue)
{
    44de:	df 93       	push	r29
    44e0:	cf 93       	push	r28
    44e2:	cd b7       	in	r28, 0x3d	; 61
    44e4:	de b7       	in	r29, 0x3e	; 62
    44e6:	2e 97       	sbiw	r28, 0x0e	; 14
    44e8:	0f b6       	in	r0, 0x3f	; 63
    44ea:	f8 94       	cli
    44ec:	de bf       	out	0x3e, r29	; 62
    44ee:	0f be       	out	0x3f, r0	; 63
    44f0:	cd bf       	out	0x3d, r28	; 61
    44f2:	8a 83       	std	Y+2, r24	; 0x02
    44f4:	6b 83       	std	Y+3, r22	; 0x03
    44f6:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ReturnedState=OK;
    44f8:	81 e0       	ldi	r24, 0x01	; 1
    44fa:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD)&&(Copy_u8PinId <= DIO_u8_PIN7)&&(Copy_u8PinValue <= DIO_u8_PIN_HIGH))
    44fc:	8a 81       	ldd	r24, Y+2	; 0x02
    44fe:	84 30       	cpi	r24, 0x04	; 4
    4500:	08 f0       	brcs	.+2      	; 0x4504 <DIO_u8SetPinValue+0x26>
    4502:	09 c1       	rjmp	.+530    	; 0x4716 <DIO_u8SetPinValue+0x238>
    4504:	8b 81       	ldd	r24, Y+3	; 0x03
    4506:	88 30       	cpi	r24, 0x08	; 8
    4508:	08 f0       	brcs	.+2      	; 0x450c <DIO_u8SetPinValue+0x2e>
    450a:	05 c1       	rjmp	.+522    	; 0x4716 <DIO_u8SetPinValue+0x238>
    450c:	8c 81       	ldd	r24, Y+4	; 0x04
    450e:	82 30       	cpi	r24, 0x02	; 2
    4510:	08 f0       	brcs	.+2      	; 0x4514 <DIO_u8SetPinValue+0x36>
    4512:	01 c1       	rjmp	.+514    	; 0x4716 <DIO_u8SetPinValue+0x238>
	{
		switch(Copy_u8PortId)
    4514:	8a 81       	ldd	r24, Y+2	; 0x02
    4516:	28 2f       	mov	r18, r24
    4518:	30 e0       	ldi	r19, 0x00	; 0
    451a:	3e 87       	std	Y+14, r19	; 0x0e
    451c:	2d 87       	std	Y+13, r18	; 0x0d
    451e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4520:	9e 85       	ldd	r25, Y+14	; 0x0e
    4522:	81 30       	cpi	r24, 0x01	; 1
    4524:	91 05       	cpc	r25, r1
    4526:	09 f4       	brne	.+2      	; 0x452a <DIO_u8SetPinValue+0x4c>
    4528:	4f c0       	rjmp	.+158    	; 0x45c8 <DIO_u8SetPinValue+0xea>
    452a:	2d 85       	ldd	r18, Y+13	; 0x0d
    452c:	3e 85       	ldd	r19, Y+14	; 0x0e
    452e:	22 30       	cpi	r18, 0x02	; 2
    4530:	31 05       	cpc	r19, r1
    4532:	2c f4       	brge	.+10     	; 0x453e <DIO_u8SetPinValue+0x60>
    4534:	8d 85       	ldd	r24, Y+13	; 0x0d
    4536:	9e 85       	ldd	r25, Y+14	; 0x0e
    4538:	00 97       	sbiw	r24, 0x00	; 0
    453a:	71 f0       	breq	.+28     	; 0x4558 <DIO_u8SetPinValue+0x7a>
    453c:	ed c0       	rjmp	.+474    	; 0x4718 <DIO_u8SetPinValue+0x23a>
    453e:	2d 85       	ldd	r18, Y+13	; 0x0d
    4540:	3e 85       	ldd	r19, Y+14	; 0x0e
    4542:	22 30       	cpi	r18, 0x02	; 2
    4544:	31 05       	cpc	r19, r1
    4546:	09 f4       	brne	.+2      	; 0x454a <DIO_u8SetPinValue+0x6c>
    4548:	77 c0       	rjmp	.+238    	; 0x4638 <DIO_u8SetPinValue+0x15a>
    454a:	8d 85       	ldd	r24, Y+13	; 0x0d
    454c:	9e 85       	ldd	r25, Y+14	; 0x0e
    454e:	83 30       	cpi	r24, 0x03	; 3
    4550:	91 05       	cpc	r25, r1
    4552:	09 f4       	brne	.+2      	; 0x4556 <DIO_u8SetPinValue+0x78>
    4554:	a9 c0       	rjmp	.+338    	; 0x46a8 <DIO_u8SetPinValue+0x1ca>
    4556:	e0 c0       	rjmp	.+448    	; 0x4718 <DIO_u8SetPinValue+0x23a>
		{
			case(DIO_u8_PORTA):
			{
				switch(Copy_u8PinValue)
    4558:	8c 81       	ldd	r24, Y+4	; 0x04
    455a:	28 2f       	mov	r18, r24
    455c:	30 e0       	ldi	r19, 0x00	; 0
    455e:	3c 87       	std	Y+12, r19	; 0x0c
    4560:	2b 87       	std	Y+11, r18	; 0x0b
    4562:	8b 85       	ldd	r24, Y+11	; 0x0b
    4564:	9c 85       	ldd	r25, Y+12	; 0x0c
    4566:	00 97       	sbiw	r24, 0x00	; 0
    4568:	d1 f0       	breq	.+52     	; 0x459e <DIO_u8SetPinValue+0xc0>
    456a:	2b 85       	ldd	r18, Y+11	; 0x0b
    456c:	3c 85       	ldd	r19, Y+12	; 0x0c
    456e:	21 30       	cpi	r18, 0x01	; 1
    4570:	31 05       	cpc	r19, r1
    4572:	09 f0       	breq	.+2      	; 0x4576 <DIO_u8SetPinValue+0x98>
    4574:	d1 c0       	rjmp	.+418    	; 0x4718 <DIO_u8SetPinValue+0x23a>
				{
					case(DIO_u8_PIN_HIGH):
					{
						SET_BIT(PORTA_u8_REG,Copy_u8PinId);
    4576:	ab e3       	ldi	r26, 0x3B	; 59
    4578:	b0 e0       	ldi	r27, 0x00	; 0
    457a:	eb e3       	ldi	r30, 0x3B	; 59
    457c:	f0 e0       	ldi	r31, 0x00	; 0
    457e:	80 81       	ld	r24, Z
    4580:	48 2f       	mov	r20, r24
    4582:	8b 81       	ldd	r24, Y+3	; 0x03
    4584:	28 2f       	mov	r18, r24
    4586:	30 e0       	ldi	r19, 0x00	; 0
    4588:	81 e0       	ldi	r24, 0x01	; 1
    458a:	90 e0       	ldi	r25, 0x00	; 0
    458c:	02 2e       	mov	r0, r18
    458e:	02 c0       	rjmp	.+4      	; 0x4594 <DIO_u8SetPinValue+0xb6>
    4590:	88 0f       	add	r24, r24
    4592:	99 1f       	adc	r25, r25
    4594:	0a 94       	dec	r0
    4596:	e2 f7       	brpl	.-8      	; 0x4590 <DIO_u8SetPinValue+0xb2>
    4598:	84 2b       	or	r24, r20
    459a:	8c 93       	st	X, r24
    459c:	bd c0       	rjmp	.+378    	; 0x4718 <DIO_u8SetPinValue+0x23a>
						break;
					}
					case(DIO_u8_PIN_LOW):
					{
						CLEAR_BIT(PORTA_u8_REG,Copy_u8PinId);
    459e:	ab e3       	ldi	r26, 0x3B	; 59
    45a0:	b0 e0       	ldi	r27, 0x00	; 0
    45a2:	eb e3       	ldi	r30, 0x3B	; 59
    45a4:	f0 e0       	ldi	r31, 0x00	; 0
    45a6:	80 81       	ld	r24, Z
    45a8:	48 2f       	mov	r20, r24
    45aa:	8b 81       	ldd	r24, Y+3	; 0x03
    45ac:	28 2f       	mov	r18, r24
    45ae:	30 e0       	ldi	r19, 0x00	; 0
    45b0:	81 e0       	ldi	r24, 0x01	; 1
    45b2:	90 e0       	ldi	r25, 0x00	; 0
    45b4:	02 2e       	mov	r0, r18
    45b6:	02 c0       	rjmp	.+4      	; 0x45bc <DIO_u8SetPinValue+0xde>
    45b8:	88 0f       	add	r24, r24
    45ba:	99 1f       	adc	r25, r25
    45bc:	0a 94       	dec	r0
    45be:	e2 f7       	brpl	.-8      	; 0x45b8 <DIO_u8SetPinValue+0xda>
    45c0:	80 95       	com	r24
    45c2:	84 23       	and	r24, r20
    45c4:	8c 93       	st	X, r24
    45c6:	a8 c0       	rjmp	.+336    	; 0x4718 <DIO_u8SetPinValue+0x23a>
				}
				break;
			}
			case(DIO_u8_PORTB):
			{
				switch(Copy_u8PinValue)
    45c8:	8c 81       	ldd	r24, Y+4	; 0x04
    45ca:	28 2f       	mov	r18, r24
    45cc:	30 e0       	ldi	r19, 0x00	; 0
    45ce:	3a 87       	std	Y+10, r19	; 0x0a
    45d0:	29 87       	std	Y+9, r18	; 0x09
    45d2:	89 85       	ldd	r24, Y+9	; 0x09
    45d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    45d6:	00 97       	sbiw	r24, 0x00	; 0
    45d8:	d1 f0       	breq	.+52     	; 0x460e <DIO_u8SetPinValue+0x130>
    45da:	29 85       	ldd	r18, Y+9	; 0x09
    45dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    45de:	21 30       	cpi	r18, 0x01	; 1
    45e0:	31 05       	cpc	r19, r1
    45e2:	09 f0       	breq	.+2      	; 0x45e6 <DIO_u8SetPinValue+0x108>
    45e4:	99 c0       	rjmp	.+306    	; 0x4718 <DIO_u8SetPinValue+0x23a>
				{
					case(DIO_u8_PIN_HIGH):
					{
						SET_BIT(PORTB_u8_REG,Copy_u8PinId);
    45e6:	a8 e3       	ldi	r26, 0x38	; 56
    45e8:	b0 e0       	ldi	r27, 0x00	; 0
    45ea:	e8 e3       	ldi	r30, 0x38	; 56
    45ec:	f0 e0       	ldi	r31, 0x00	; 0
    45ee:	80 81       	ld	r24, Z
    45f0:	48 2f       	mov	r20, r24
    45f2:	8b 81       	ldd	r24, Y+3	; 0x03
    45f4:	28 2f       	mov	r18, r24
    45f6:	30 e0       	ldi	r19, 0x00	; 0
    45f8:	81 e0       	ldi	r24, 0x01	; 1
    45fa:	90 e0       	ldi	r25, 0x00	; 0
    45fc:	02 2e       	mov	r0, r18
    45fe:	02 c0       	rjmp	.+4      	; 0x4604 <DIO_u8SetPinValue+0x126>
    4600:	88 0f       	add	r24, r24
    4602:	99 1f       	adc	r25, r25
    4604:	0a 94       	dec	r0
    4606:	e2 f7       	brpl	.-8      	; 0x4600 <DIO_u8SetPinValue+0x122>
    4608:	84 2b       	or	r24, r20
    460a:	8c 93       	st	X, r24
    460c:	85 c0       	rjmp	.+266    	; 0x4718 <DIO_u8SetPinValue+0x23a>
						break;
					}
					case(DIO_u8_PIN_LOW):
					{
						CLEAR_BIT(PORTB_u8_REG,Copy_u8PinId);
    460e:	a8 e3       	ldi	r26, 0x38	; 56
    4610:	b0 e0       	ldi	r27, 0x00	; 0
    4612:	e8 e3       	ldi	r30, 0x38	; 56
    4614:	f0 e0       	ldi	r31, 0x00	; 0
    4616:	80 81       	ld	r24, Z
    4618:	48 2f       	mov	r20, r24
    461a:	8b 81       	ldd	r24, Y+3	; 0x03
    461c:	28 2f       	mov	r18, r24
    461e:	30 e0       	ldi	r19, 0x00	; 0
    4620:	81 e0       	ldi	r24, 0x01	; 1
    4622:	90 e0       	ldi	r25, 0x00	; 0
    4624:	02 2e       	mov	r0, r18
    4626:	02 c0       	rjmp	.+4      	; 0x462c <DIO_u8SetPinValue+0x14e>
    4628:	88 0f       	add	r24, r24
    462a:	99 1f       	adc	r25, r25
    462c:	0a 94       	dec	r0
    462e:	e2 f7       	brpl	.-8      	; 0x4628 <DIO_u8SetPinValue+0x14a>
    4630:	80 95       	com	r24
    4632:	84 23       	and	r24, r20
    4634:	8c 93       	st	X, r24
    4636:	70 c0       	rjmp	.+224    	; 0x4718 <DIO_u8SetPinValue+0x23a>
				}
				break;
			}
			case(DIO_u8_PORTC):
			{
				switch(Copy_u8PinValue)
    4638:	8c 81       	ldd	r24, Y+4	; 0x04
    463a:	28 2f       	mov	r18, r24
    463c:	30 e0       	ldi	r19, 0x00	; 0
    463e:	38 87       	std	Y+8, r19	; 0x08
    4640:	2f 83       	std	Y+7, r18	; 0x07
    4642:	8f 81       	ldd	r24, Y+7	; 0x07
    4644:	98 85       	ldd	r25, Y+8	; 0x08
    4646:	00 97       	sbiw	r24, 0x00	; 0
    4648:	d1 f0       	breq	.+52     	; 0x467e <DIO_u8SetPinValue+0x1a0>
    464a:	2f 81       	ldd	r18, Y+7	; 0x07
    464c:	38 85       	ldd	r19, Y+8	; 0x08
    464e:	21 30       	cpi	r18, 0x01	; 1
    4650:	31 05       	cpc	r19, r1
    4652:	09 f0       	breq	.+2      	; 0x4656 <DIO_u8SetPinValue+0x178>
    4654:	61 c0       	rjmp	.+194    	; 0x4718 <DIO_u8SetPinValue+0x23a>
				{
					case(DIO_u8_PIN_HIGH):
					{
						SET_BIT(PORTC_u8_REG,Copy_u8PinId);
    4656:	a5 e3       	ldi	r26, 0x35	; 53
    4658:	b0 e0       	ldi	r27, 0x00	; 0
    465a:	e5 e3       	ldi	r30, 0x35	; 53
    465c:	f0 e0       	ldi	r31, 0x00	; 0
    465e:	80 81       	ld	r24, Z
    4660:	48 2f       	mov	r20, r24
    4662:	8b 81       	ldd	r24, Y+3	; 0x03
    4664:	28 2f       	mov	r18, r24
    4666:	30 e0       	ldi	r19, 0x00	; 0
    4668:	81 e0       	ldi	r24, 0x01	; 1
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	02 2e       	mov	r0, r18
    466e:	02 c0       	rjmp	.+4      	; 0x4674 <DIO_u8SetPinValue+0x196>
    4670:	88 0f       	add	r24, r24
    4672:	99 1f       	adc	r25, r25
    4674:	0a 94       	dec	r0
    4676:	e2 f7       	brpl	.-8      	; 0x4670 <DIO_u8SetPinValue+0x192>
    4678:	84 2b       	or	r24, r20
    467a:	8c 93       	st	X, r24
    467c:	4d c0       	rjmp	.+154    	; 0x4718 <DIO_u8SetPinValue+0x23a>
						break;
					}
					case(DIO_u8_PIN_LOW):
					{
						CLEAR_BIT(PORTC_u8_REG,Copy_u8PinId);
    467e:	a5 e3       	ldi	r26, 0x35	; 53
    4680:	b0 e0       	ldi	r27, 0x00	; 0
    4682:	e5 e3       	ldi	r30, 0x35	; 53
    4684:	f0 e0       	ldi	r31, 0x00	; 0
    4686:	80 81       	ld	r24, Z
    4688:	48 2f       	mov	r20, r24
    468a:	8b 81       	ldd	r24, Y+3	; 0x03
    468c:	28 2f       	mov	r18, r24
    468e:	30 e0       	ldi	r19, 0x00	; 0
    4690:	81 e0       	ldi	r24, 0x01	; 1
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	02 2e       	mov	r0, r18
    4696:	02 c0       	rjmp	.+4      	; 0x469c <DIO_u8SetPinValue+0x1be>
    4698:	88 0f       	add	r24, r24
    469a:	99 1f       	adc	r25, r25
    469c:	0a 94       	dec	r0
    469e:	e2 f7       	brpl	.-8      	; 0x4698 <DIO_u8SetPinValue+0x1ba>
    46a0:	80 95       	com	r24
    46a2:	84 23       	and	r24, r20
    46a4:	8c 93       	st	X, r24
    46a6:	38 c0       	rjmp	.+112    	; 0x4718 <DIO_u8SetPinValue+0x23a>
				}
				break;
			}
			case(DIO_u8_PORTD):
			{
				switch(Copy_u8PinValue)
    46a8:	8c 81       	ldd	r24, Y+4	; 0x04
    46aa:	28 2f       	mov	r18, r24
    46ac:	30 e0       	ldi	r19, 0x00	; 0
    46ae:	3e 83       	std	Y+6, r19	; 0x06
    46b0:	2d 83       	std	Y+5, r18	; 0x05
    46b2:	8d 81       	ldd	r24, Y+5	; 0x05
    46b4:	9e 81       	ldd	r25, Y+6	; 0x06
    46b6:	00 97       	sbiw	r24, 0x00	; 0
    46b8:	c9 f0       	breq	.+50     	; 0x46ec <DIO_u8SetPinValue+0x20e>
    46ba:	2d 81       	ldd	r18, Y+5	; 0x05
    46bc:	3e 81       	ldd	r19, Y+6	; 0x06
    46be:	21 30       	cpi	r18, 0x01	; 1
    46c0:	31 05       	cpc	r19, r1
    46c2:	51 f5       	brne	.+84     	; 0x4718 <DIO_u8SetPinValue+0x23a>
				{
					case(DIO_u8_PIN_HIGH):
					{
						SET_BIT(PORTD_u8_REG,Copy_u8PinId);
    46c4:	a2 e3       	ldi	r26, 0x32	; 50
    46c6:	b0 e0       	ldi	r27, 0x00	; 0
    46c8:	e2 e3       	ldi	r30, 0x32	; 50
    46ca:	f0 e0       	ldi	r31, 0x00	; 0
    46cc:	80 81       	ld	r24, Z
    46ce:	48 2f       	mov	r20, r24
    46d0:	8b 81       	ldd	r24, Y+3	; 0x03
    46d2:	28 2f       	mov	r18, r24
    46d4:	30 e0       	ldi	r19, 0x00	; 0
    46d6:	81 e0       	ldi	r24, 0x01	; 1
    46d8:	90 e0       	ldi	r25, 0x00	; 0
    46da:	02 2e       	mov	r0, r18
    46dc:	02 c0       	rjmp	.+4      	; 0x46e2 <DIO_u8SetPinValue+0x204>
    46de:	88 0f       	add	r24, r24
    46e0:	99 1f       	adc	r25, r25
    46e2:	0a 94       	dec	r0
    46e4:	e2 f7       	brpl	.-8      	; 0x46de <DIO_u8SetPinValue+0x200>
    46e6:	84 2b       	or	r24, r20
    46e8:	8c 93       	st	X, r24
    46ea:	16 c0       	rjmp	.+44     	; 0x4718 <DIO_u8SetPinValue+0x23a>
						break;
					}
					case(DIO_u8_PIN_LOW):
					{
						CLEAR_BIT(PORTD_u8_REG,Copy_u8PinId);
    46ec:	a2 e3       	ldi	r26, 0x32	; 50
    46ee:	b0 e0       	ldi	r27, 0x00	; 0
    46f0:	e2 e3       	ldi	r30, 0x32	; 50
    46f2:	f0 e0       	ldi	r31, 0x00	; 0
    46f4:	80 81       	ld	r24, Z
    46f6:	48 2f       	mov	r20, r24
    46f8:	8b 81       	ldd	r24, Y+3	; 0x03
    46fa:	28 2f       	mov	r18, r24
    46fc:	30 e0       	ldi	r19, 0x00	; 0
    46fe:	81 e0       	ldi	r24, 0x01	; 1
    4700:	90 e0       	ldi	r25, 0x00	; 0
    4702:	02 2e       	mov	r0, r18
    4704:	02 c0       	rjmp	.+4      	; 0x470a <DIO_u8SetPinValue+0x22c>
    4706:	88 0f       	add	r24, r24
    4708:	99 1f       	adc	r25, r25
    470a:	0a 94       	dec	r0
    470c:	e2 f7       	brpl	.-8      	; 0x4706 <DIO_u8SetPinValue+0x228>
    470e:	80 95       	com	r24
    4710:	84 23       	and	r24, r20
    4712:	8c 93       	st	X, r24
    4714:	01 c0       	rjmp	.+2      	; 0x4718 <DIO_u8SetPinValue+0x23a>
			}
		}
	}
	else
	{
		Local_u8ReturnedState=NOT_OK;
    4716:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnedState;
    4718:	89 81       	ldd	r24, Y+1	; 0x01
}
    471a:	2e 96       	adiw	r28, 0x0e	; 14
    471c:	0f b6       	in	r0, 0x3f	; 63
    471e:	f8 94       	cli
    4720:	de bf       	out	0x3e, r29	; 62
    4722:	0f be       	out	0x3f, r0	; 63
    4724:	cd bf       	out	0x3d, r28	; 61
    4726:	cf 91       	pop	r28
    4728:	df 91       	pop	r29
    472a:	08 95       	ret

0000472c <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue(u8 Copy_u8PortId,u8 Copy_u8PinId)
{
    472c:	df 93       	push	r29
    472e:	cf 93       	push	r28
    4730:	00 d0       	rcall	.+0      	; 0x4732 <DIO_u8GetPinValue+0x6>
    4732:	00 d0       	rcall	.+0      	; 0x4734 <DIO_u8GetPinValue+0x8>
    4734:	0f 92       	push	r0
    4736:	cd b7       	in	r28, 0x3d	; 61
    4738:	de b7       	in	r29, 0x3e	; 62
    473a:	8a 83       	std	Y+2, r24	; 0x02
    473c:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnedState=0;
    473e:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD)&&(Copy_u8PinId <= DIO_u8_PIN7))
    4740:	8a 81       	ldd	r24, Y+2	; 0x02
    4742:	84 30       	cpi	r24, 0x04	; 4
    4744:	08 f0       	brcs	.+2      	; 0x4748 <DIO_u8GetPinValue+0x1c>
    4746:	6b c0       	rjmp	.+214    	; 0x481e <DIO_u8GetPinValue+0xf2>
    4748:	8b 81       	ldd	r24, Y+3	; 0x03
    474a:	88 30       	cpi	r24, 0x08	; 8
    474c:	08 f0       	brcs	.+2      	; 0x4750 <DIO_u8GetPinValue+0x24>
    474e:	67 c0       	rjmp	.+206    	; 0x481e <DIO_u8GetPinValue+0xf2>
	{
		switch(Copy_u8PortId)
    4750:	8a 81       	ldd	r24, Y+2	; 0x02
    4752:	28 2f       	mov	r18, r24
    4754:	30 e0       	ldi	r19, 0x00	; 0
    4756:	3d 83       	std	Y+5, r19	; 0x05
    4758:	2c 83       	std	Y+4, r18	; 0x04
    475a:	4c 81       	ldd	r20, Y+4	; 0x04
    475c:	5d 81       	ldd	r21, Y+5	; 0x05
    475e:	41 30       	cpi	r20, 0x01	; 1
    4760:	51 05       	cpc	r21, r1
    4762:	41 f1       	breq	.+80     	; 0x47b4 <DIO_u8GetPinValue+0x88>
    4764:	8c 81       	ldd	r24, Y+4	; 0x04
    4766:	9d 81       	ldd	r25, Y+5	; 0x05
    4768:	82 30       	cpi	r24, 0x02	; 2
    476a:	91 05       	cpc	r25, r1
    476c:	34 f4       	brge	.+12     	; 0x477a <DIO_u8GetPinValue+0x4e>
    476e:	2c 81       	ldd	r18, Y+4	; 0x04
    4770:	3d 81       	ldd	r19, Y+5	; 0x05
    4772:	21 15       	cp	r18, r1
    4774:	31 05       	cpc	r19, r1
    4776:	61 f0       	breq	.+24     	; 0x4790 <DIO_u8GetPinValue+0x64>
    4778:	52 c0       	rjmp	.+164    	; 0x481e <DIO_u8GetPinValue+0xf2>
    477a:	4c 81       	ldd	r20, Y+4	; 0x04
    477c:	5d 81       	ldd	r21, Y+5	; 0x05
    477e:	42 30       	cpi	r20, 0x02	; 2
    4780:	51 05       	cpc	r21, r1
    4782:	51 f1       	breq	.+84     	; 0x47d8 <DIO_u8GetPinValue+0xac>
    4784:	8c 81       	ldd	r24, Y+4	; 0x04
    4786:	9d 81       	ldd	r25, Y+5	; 0x05
    4788:	83 30       	cpi	r24, 0x03	; 3
    478a:	91 05       	cpc	r25, r1
    478c:	b9 f1       	breq	.+110    	; 0x47fc <DIO_u8GetPinValue+0xd0>
    478e:	47 c0       	rjmp	.+142    	; 0x481e <DIO_u8GetPinValue+0xf2>
		{
			case(DIO_u8_PORTA):
			{
				Local_u8ReturnedState=GET_BIT(PINA_u8_REG,Copy_u8PinId);
    4790:	e9 e3       	ldi	r30, 0x39	; 57
    4792:	f0 e0       	ldi	r31, 0x00	; 0
    4794:	80 81       	ld	r24, Z
    4796:	28 2f       	mov	r18, r24
    4798:	30 e0       	ldi	r19, 0x00	; 0
    479a:	8b 81       	ldd	r24, Y+3	; 0x03
    479c:	88 2f       	mov	r24, r24
    479e:	90 e0       	ldi	r25, 0x00	; 0
    47a0:	a9 01       	movw	r20, r18
    47a2:	02 c0       	rjmp	.+4      	; 0x47a8 <DIO_u8GetPinValue+0x7c>
    47a4:	55 95       	asr	r21
    47a6:	47 95       	ror	r20
    47a8:	8a 95       	dec	r24
    47aa:	e2 f7       	brpl	.-8      	; 0x47a4 <DIO_u8GetPinValue+0x78>
    47ac:	ca 01       	movw	r24, r20
    47ae:	81 70       	andi	r24, 0x01	; 1
    47b0:	89 83       	std	Y+1, r24	; 0x01
    47b2:	35 c0       	rjmp	.+106    	; 0x481e <DIO_u8GetPinValue+0xf2>
				break;
			}
			case(DIO_u8_PORTB):
			{
				Local_u8ReturnedState=GET_BIT(PINB_u8_REG,Copy_u8PinId);
    47b4:	e6 e3       	ldi	r30, 0x36	; 54
    47b6:	f0 e0       	ldi	r31, 0x00	; 0
    47b8:	80 81       	ld	r24, Z
    47ba:	28 2f       	mov	r18, r24
    47bc:	30 e0       	ldi	r19, 0x00	; 0
    47be:	8b 81       	ldd	r24, Y+3	; 0x03
    47c0:	88 2f       	mov	r24, r24
    47c2:	90 e0       	ldi	r25, 0x00	; 0
    47c4:	a9 01       	movw	r20, r18
    47c6:	02 c0       	rjmp	.+4      	; 0x47cc <DIO_u8GetPinValue+0xa0>
    47c8:	55 95       	asr	r21
    47ca:	47 95       	ror	r20
    47cc:	8a 95       	dec	r24
    47ce:	e2 f7       	brpl	.-8      	; 0x47c8 <DIO_u8GetPinValue+0x9c>
    47d0:	ca 01       	movw	r24, r20
    47d2:	81 70       	andi	r24, 0x01	; 1
    47d4:	89 83       	std	Y+1, r24	; 0x01
    47d6:	23 c0       	rjmp	.+70     	; 0x481e <DIO_u8GetPinValue+0xf2>
				break;
			}
			case(DIO_u8_PORTC):
			{
				Local_u8ReturnedState=GET_BIT(PINC_u8_REG,Copy_u8PinId);
    47d8:	e3 e3       	ldi	r30, 0x33	; 51
    47da:	f0 e0       	ldi	r31, 0x00	; 0
    47dc:	80 81       	ld	r24, Z
    47de:	28 2f       	mov	r18, r24
    47e0:	30 e0       	ldi	r19, 0x00	; 0
    47e2:	8b 81       	ldd	r24, Y+3	; 0x03
    47e4:	88 2f       	mov	r24, r24
    47e6:	90 e0       	ldi	r25, 0x00	; 0
    47e8:	a9 01       	movw	r20, r18
    47ea:	02 c0       	rjmp	.+4      	; 0x47f0 <DIO_u8GetPinValue+0xc4>
    47ec:	55 95       	asr	r21
    47ee:	47 95       	ror	r20
    47f0:	8a 95       	dec	r24
    47f2:	e2 f7       	brpl	.-8      	; 0x47ec <DIO_u8GetPinValue+0xc0>
    47f4:	ca 01       	movw	r24, r20
    47f6:	81 70       	andi	r24, 0x01	; 1
    47f8:	89 83       	std	Y+1, r24	; 0x01
    47fa:	11 c0       	rjmp	.+34     	; 0x481e <DIO_u8GetPinValue+0xf2>
				break;
			}
			case(DIO_u8_PORTD):
			{
				Local_u8ReturnedState=GET_BIT(PIND_u8_REG,Copy_u8PinId);
    47fc:	e0 e3       	ldi	r30, 0x30	; 48
    47fe:	f0 e0       	ldi	r31, 0x00	; 0
    4800:	80 81       	ld	r24, Z
    4802:	28 2f       	mov	r18, r24
    4804:	30 e0       	ldi	r19, 0x00	; 0
    4806:	8b 81       	ldd	r24, Y+3	; 0x03
    4808:	88 2f       	mov	r24, r24
    480a:	90 e0       	ldi	r25, 0x00	; 0
    480c:	a9 01       	movw	r20, r18
    480e:	02 c0       	rjmp	.+4      	; 0x4814 <DIO_u8GetPinValue+0xe8>
    4810:	55 95       	asr	r21
    4812:	47 95       	ror	r20
    4814:	8a 95       	dec	r24
    4816:	e2 f7       	brpl	.-8      	; 0x4810 <DIO_u8GetPinValue+0xe4>
    4818:	ca 01       	movw	r24, r20
    481a:	81 70       	andi	r24, 0x01	; 1
    481c:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
		}
	}
	return Local_u8ReturnedState;
    481e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4820:	0f 90       	pop	r0
    4822:	0f 90       	pop	r0
    4824:	0f 90       	pop	r0
    4826:	0f 90       	pop	r0
    4828:	0f 90       	pop	r0
    482a:	cf 91       	pop	r28
    482c:	df 91       	pop	r29
    482e:	08 95       	ret

00004830 <DIO_u8SetPortDirection>:
u8 DIO_u8SetPortDirection(u8 Copy_u8PortId,u8 Copy_u8PortDirection)
{
    4830:	df 93       	push	r29
    4832:	cf 93       	push	r28
    4834:	cd b7       	in	r28, 0x3d	; 61
    4836:	de b7       	in	r29, 0x3e	; 62
    4838:	2d 97       	sbiw	r28, 0x0d	; 13
    483a:	0f b6       	in	r0, 0x3f	; 63
    483c:	f8 94       	cli
    483e:	de bf       	out	0x3e, r29	; 62
    4840:	0f be       	out	0x3f, r0	; 63
    4842:	cd bf       	out	0x3d, r28	; 61
    4844:	8a 83       	std	Y+2, r24	; 0x02
    4846:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnedState=OK;
    4848:	81 e0       	ldi	r24, 0x01	; 1
    484a:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD)&&(Copy_u8PortDirection <= DIO_u8_PORT_OUTPUT))
    484c:	8a 81       	ldd	r24, Y+2	; 0x02
    484e:	84 30       	cpi	r24, 0x04	; 4
    4850:	08 f0       	brcs	.+2      	; 0x4854 <DIO_u8SetPortDirection+0x24>
    4852:	7d c0       	rjmp	.+250    	; 0x494e <DIO_u8SetPortDirection+0x11e>
	{
		switch(Copy_u8PortId)
    4854:	8a 81       	ldd	r24, Y+2	; 0x02
    4856:	28 2f       	mov	r18, r24
    4858:	30 e0       	ldi	r19, 0x00	; 0
    485a:	3d 87       	std	Y+13, r19	; 0x0d
    485c:	2c 87       	std	Y+12, r18	; 0x0c
    485e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4860:	9d 85       	ldd	r25, Y+13	; 0x0d
    4862:	81 30       	cpi	r24, 0x01	; 1
    4864:	91 05       	cpc	r25, r1
    4866:	71 f1       	breq	.+92     	; 0x48c4 <DIO_u8SetPortDirection+0x94>
    4868:	2c 85       	ldd	r18, Y+12	; 0x0c
    486a:	3d 85       	ldd	r19, Y+13	; 0x0d
    486c:	22 30       	cpi	r18, 0x02	; 2
    486e:	31 05       	cpc	r19, r1
    4870:	2c f4       	brge	.+10     	; 0x487c <DIO_u8SetPortDirection+0x4c>
    4872:	8c 85       	ldd	r24, Y+12	; 0x0c
    4874:	9d 85       	ldd	r25, Y+13	; 0x0d
    4876:	00 97       	sbiw	r24, 0x00	; 0
    4878:	69 f0       	breq	.+26     	; 0x4894 <DIO_u8SetPortDirection+0x64>
    487a:	6a c0       	rjmp	.+212    	; 0x4950 <DIO_u8SetPortDirection+0x120>
    487c:	2c 85       	ldd	r18, Y+12	; 0x0c
    487e:	3d 85       	ldd	r19, Y+13	; 0x0d
    4880:	22 30       	cpi	r18, 0x02	; 2
    4882:	31 05       	cpc	r19, r1
    4884:	b1 f1       	breq	.+108    	; 0x48f2 <DIO_u8SetPortDirection+0xc2>
    4886:	8c 85       	ldd	r24, Y+12	; 0x0c
    4888:	9d 85       	ldd	r25, Y+13	; 0x0d
    488a:	83 30       	cpi	r24, 0x03	; 3
    488c:	91 05       	cpc	r25, r1
    488e:	09 f4       	brne	.+2      	; 0x4892 <DIO_u8SetPortDirection+0x62>
    4890:	47 c0       	rjmp	.+142    	; 0x4920 <DIO_u8SetPortDirection+0xf0>
    4892:	5e c0       	rjmp	.+188    	; 0x4950 <DIO_u8SetPortDirection+0x120>
		{
			case(DIO_u8_PORTA):
			{
				switch(Copy_u8PortDirection)
    4894:	8b 81       	ldd	r24, Y+3	; 0x03
    4896:	28 2f       	mov	r18, r24
    4898:	30 e0       	ldi	r19, 0x00	; 0
    489a:	3b 87       	std	Y+11, r19	; 0x0b
    489c:	2a 87       	std	Y+10, r18	; 0x0a
    489e:	8a 85       	ldd	r24, Y+10	; 0x0a
    48a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    48a2:	00 97       	sbiw	r24, 0x00	; 0
    48a4:	59 f0       	breq	.+22     	; 0x48bc <DIO_u8SetPortDirection+0x8c>
    48a6:	2a 85       	ldd	r18, Y+10	; 0x0a
    48a8:	3b 85       	ldd	r19, Y+11	; 0x0b
    48aa:	2f 3f       	cpi	r18, 0xFF	; 255
    48ac:	31 05       	cpc	r19, r1
    48ae:	09 f0       	breq	.+2      	; 0x48b2 <DIO_u8SetPortDirection+0x82>
    48b0:	4f c0       	rjmp	.+158    	; 0x4950 <DIO_u8SetPortDirection+0x120>
				{
					case(DIO_u8_PORT_OUTPUT):
					{
						DDRA_u8_REG=DIO_u8_PORT_OUTPUT;
    48b2:	ea e3       	ldi	r30, 0x3A	; 58
    48b4:	f0 e0       	ldi	r31, 0x00	; 0
    48b6:	8f ef       	ldi	r24, 0xFF	; 255
    48b8:	80 83       	st	Z, r24
    48ba:	4a c0       	rjmp	.+148    	; 0x4950 <DIO_u8SetPortDirection+0x120>
						break;
					}
					case(DIO_u8_PORT_INPUT):
					{
						DDRA_u8_REG=DIO_u8_PORT_INPUT;
    48bc:	ea e3       	ldi	r30, 0x3A	; 58
    48be:	f0 e0       	ldi	r31, 0x00	; 0
    48c0:	10 82       	st	Z, r1
    48c2:	46 c0       	rjmp	.+140    	; 0x4950 <DIO_u8SetPortDirection+0x120>
				}
				break;
			}
			case(DIO_u8_PORTB):
			{
				switch(Copy_u8PortDirection)
    48c4:	8b 81       	ldd	r24, Y+3	; 0x03
    48c6:	28 2f       	mov	r18, r24
    48c8:	30 e0       	ldi	r19, 0x00	; 0
    48ca:	39 87       	std	Y+9, r19	; 0x09
    48cc:	28 87       	std	Y+8, r18	; 0x08
    48ce:	88 85       	ldd	r24, Y+8	; 0x08
    48d0:	99 85       	ldd	r25, Y+9	; 0x09
    48d2:	00 97       	sbiw	r24, 0x00	; 0
    48d4:	51 f0       	breq	.+20     	; 0x48ea <DIO_u8SetPortDirection+0xba>
    48d6:	28 85       	ldd	r18, Y+8	; 0x08
    48d8:	39 85       	ldd	r19, Y+9	; 0x09
    48da:	2f 3f       	cpi	r18, 0xFF	; 255
    48dc:	31 05       	cpc	r19, r1
    48de:	c1 f5       	brne	.+112    	; 0x4950 <DIO_u8SetPortDirection+0x120>
				{
					case(DIO_u8_PORT_OUTPUT):
					{
						DDRB_u8_REG=DIO_u8_PORT_OUTPUT;
    48e0:	e7 e3       	ldi	r30, 0x37	; 55
    48e2:	f0 e0       	ldi	r31, 0x00	; 0
    48e4:	8f ef       	ldi	r24, 0xFF	; 255
    48e6:	80 83       	st	Z, r24
    48e8:	33 c0       	rjmp	.+102    	; 0x4950 <DIO_u8SetPortDirection+0x120>
						break;
					}
					case(DIO_u8_PORT_INPUT):
					{
						DDRB_u8_REG=DIO_u8_PORT_INPUT;
    48ea:	e7 e3       	ldi	r30, 0x37	; 55
    48ec:	f0 e0       	ldi	r31, 0x00	; 0
    48ee:	10 82       	st	Z, r1
    48f0:	2f c0       	rjmp	.+94     	; 0x4950 <DIO_u8SetPortDirection+0x120>
				}
				break;
			}
			case(DIO_u8_PORTC):
			{
				switch(Copy_u8PortDirection)
    48f2:	8b 81       	ldd	r24, Y+3	; 0x03
    48f4:	28 2f       	mov	r18, r24
    48f6:	30 e0       	ldi	r19, 0x00	; 0
    48f8:	3f 83       	std	Y+7, r19	; 0x07
    48fa:	2e 83       	std	Y+6, r18	; 0x06
    48fc:	8e 81       	ldd	r24, Y+6	; 0x06
    48fe:	9f 81       	ldd	r25, Y+7	; 0x07
    4900:	00 97       	sbiw	r24, 0x00	; 0
    4902:	51 f0       	breq	.+20     	; 0x4918 <DIO_u8SetPortDirection+0xe8>
    4904:	2e 81       	ldd	r18, Y+6	; 0x06
    4906:	3f 81       	ldd	r19, Y+7	; 0x07
    4908:	2f 3f       	cpi	r18, 0xFF	; 255
    490a:	31 05       	cpc	r19, r1
    490c:	09 f5       	brne	.+66     	; 0x4950 <DIO_u8SetPortDirection+0x120>
				{
					case(DIO_u8_PORT_OUTPUT):
					{
						DDRC_u8_REG=DIO_u8_PORT_OUTPUT;
    490e:	e4 e3       	ldi	r30, 0x34	; 52
    4910:	f0 e0       	ldi	r31, 0x00	; 0
    4912:	8f ef       	ldi	r24, 0xFF	; 255
    4914:	80 83       	st	Z, r24
    4916:	1c c0       	rjmp	.+56     	; 0x4950 <DIO_u8SetPortDirection+0x120>
						break;
					}
					case(DIO_u8_PORT_INPUT):
					{
						DDRC_u8_REG=DIO_u8_PORT_INPUT;
    4918:	e4 e3       	ldi	r30, 0x34	; 52
    491a:	f0 e0       	ldi	r31, 0x00	; 0
    491c:	10 82       	st	Z, r1
    491e:	18 c0       	rjmp	.+48     	; 0x4950 <DIO_u8SetPortDirection+0x120>
				}
				break;
			}
			case(DIO_u8_PORTD):
			{
				switch(Copy_u8PortDirection)
    4920:	8b 81       	ldd	r24, Y+3	; 0x03
    4922:	28 2f       	mov	r18, r24
    4924:	30 e0       	ldi	r19, 0x00	; 0
    4926:	3d 83       	std	Y+5, r19	; 0x05
    4928:	2c 83       	std	Y+4, r18	; 0x04
    492a:	8c 81       	ldd	r24, Y+4	; 0x04
    492c:	9d 81       	ldd	r25, Y+5	; 0x05
    492e:	00 97       	sbiw	r24, 0x00	; 0
    4930:	51 f0       	breq	.+20     	; 0x4946 <DIO_u8SetPortDirection+0x116>
    4932:	2c 81       	ldd	r18, Y+4	; 0x04
    4934:	3d 81       	ldd	r19, Y+5	; 0x05
    4936:	2f 3f       	cpi	r18, 0xFF	; 255
    4938:	31 05       	cpc	r19, r1
    493a:	51 f4       	brne	.+20     	; 0x4950 <DIO_u8SetPortDirection+0x120>
				{
					case(DIO_u8_PORT_OUTPUT):
					{
						DDRD_u8_REG=DIO_u8_PORT_OUTPUT;
    493c:	e1 e3       	ldi	r30, 0x31	; 49
    493e:	f0 e0       	ldi	r31, 0x00	; 0
    4940:	8f ef       	ldi	r24, 0xFF	; 255
    4942:	80 83       	st	Z, r24
    4944:	05 c0       	rjmp	.+10     	; 0x4950 <DIO_u8SetPortDirection+0x120>
						break;
					}
					case(DIO_u8_PORT_INPUT):
					{
						DDRD_u8_REG=DIO_u8_PORT_INPUT;
    4946:	e1 e3       	ldi	r30, 0x31	; 49
    4948:	f0 e0       	ldi	r31, 0x00	; 0
    494a:	10 82       	st	Z, r1
    494c:	01 c0       	rjmp	.+2      	; 0x4950 <DIO_u8SetPortDirection+0x120>
	          
		}
	}
	else
	{
		Local_u8ReturnedState=NOT_OK;
    494e:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnedState;
    4950:	89 81       	ldd	r24, Y+1	; 0x01
}
    4952:	2d 96       	adiw	r28, 0x0d	; 13
    4954:	0f b6       	in	r0, 0x3f	; 63
    4956:	f8 94       	cli
    4958:	de bf       	out	0x3e, r29	; 62
    495a:	0f be       	out	0x3f, r0	; 63
    495c:	cd bf       	out	0x3d, r28	; 61
    495e:	cf 91       	pop	r28
    4960:	df 91       	pop	r29
    4962:	08 95       	ret

00004964 <DIO_u8SetPortValue>:
u8 DIO_u8SetPortValue(u8 Copy_u8PortId,u8 Copy_u8PortValue)
{
    4964:	df 93       	push	r29
    4966:	cf 93       	push	r28
    4968:	00 d0       	rcall	.+0      	; 0x496a <DIO_u8SetPortValue+0x6>
    496a:	00 d0       	rcall	.+0      	; 0x496c <DIO_u8SetPortValue+0x8>
    496c:	0f 92       	push	r0
    496e:	cd b7       	in	r28, 0x3d	; 61
    4970:	de b7       	in	r29, 0x3e	; 62
    4972:	8a 83       	std	Y+2, r24	; 0x02
    4974:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnedState=OK;
    4976:	81 e0       	ldi	r24, 0x01	; 1
    4978:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PortId <= DIO_u8_PORTD)
    497a:	8a 81       	ldd	r24, Y+2	; 0x02
    497c:	84 30       	cpi	r24, 0x04	; 4
    497e:	98 f5       	brcc	.+102    	; 0x49e6 <DIO_u8SetPortValue+0x82>
	{
		switch(Copy_u8PortId)
    4980:	8a 81       	ldd	r24, Y+2	; 0x02
    4982:	28 2f       	mov	r18, r24
    4984:	30 e0       	ldi	r19, 0x00	; 0
    4986:	3d 83       	std	Y+5, r19	; 0x05
    4988:	2c 83       	std	Y+4, r18	; 0x04
    498a:	8c 81       	ldd	r24, Y+4	; 0x04
    498c:	9d 81       	ldd	r25, Y+5	; 0x05
    498e:	81 30       	cpi	r24, 0x01	; 1
    4990:	91 05       	cpc	r25, r1
    4992:	d1 f0       	breq	.+52     	; 0x49c8 <DIO_u8SetPortValue+0x64>
    4994:	2c 81       	ldd	r18, Y+4	; 0x04
    4996:	3d 81       	ldd	r19, Y+5	; 0x05
    4998:	22 30       	cpi	r18, 0x02	; 2
    499a:	31 05       	cpc	r19, r1
    499c:	2c f4       	brge	.+10     	; 0x49a8 <DIO_u8SetPortValue+0x44>
    499e:	8c 81       	ldd	r24, Y+4	; 0x04
    49a0:	9d 81       	ldd	r25, Y+5	; 0x05
    49a2:	00 97       	sbiw	r24, 0x00	; 0
    49a4:	61 f0       	breq	.+24     	; 0x49be <DIO_u8SetPortValue+0x5a>
    49a6:	20 c0       	rjmp	.+64     	; 0x49e8 <DIO_u8SetPortValue+0x84>
    49a8:	2c 81       	ldd	r18, Y+4	; 0x04
    49aa:	3d 81       	ldd	r19, Y+5	; 0x05
    49ac:	22 30       	cpi	r18, 0x02	; 2
    49ae:	31 05       	cpc	r19, r1
    49b0:	81 f0       	breq	.+32     	; 0x49d2 <DIO_u8SetPortValue+0x6e>
    49b2:	8c 81       	ldd	r24, Y+4	; 0x04
    49b4:	9d 81       	ldd	r25, Y+5	; 0x05
    49b6:	83 30       	cpi	r24, 0x03	; 3
    49b8:	91 05       	cpc	r25, r1
    49ba:	81 f0       	breq	.+32     	; 0x49dc <DIO_u8SetPortValue+0x78>
    49bc:	15 c0       	rjmp	.+42     	; 0x49e8 <DIO_u8SetPortValue+0x84>
		{
			case(DIO_u8_PORTA):
			{
				PORTA_u8_REG=Copy_u8PortValue;
    49be:	eb e3       	ldi	r30, 0x3B	; 59
    49c0:	f0 e0       	ldi	r31, 0x00	; 0
    49c2:	8b 81       	ldd	r24, Y+3	; 0x03
    49c4:	80 83       	st	Z, r24
    49c6:	10 c0       	rjmp	.+32     	; 0x49e8 <DIO_u8SetPortValue+0x84>
				break;
			}
			case(DIO_u8_PORTB):
			{
				PORTB_u8_REG=Copy_u8PortValue;
    49c8:	e8 e3       	ldi	r30, 0x38	; 56
    49ca:	f0 e0       	ldi	r31, 0x00	; 0
    49cc:	8b 81       	ldd	r24, Y+3	; 0x03
    49ce:	80 83       	st	Z, r24
    49d0:	0b c0       	rjmp	.+22     	; 0x49e8 <DIO_u8SetPortValue+0x84>
				break;
			}
			case(DIO_u8_PORTC):
			{
				PORTC_u8_REG=Copy_u8PortValue;
    49d2:	e5 e3       	ldi	r30, 0x35	; 53
    49d4:	f0 e0       	ldi	r31, 0x00	; 0
    49d6:	8b 81       	ldd	r24, Y+3	; 0x03
    49d8:	80 83       	st	Z, r24
    49da:	06 c0       	rjmp	.+12     	; 0x49e8 <DIO_u8SetPortValue+0x84>
				break;
			}
			case(DIO_u8_PORTD):
			{
				PORTD_u8_REG=Copy_u8PortValue;
    49dc:	e2 e3       	ldi	r30, 0x32	; 50
    49de:	f0 e0       	ldi	r31, 0x00	; 0
    49e0:	8b 81       	ldd	r24, Y+3	; 0x03
    49e2:	80 83       	st	Z, r24
    49e4:	01 c0       	rjmp	.+2      	; 0x49e8 <DIO_u8SetPortValue+0x84>
			}
		}
	}
	else
	{
		Local_u8ReturnedState=NOT_OK;
    49e6:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnedState;
    49e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    49ea:	0f 90       	pop	r0
    49ec:	0f 90       	pop	r0
    49ee:	0f 90       	pop	r0
    49f0:	0f 90       	pop	r0
    49f2:	0f 90       	pop	r0
    49f4:	cf 91       	pop	r28
    49f6:	df 91       	pop	r29
    49f8:	08 95       	ret

000049fa <DIO_u8GetPortValue>:
u8 DIO_u8GetPortValue(u8 Copy_u8PortId,u8 *Copy_pu8ReturnedPortValue)
{
    49fa:	df 93       	push	r29
    49fc:	cf 93       	push	r28
    49fe:	00 d0       	rcall	.+0      	; 0x4a00 <DIO_u8GetPortValue+0x6>
    4a00:	00 d0       	rcall	.+0      	; 0x4a02 <DIO_u8GetPortValue+0x8>
    4a02:	00 d0       	rcall	.+0      	; 0x4a04 <DIO_u8GetPortValue+0xa>
    4a04:	cd b7       	in	r28, 0x3d	; 61
    4a06:	de b7       	in	r29, 0x3e	; 62
    4a08:	8a 83       	std	Y+2, r24	; 0x02
    4a0a:	7c 83       	std	Y+4, r23	; 0x04
    4a0c:	6b 83       	std	Y+3, r22	; 0x03
	u8 local_u8ReturnedState=OK;
    4a0e:	81 e0       	ldi	r24, 0x01	; 1
    4a10:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD)&&(Copy_pu8ReturnedPortValue != NULL))
    4a12:	8a 81       	ldd	r24, Y+2	; 0x02
    4a14:	84 30       	cpi	r24, 0x04	; 4
    4a16:	08 f0       	brcs	.+2      	; 0x4a1a <DIO_u8GetPortValue+0x20>
    4a18:	3f c0       	rjmp	.+126    	; 0x4a98 <DIO_u8GetPortValue+0x9e>
    4a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a1e:	00 97       	sbiw	r24, 0x00	; 0
    4a20:	d9 f1       	breq	.+118    	; 0x4a98 <DIO_u8GetPortValue+0x9e>
	{
		switch(Copy_u8PortId)
    4a22:	8a 81       	ldd	r24, Y+2	; 0x02
    4a24:	28 2f       	mov	r18, r24
    4a26:	30 e0       	ldi	r19, 0x00	; 0
    4a28:	3e 83       	std	Y+6, r19	; 0x06
    4a2a:	2d 83       	std	Y+5, r18	; 0x05
    4a2c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a2e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a30:	81 30       	cpi	r24, 0x01	; 1
    4a32:	91 05       	cpc	r25, r1
    4a34:	e1 f0       	breq	.+56     	; 0x4a6e <DIO_u8GetPortValue+0x74>
    4a36:	2d 81       	ldd	r18, Y+5	; 0x05
    4a38:	3e 81       	ldd	r19, Y+6	; 0x06
    4a3a:	22 30       	cpi	r18, 0x02	; 2
    4a3c:	31 05       	cpc	r19, r1
    4a3e:	2c f4       	brge	.+10     	; 0x4a4a <DIO_u8GetPortValue+0x50>
    4a40:	8d 81       	ldd	r24, Y+5	; 0x05
    4a42:	9e 81       	ldd	r25, Y+6	; 0x06
    4a44:	00 97       	sbiw	r24, 0x00	; 0
    4a46:	61 f0       	breq	.+24     	; 0x4a60 <DIO_u8GetPortValue+0x66>
    4a48:	28 c0       	rjmp	.+80     	; 0x4a9a <DIO_u8GetPortValue+0xa0>
    4a4a:	2d 81       	ldd	r18, Y+5	; 0x05
    4a4c:	3e 81       	ldd	r19, Y+6	; 0x06
    4a4e:	22 30       	cpi	r18, 0x02	; 2
    4a50:	31 05       	cpc	r19, r1
    4a52:	a1 f0       	breq	.+40     	; 0x4a7c <DIO_u8GetPortValue+0x82>
    4a54:	8d 81       	ldd	r24, Y+5	; 0x05
    4a56:	9e 81       	ldd	r25, Y+6	; 0x06
    4a58:	83 30       	cpi	r24, 0x03	; 3
    4a5a:	91 05       	cpc	r25, r1
    4a5c:	b1 f0       	breq	.+44     	; 0x4a8a <DIO_u8GetPortValue+0x90>
    4a5e:	1d c0       	rjmp	.+58     	; 0x4a9a <DIO_u8GetPortValue+0xa0>
		{
			case(DIO_u8_PORTA):
			{
				*Copy_pu8ReturnedPortValue=PINA_u8_REG;
    4a60:	e9 e3       	ldi	r30, 0x39	; 57
    4a62:	f0 e0       	ldi	r31, 0x00	; 0
    4a64:	80 81       	ld	r24, Z
    4a66:	eb 81       	ldd	r30, Y+3	; 0x03
    4a68:	fc 81       	ldd	r31, Y+4	; 0x04
    4a6a:	80 83       	st	Z, r24
    4a6c:	16 c0       	rjmp	.+44     	; 0x4a9a <DIO_u8GetPortValue+0xa0>
				break;
			}
			case(DIO_u8_PORTB):
			{
				*Copy_pu8ReturnedPortValue=PINB_u8_REG;
    4a6e:	e6 e3       	ldi	r30, 0x36	; 54
    4a70:	f0 e0       	ldi	r31, 0x00	; 0
    4a72:	80 81       	ld	r24, Z
    4a74:	eb 81       	ldd	r30, Y+3	; 0x03
    4a76:	fc 81       	ldd	r31, Y+4	; 0x04
    4a78:	80 83       	st	Z, r24
    4a7a:	0f c0       	rjmp	.+30     	; 0x4a9a <DIO_u8GetPortValue+0xa0>
				break;
			}
			case(DIO_u8_PORTC):
			{
				*Copy_pu8ReturnedPortValue=PINC_u8_REG;
    4a7c:	e3 e3       	ldi	r30, 0x33	; 51
    4a7e:	f0 e0       	ldi	r31, 0x00	; 0
    4a80:	80 81       	ld	r24, Z
    4a82:	eb 81       	ldd	r30, Y+3	; 0x03
    4a84:	fc 81       	ldd	r31, Y+4	; 0x04
    4a86:	80 83       	st	Z, r24
    4a88:	08 c0       	rjmp	.+16     	; 0x4a9a <DIO_u8GetPortValue+0xa0>
				break;
			}
			case(DIO_u8_PORTD):
			{
				*Copy_pu8ReturnedPortValue=PIND_u8_REG;
    4a8a:	e0 e3       	ldi	r30, 0x30	; 48
    4a8c:	f0 e0       	ldi	r31, 0x00	; 0
    4a8e:	80 81       	ld	r24, Z
    4a90:	eb 81       	ldd	r30, Y+3	; 0x03
    4a92:	fc 81       	ldd	r31, Y+4	; 0x04
    4a94:	80 83       	st	Z, r24
    4a96:	01 c0       	rjmp	.+2      	; 0x4a9a <DIO_u8GetPortValue+0xa0>
			}
		}
	}
	else
	{
		local_u8ReturnedState=NOT_OK;
    4a98:	19 82       	std	Y+1, r1	; 0x01
	}
	return local_u8ReturnedState;
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4a9c:	26 96       	adiw	r28, 0x06	; 6
    4a9e:	0f b6       	in	r0, 0x3f	; 63
    4aa0:	f8 94       	cli
    4aa2:	de bf       	out	0x3e, r29	; 62
    4aa4:	0f be       	out	0x3f, r0	; 63
    4aa6:	cd bf       	out	0x3d, r28	; 61
    4aa8:	cf 91       	pop	r28
    4aaa:	df 91       	pop	r29
    4aac:	08 95       	ret

00004aae <DIO_u8TogglePortValue>:
void DIO_u8TogglePortValue(u8 Copy_u8PortId)
{
    4aae:	df 93       	push	r29
    4ab0:	cf 93       	push	r28
    4ab2:	00 d0       	rcall	.+0      	; 0x4ab4 <DIO_u8TogglePortValue+0x6>
    4ab4:	00 d0       	rcall	.+0      	; 0x4ab6 <DIO_u8TogglePortValue+0x8>
    4ab6:	cd b7       	in	r28, 0x3d	; 61
    4ab8:	de b7       	in	r29, 0x3e	; 62
    4aba:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8TempValue;
	switch(Copy_u8PortId)
    4abc:	8a 81       	ldd	r24, Y+2	; 0x02
    4abe:	28 2f       	mov	r18, r24
    4ac0:	30 e0       	ldi	r19, 0x00	; 0
    4ac2:	3c 83       	std	Y+4, r19	; 0x04
    4ac4:	2b 83       	std	Y+3, r18	; 0x03
    4ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ac8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aca:	81 30       	cpi	r24, 0x01	; 1
    4acc:	91 05       	cpc	r25, r1
    4ace:	31 f1       	breq	.+76     	; 0x4b1c <DIO_u8TogglePortValue+0x6e>
    4ad0:	2b 81       	ldd	r18, Y+3	; 0x03
    4ad2:	3c 81       	ldd	r19, Y+4	; 0x04
    4ad4:	22 30       	cpi	r18, 0x02	; 2
    4ad6:	31 05       	cpc	r19, r1
    4ad8:	2c f4       	brge	.+10     	; 0x4ae4 <DIO_u8TogglePortValue+0x36>
    4ada:	8b 81       	ldd	r24, Y+3	; 0x03
    4adc:	9c 81       	ldd	r25, Y+4	; 0x04
    4ade:	00 97       	sbiw	r24, 0x00	; 0
    4ae0:	61 f0       	breq	.+24     	; 0x4afa <DIO_u8TogglePortValue+0x4c>
    4ae2:	4e c0       	rjmp	.+156    	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
    4ae4:	2b 81       	ldd	r18, Y+3	; 0x03
    4ae6:	3c 81       	ldd	r19, Y+4	; 0x04
    4ae8:	22 30       	cpi	r18, 0x02	; 2
    4aea:	31 05       	cpc	r19, r1
    4aec:	41 f1       	breq	.+80     	; 0x4b3e <DIO_u8TogglePortValue+0x90>
    4aee:	8b 81       	ldd	r24, Y+3	; 0x03
    4af0:	9c 81       	ldd	r25, Y+4	; 0x04
    4af2:	83 30       	cpi	r24, 0x03	; 3
    4af4:	91 05       	cpc	r25, r1
    4af6:	a1 f1       	breq	.+104    	; 0x4b60 <DIO_u8TogglePortValue+0xb2>
    4af8:	43 c0       	rjmp	.+134    	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
	{
		case(DIO_u8_PORTA):
		{
			Local_u8TempValue = PINA_u8_REG;
    4afa:	e9 e3       	ldi	r30, 0x39	; 57
    4afc:	f0 e0       	ldi	r31, 0x00	; 0
    4afe:	80 81       	ld	r24, Z
    4b00:	89 83       	std	Y+1, r24	; 0x01
			if(Local_u8TempValue == 0xff)
    4b02:	89 81       	ldd	r24, Y+1	; 0x01
    4b04:	8f 3f       	cpi	r24, 0xFF	; 255
    4b06:	29 f4       	brne	.+10     	; 0x4b12 <DIO_u8TogglePortValue+0x64>
			{
				DIO_u8SetPortValue(DIO_u8_PORTA,0x00);
    4b08:	80 e0       	ldi	r24, 0x00	; 0
    4b0a:	60 e0       	ldi	r22, 0x00	; 0
    4b0c:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b10:	37 c0       	rjmp	.+110    	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			else
			{
				DIO_u8SetPortValue(DIO_u8_PORTA,0xff);
    4b12:	80 e0       	ldi	r24, 0x00	; 0
    4b14:	6f ef       	ldi	r22, 0xFF	; 255
    4b16:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b1a:	32 c0       	rjmp	.+100    	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			break;
		}
		case(DIO_u8_PORTB):
		{
			Local_u8TempValue = PINB_u8_REG;
    4b1c:	e6 e3       	ldi	r30, 0x36	; 54
    4b1e:	f0 e0       	ldi	r31, 0x00	; 0
    4b20:	80 81       	ld	r24, Z
    4b22:	89 83       	std	Y+1, r24	; 0x01
			if(Local_u8TempValue == 0xff)
    4b24:	89 81       	ldd	r24, Y+1	; 0x01
    4b26:	8f 3f       	cpi	r24, 0xFF	; 255
    4b28:	29 f4       	brne	.+10     	; 0x4b34 <DIO_u8TogglePortValue+0x86>
			{
				DIO_u8SetPortValue(DIO_u8_PORTB,0x00);
    4b2a:	81 e0       	ldi	r24, 0x01	; 1
    4b2c:	60 e0       	ldi	r22, 0x00	; 0
    4b2e:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b32:	26 c0       	rjmp	.+76     	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			else
			{
				DIO_u8SetPortValue(DIO_u8_PORTB,0xff);
    4b34:	81 e0       	ldi	r24, 0x01	; 1
    4b36:	6f ef       	ldi	r22, 0xFF	; 255
    4b38:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b3c:	21 c0       	rjmp	.+66     	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			break;
		}
		case(DIO_u8_PORTC):
		{
			Local_u8TempValue = PINC_u8_REG;
    4b3e:	e3 e3       	ldi	r30, 0x33	; 51
    4b40:	f0 e0       	ldi	r31, 0x00	; 0
    4b42:	80 81       	ld	r24, Z
    4b44:	89 83       	std	Y+1, r24	; 0x01
			if(Local_u8TempValue == 0xff)
    4b46:	89 81       	ldd	r24, Y+1	; 0x01
    4b48:	8f 3f       	cpi	r24, 0xFF	; 255
    4b4a:	29 f4       	brne	.+10     	; 0x4b56 <DIO_u8TogglePortValue+0xa8>
			{
				DIO_u8SetPortValue(DIO_u8_PORTC,0x00);
    4b4c:	82 e0       	ldi	r24, 0x02	; 2
    4b4e:	60 e0       	ldi	r22, 0x00	; 0
    4b50:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b54:	15 c0       	rjmp	.+42     	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			else
			{
				DIO_u8SetPortValue(DIO_u8_PORTC,0xff);
    4b56:	82 e0       	ldi	r24, 0x02	; 2
    4b58:	6f ef       	ldi	r22, 0xFF	; 255
    4b5a:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b5e:	10 c0       	rjmp	.+32     	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			break;
		}
		case(DIO_u8_PORTD):
		{
			Local_u8TempValue = PIND_u8_REG;
    4b60:	e0 e3       	ldi	r30, 0x30	; 48
    4b62:	f0 e0       	ldi	r31, 0x00	; 0
    4b64:	80 81       	ld	r24, Z
    4b66:	89 83       	std	Y+1, r24	; 0x01
			if(Local_u8TempValue == 0xff)
    4b68:	89 81       	ldd	r24, Y+1	; 0x01
    4b6a:	8f 3f       	cpi	r24, 0xFF	; 255
    4b6c:	29 f4       	brne	.+10     	; 0x4b78 <DIO_u8TogglePortValue+0xca>
			{
				DIO_u8SetPortValue(DIO_u8_PORTD,0x00);
    4b6e:	83 e0       	ldi	r24, 0x03	; 3
    4b70:	60 e0       	ldi	r22, 0x00	; 0
    4b72:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
    4b76:	04 c0       	rjmp	.+8      	; 0x4b80 <DIO_u8TogglePortValue+0xd2>
			}
			else
			{
				DIO_u8SetPortValue(DIO_u8_PORTD,0xff);
    4b78:	83 e0       	ldi	r24, 0x03	; 3
    4b7a:	6f ef       	ldi	r22, 0xFF	; 255
    4b7c:	0e 94 b2 24 	call	0x4964	; 0x4964 <DIO_u8SetPortValue>
			}
			break;
		}
	}
}
    4b80:	0f 90       	pop	r0
    4b82:	0f 90       	pop	r0
    4b84:	0f 90       	pop	r0
    4b86:	0f 90       	pop	r0
    4b88:	cf 91       	pop	r28
    4b8a:	df 91       	pop	r29
    4b8c:	08 95       	ret

00004b8e <__divmodhi4>:
    4b8e:	97 fb       	bst	r25, 7
    4b90:	09 2e       	mov	r0, r25
    4b92:	07 26       	eor	r0, r23
    4b94:	0a d0       	rcall	.+20     	; 0x4baa <__divmodhi4_neg1>
    4b96:	77 fd       	sbrc	r23, 7
    4b98:	04 d0       	rcall	.+8      	; 0x4ba2 <__divmodhi4_neg2>
    4b9a:	0c d0       	rcall	.+24     	; 0x4bb4 <__udivmodhi4>
    4b9c:	06 d0       	rcall	.+12     	; 0x4baa <__divmodhi4_neg1>
    4b9e:	00 20       	and	r0, r0
    4ba0:	1a f4       	brpl	.+6      	; 0x4ba8 <__divmodhi4_exit>

00004ba2 <__divmodhi4_neg2>:
    4ba2:	70 95       	com	r23
    4ba4:	61 95       	neg	r22
    4ba6:	7f 4f       	sbci	r23, 0xFF	; 255

00004ba8 <__divmodhi4_exit>:
    4ba8:	08 95       	ret

00004baa <__divmodhi4_neg1>:
    4baa:	f6 f7       	brtc	.-4      	; 0x4ba8 <__divmodhi4_exit>
    4bac:	90 95       	com	r25
    4bae:	81 95       	neg	r24
    4bb0:	9f 4f       	sbci	r25, 0xFF	; 255
    4bb2:	08 95       	ret

00004bb4 <__udivmodhi4>:
    4bb4:	aa 1b       	sub	r26, r26
    4bb6:	bb 1b       	sub	r27, r27
    4bb8:	51 e1       	ldi	r21, 0x11	; 17
    4bba:	07 c0       	rjmp	.+14     	; 0x4bca <__udivmodhi4_ep>

00004bbc <__udivmodhi4_loop>:
    4bbc:	aa 1f       	adc	r26, r26
    4bbe:	bb 1f       	adc	r27, r27
    4bc0:	a6 17       	cp	r26, r22
    4bc2:	b7 07       	cpc	r27, r23
    4bc4:	10 f0       	brcs	.+4      	; 0x4bca <__udivmodhi4_ep>
    4bc6:	a6 1b       	sub	r26, r22
    4bc8:	b7 0b       	sbc	r27, r23

00004bca <__udivmodhi4_ep>:
    4bca:	88 1f       	adc	r24, r24
    4bcc:	99 1f       	adc	r25, r25
    4bce:	5a 95       	dec	r21
    4bd0:	a9 f7       	brne	.-22     	; 0x4bbc <__udivmodhi4_loop>
    4bd2:	80 95       	com	r24
    4bd4:	90 95       	com	r25
    4bd6:	bc 01       	movw	r22, r24
    4bd8:	cd 01       	movw	r24, r26
    4bda:	08 95       	ret

00004bdc <__prologue_saves__>:
    4bdc:	2f 92       	push	r2
    4bde:	3f 92       	push	r3
    4be0:	4f 92       	push	r4
    4be2:	5f 92       	push	r5
    4be4:	6f 92       	push	r6
    4be6:	7f 92       	push	r7
    4be8:	8f 92       	push	r8
    4bea:	9f 92       	push	r9
    4bec:	af 92       	push	r10
    4bee:	bf 92       	push	r11
    4bf0:	cf 92       	push	r12
    4bf2:	df 92       	push	r13
    4bf4:	ef 92       	push	r14
    4bf6:	ff 92       	push	r15
    4bf8:	0f 93       	push	r16
    4bfa:	1f 93       	push	r17
    4bfc:	cf 93       	push	r28
    4bfe:	df 93       	push	r29
    4c00:	cd b7       	in	r28, 0x3d	; 61
    4c02:	de b7       	in	r29, 0x3e	; 62
    4c04:	ca 1b       	sub	r28, r26
    4c06:	db 0b       	sbc	r29, r27
    4c08:	0f b6       	in	r0, 0x3f	; 63
    4c0a:	f8 94       	cli
    4c0c:	de bf       	out	0x3e, r29	; 62
    4c0e:	0f be       	out	0x3f, r0	; 63
    4c10:	cd bf       	out	0x3d, r28	; 61
    4c12:	09 94       	ijmp

00004c14 <__epilogue_restores__>:
    4c14:	2a 88       	ldd	r2, Y+18	; 0x12
    4c16:	39 88       	ldd	r3, Y+17	; 0x11
    4c18:	48 88       	ldd	r4, Y+16	; 0x10
    4c1a:	5f 84       	ldd	r5, Y+15	; 0x0f
    4c1c:	6e 84       	ldd	r6, Y+14	; 0x0e
    4c1e:	7d 84       	ldd	r7, Y+13	; 0x0d
    4c20:	8c 84       	ldd	r8, Y+12	; 0x0c
    4c22:	9b 84       	ldd	r9, Y+11	; 0x0b
    4c24:	aa 84       	ldd	r10, Y+10	; 0x0a
    4c26:	b9 84       	ldd	r11, Y+9	; 0x09
    4c28:	c8 84       	ldd	r12, Y+8	; 0x08
    4c2a:	df 80       	ldd	r13, Y+7	; 0x07
    4c2c:	ee 80       	ldd	r14, Y+6	; 0x06
    4c2e:	fd 80       	ldd	r15, Y+5	; 0x05
    4c30:	0c 81       	ldd	r16, Y+4	; 0x04
    4c32:	1b 81       	ldd	r17, Y+3	; 0x03
    4c34:	aa 81       	ldd	r26, Y+2	; 0x02
    4c36:	b9 81       	ldd	r27, Y+1	; 0x01
    4c38:	ce 0f       	add	r28, r30
    4c3a:	d1 1d       	adc	r29, r1
    4c3c:	0f b6       	in	r0, 0x3f	; 63
    4c3e:	f8 94       	cli
    4c40:	de bf       	out	0x3e, r29	; 62
    4c42:	0f be       	out	0x3f, r0	; 63
    4c44:	cd bf       	out	0x3d, r28	; 61
    4c46:	ed 01       	movw	r28, r26
    4c48:	08 95       	ret

00004c4a <memcpy>:
    4c4a:	fb 01       	movw	r30, r22
    4c4c:	dc 01       	movw	r26, r24
    4c4e:	02 c0       	rjmp	.+4      	; 0x4c54 <memcpy+0xa>
    4c50:	01 90       	ld	r0, Z+
    4c52:	0d 92       	st	X+, r0
    4c54:	41 50       	subi	r20, 0x01	; 1
    4c56:	50 40       	sbci	r21, 0x00	; 0
    4c58:	d8 f7       	brcc	.-10     	; 0x4c50 <memcpy+0x6>
    4c5a:	08 95       	ret

00004c5c <memset>:
    4c5c:	dc 01       	movw	r26, r24
    4c5e:	01 c0       	rjmp	.+2      	; 0x4c62 <memset+0x6>
    4c60:	6d 93       	st	X+, r22
    4c62:	41 50       	subi	r20, 0x01	; 1
    4c64:	50 40       	sbci	r21, 0x00	; 0
    4c66:	e0 f7       	brcc	.-8      	; 0x4c60 <memset+0x4>
    4c68:	08 95       	ret

00004c6a <strlen>:
    4c6a:	fc 01       	movw	r30, r24
    4c6c:	01 90       	ld	r0, Z+
    4c6e:	00 20       	and	r0, r0
    4c70:	e9 f7       	brne	.-6      	; 0x4c6c <strlen+0x2>
    4c72:	80 95       	com	r24
    4c74:	90 95       	com	r25
    4c76:	8e 0f       	add	r24, r30
    4c78:	9f 1f       	adc	r25, r31
    4c7a:	08 95       	ret

00004c7c <strncpy>:
    4c7c:	fb 01       	movw	r30, r22
    4c7e:	dc 01       	movw	r26, r24
    4c80:	41 50       	subi	r20, 0x01	; 1
    4c82:	50 40       	sbci	r21, 0x00	; 0
    4c84:	48 f0       	brcs	.+18     	; 0x4c98 <strncpy+0x1c>
    4c86:	01 90       	ld	r0, Z+
    4c88:	0d 92       	st	X+, r0
    4c8a:	00 20       	and	r0, r0
    4c8c:	c9 f7       	brne	.-14     	; 0x4c80 <strncpy+0x4>
    4c8e:	01 c0       	rjmp	.+2      	; 0x4c92 <strncpy+0x16>
    4c90:	1d 92       	st	X+, r1
    4c92:	41 50       	subi	r20, 0x01	; 1
    4c94:	50 40       	sbci	r21, 0x00	; 0
    4c96:	e0 f7       	brcc	.-8      	; 0x4c90 <strncpy+0x14>
    4c98:	08 95       	ret

00004c9a <_exit>:
    4c9a:	f8 94       	cli

00004c9c <__stop_program>:
    4c9c:	ff cf       	rjmp	.-2      	; 0x4c9c <__stop_program>
